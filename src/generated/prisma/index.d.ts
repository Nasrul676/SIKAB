
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Suppliers
 * 
 */
export type Suppliers = $Result.DefaultSelection<Prisma.$SuppliersPayload>
/**
 * Model Materials
 * 
 */
export type Materials = $Result.DefaultSelection<Prisma.$MaterialsPayload>
/**
 * Model Conditions
 * 
 */
export type Conditions = $Result.DefaultSelection<Prisma.$ConditionsPayload>
/**
 * Model Parameters
 * 
 */
export type Parameters = $Result.DefaultSelection<Prisma.$ParametersPayload>
/**
 * Model Arrivals
 * 
 */
export type Arrivals = $Result.DefaultSelection<Prisma.$ArrivalsPayload>
/**
 * Model ArrivalItems
 * 
 */
export type ArrivalItems = $Result.DefaultSelection<Prisma.$ArrivalItemsPayload>
/**
 * Model Weighings
 * 
 */
export type Weighings = $Result.DefaultSelection<Prisma.$WeighingsPayload>
/**
 * Model Notifications
 * 
 */
export type Notifications = $Result.DefaultSelection<Prisma.$NotificationsPayload>
/**
 * Model QcResults
 * 
 */
export type QcResults = $Result.DefaultSelection<Prisma.$QcResultsPayload>
/**
 * Model QcStatus
 * 
 */
export type QcStatus = $Result.DefaultSelection<Prisma.$QcStatusPayload>
/**
 * Model QcPhotos
 * 
 */
export type QcPhotos = $Result.DefaultSelection<Prisma.$QcPhotosPayload>
/**
 * Model SecurityPhotos
 * 
 */
export type SecurityPhotos = $Result.DefaultSelection<Prisma.$SecurityPhotosPayload>
/**
 * Model WeighingsPhotos
 * 
 */
export type WeighingsPhotos = $Result.DefaultSelection<Prisma.$WeighingsPhotosPayload>
/**
 * Model QcHistories
 * 
 */
export type QcHistories = $Result.DefaultSelection<Prisma.$QcHistoriesPayload>
/**
 * Model ArrivalStatuses
 * 
 */
export type ArrivalStatuses = $Result.DefaultSelection<Prisma.$ArrivalStatusesPayload>
/**
 * Model ParameterSettings
 * 
 */
export type ParameterSettings = $Result.DefaultSelection<Prisma.$ParameterSettingsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suppliers`: Exposes CRUD operations for the **Suppliers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.suppliers.findMany()
    * ```
    */
  get suppliers(): Prisma.SuppliersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materials`: Exposes CRUD operations for the **Materials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.materials.findMany()
    * ```
    */
  get materials(): Prisma.MaterialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conditions`: Exposes CRUD operations for the **Conditions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conditions
    * const conditions = await prisma.conditions.findMany()
    * ```
    */
  get conditions(): Prisma.ConditionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parameters`: Exposes CRUD operations for the **Parameters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parameters
    * const parameters = await prisma.parameters.findMany()
    * ```
    */
  get parameters(): Prisma.ParametersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.arrivals`: Exposes CRUD operations for the **Arrivals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Arrivals
    * const arrivals = await prisma.arrivals.findMany()
    * ```
    */
  get arrivals(): Prisma.ArrivalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.arrivalItems`: Exposes CRUD operations for the **ArrivalItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArrivalItems
    * const arrivalItems = await prisma.arrivalItems.findMany()
    * ```
    */
  get arrivalItems(): Prisma.ArrivalItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weighings`: Exposes CRUD operations for the **Weighings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weighings
    * const weighings = await prisma.weighings.findMany()
    * ```
    */
  get weighings(): Prisma.WeighingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qcResults`: Exposes CRUD operations for the **QcResults** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QcResults
    * const qcResults = await prisma.qcResults.findMany()
    * ```
    */
  get qcResults(): Prisma.QcResultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qcStatus`: Exposes CRUD operations for the **QcStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QcStatuses
    * const qcStatuses = await prisma.qcStatus.findMany()
    * ```
    */
  get qcStatus(): Prisma.QcStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qcPhotos`: Exposes CRUD operations for the **QcPhotos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QcPhotos
    * const qcPhotos = await prisma.qcPhotos.findMany()
    * ```
    */
  get qcPhotos(): Prisma.QcPhotosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityPhotos`: Exposes CRUD operations for the **SecurityPhotos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityPhotos
    * const securityPhotos = await prisma.securityPhotos.findMany()
    * ```
    */
  get securityPhotos(): Prisma.SecurityPhotosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weighingsPhotos`: Exposes CRUD operations for the **WeighingsPhotos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeighingsPhotos
    * const weighingsPhotos = await prisma.weighingsPhotos.findMany()
    * ```
    */
  get weighingsPhotos(): Prisma.WeighingsPhotosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qcHistories`: Exposes CRUD operations for the **QcHistories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QcHistories
    * const qcHistories = await prisma.qcHistories.findMany()
    * ```
    */
  get qcHistories(): Prisma.QcHistoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.arrivalStatuses`: Exposes CRUD operations for the **ArrivalStatuses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArrivalStatuses
    * const arrivalStatuses = await prisma.arrivalStatuses.findMany()
    * ```
    */
  get arrivalStatuses(): Prisma.ArrivalStatusesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parameterSettings`: Exposes CRUD operations for the **ParameterSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParameterSettings
    * const parameterSettings = await prisma.parameterSettings.findMany()
    * ```
    */
  get parameterSettings(): Prisma.ParameterSettingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Users: 'Users',
    Suppliers: 'Suppliers',
    Materials: 'Materials',
    Conditions: 'Conditions',
    Parameters: 'Parameters',
    Arrivals: 'Arrivals',
    ArrivalItems: 'ArrivalItems',
    Weighings: 'Weighings',
    Notifications: 'Notifications',
    QcResults: 'QcResults',
    QcStatus: 'QcStatus',
    QcPhotos: 'QcPhotos',
    SecurityPhotos: 'SecurityPhotos',
    WeighingsPhotos: 'WeighingsPhotos',
    QcHistories: 'QcHistories',
    ArrivalStatuses: 'ArrivalStatuses',
    ParameterSettings: 'ParameterSettings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "suppliers" | "materials" | "conditions" | "parameters" | "arrivals" | "arrivalItems" | "weighings" | "notifications" | "qcResults" | "qcStatus" | "qcPhotos" | "securityPhotos" | "weighingsPhotos" | "qcHistories" | "arrivalStatuses" | "parameterSettings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Suppliers: {
        payload: Prisma.$SuppliersPayload<ExtArgs>
        fields: Prisma.SuppliersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuppliersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuppliersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          findFirst: {
            args: Prisma.SuppliersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuppliersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          findMany: {
            args: Prisma.SuppliersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>[]
          }
          create: {
            args: Prisma.SuppliersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          createMany: {
            args: Prisma.SuppliersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SuppliersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          update: {
            args: Prisma.SuppliersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          deleteMany: {
            args: Prisma.SuppliersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuppliersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SuppliersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          aggregate: {
            args: Prisma.SuppliersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuppliers>
          }
          groupBy: {
            args: Prisma.SuppliersGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuppliersGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuppliersCountArgs<ExtArgs>
            result: $Utils.Optional<SuppliersCountAggregateOutputType> | number
          }
        }
      }
      Materials: {
        payload: Prisma.$MaterialsPayload<ExtArgs>
        fields: Prisma.MaterialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          findFirst: {
            args: Prisma.MaterialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          findMany: {
            args: Prisma.MaterialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>[]
          }
          create: {
            args: Prisma.MaterialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          createMany: {
            args: Prisma.MaterialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          update: {
            args: Prisma.MaterialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          deleteMany: {
            args: Prisma.MaterialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          aggregate: {
            args: Prisma.MaterialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterials>
          }
          groupBy: {
            args: Prisma.MaterialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialsCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialsCountAggregateOutputType> | number
          }
        }
      }
      Conditions: {
        payload: Prisma.$ConditionsPayload<ExtArgs>
        fields: Prisma.ConditionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConditionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConditionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionsPayload>
          }
          findFirst: {
            args: Prisma.ConditionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConditionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionsPayload>
          }
          findMany: {
            args: Prisma.ConditionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionsPayload>[]
          }
          create: {
            args: Prisma.ConditionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionsPayload>
          }
          createMany: {
            args: Prisma.ConditionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConditionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionsPayload>
          }
          update: {
            args: Prisma.ConditionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionsPayload>
          }
          deleteMany: {
            args: Prisma.ConditionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConditionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConditionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionsPayload>
          }
          aggregate: {
            args: Prisma.ConditionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConditions>
          }
          groupBy: {
            args: Prisma.ConditionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConditionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConditionsCountArgs<ExtArgs>
            result: $Utils.Optional<ConditionsCountAggregateOutputType> | number
          }
        }
      }
      Parameters: {
        payload: Prisma.$ParametersPayload<ExtArgs>
        fields: Prisma.ParametersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParametersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParametersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametersPayload>
          }
          findFirst: {
            args: Prisma.ParametersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParametersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametersPayload>
          }
          findMany: {
            args: Prisma.ParametersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametersPayload>[]
          }
          create: {
            args: Prisma.ParametersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametersPayload>
          }
          createMany: {
            args: Prisma.ParametersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParametersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametersPayload>
          }
          update: {
            args: Prisma.ParametersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametersPayload>
          }
          deleteMany: {
            args: Prisma.ParametersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParametersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParametersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametersPayload>
          }
          aggregate: {
            args: Prisma.ParametersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParameters>
          }
          groupBy: {
            args: Prisma.ParametersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParametersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParametersCountArgs<ExtArgs>
            result: $Utils.Optional<ParametersCountAggregateOutputType> | number
          }
        }
      }
      Arrivals: {
        payload: Prisma.$ArrivalsPayload<ExtArgs>
        fields: Prisma.ArrivalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArrivalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArrivalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalsPayload>
          }
          findFirst: {
            args: Prisma.ArrivalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArrivalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalsPayload>
          }
          findMany: {
            args: Prisma.ArrivalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalsPayload>[]
          }
          create: {
            args: Prisma.ArrivalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalsPayload>
          }
          createMany: {
            args: Prisma.ArrivalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ArrivalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalsPayload>
          }
          update: {
            args: Prisma.ArrivalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalsPayload>
          }
          deleteMany: {
            args: Prisma.ArrivalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArrivalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArrivalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalsPayload>
          }
          aggregate: {
            args: Prisma.ArrivalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArrivals>
          }
          groupBy: {
            args: Prisma.ArrivalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArrivalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArrivalsCountArgs<ExtArgs>
            result: $Utils.Optional<ArrivalsCountAggregateOutputType> | number
          }
        }
      }
      ArrivalItems: {
        payload: Prisma.$ArrivalItemsPayload<ExtArgs>
        fields: Prisma.ArrivalItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArrivalItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArrivalItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalItemsPayload>
          }
          findFirst: {
            args: Prisma.ArrivalItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArrivalItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalItemsPayload>
          }
          findMany: {
            args: Prisma.ArrivalItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalItemsPayload>[]
          }
          create: {
            args: Prisma.ArrivalItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalItemsPayload>
          }
          createMany: {
            args: Prisma.ArrivalItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ArrivalItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalItemsPayload>
          }
          update: {
            args: Prisma.ArrivalItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalItemsPayload>
          }
          deleteMany: {
            args: Prisma.ArrivalItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArrivalItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArrivalItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalItemsPayload>
          }
          aggregate: {
            args: Prisma.ArrivalItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArrivalItems>
          }
          groupBy: {
            args: Prisma.ArrivalItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArrivalItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArrivalItemsCountArgs<ExtArgs>
            result: $Utils.Optional<ArrivalItemsCountAggregateOutputType> | number
          }
        }
      }
      Weighings: {
        payload: Prisma.$WeighingsPayload<ExtArgs>
        fields: Prisma.WeighingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeighingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeighingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPayload>
          }
          findFirst: {
            args: Prisma.WeighingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeighingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPayload>
          }
          findMany: {
            args: Prisma.WeighingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPayload>[]
          }
          create: {
            args: Prisma.WeighingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPayload>
          }
          createMany: {
            args: Prisma.WeighingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WeighingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPayload>
          }
          update: {
            args: Prisma.WeighingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPayload>
          }
          deleteMany: {
            args: Prisma.WeighingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeighingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeighingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPayload>
          }
          aggregate: {
            args: Prisma.WeighingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeighings>
          }
          groupBy: {
            args: Prisma.WeighingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeighingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeighingsCountArgs<ExtArgs>
            result: $Utils.Optional<WeighingsCountAggregateOutputType> | number
          }
        }
      }
      Notifications: {
        payload: Prisma.$NotificationsPayload<ExtArgs>
        fields: Prisma.NotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findFirst: {
            args: Prisma.NotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findMany: {
            args: Prisma.NotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          create: {
            args: Prisma.NotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          createMany: {
            args: Prisma.NotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          update: {
            args: Prisma.NotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.NotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      QcResults: {
        payload: Prisma.$QcResultsPayload<ExtArgs>
        fields: Prisma.QcResultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QcResultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QcResultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultsPayload>
          }
          findFirst: {
            args: Prisma.QcResultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QcResultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultsPayload>
          }
          findMany: {
            args: Prisma.QcResultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultsPayload>[]
          }
          create: {
            args: Prisma.QcResultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultsPayload>
          }
          createMany: {
            args: Prisma.QcResultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QcResultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultsPayload>
          }
          update: {
            args: Prisma.QcResultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultsPayload>
          }
          deleteMany: {
            args: Prisma.QcResultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QcResultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QcResultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultsPayload>
          }
          aggregate: {
            args: Prisma.QcResultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQcResults>
          }
          groupBy: {
            args: Prisma.QcResultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QcResultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QcResultsCountArgs<ExtArgs>
            result: $Utils.Optional<QcResultsCountAggregateOutputType> | number
          }
        }
      }
      QcStatus: {
        payload: Prisma.$QcStatusPayload<ExtArgs>
        fields: Prisma.QcStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QcStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QcStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcStatusPayload>
          }
          findFirst: {
            args: Prisma.QcStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QcStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcStatusPayload>
          }
          findMany: {
            args: Prisma.QcStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcStatusPayload>[]
          }
          create: {
            args: Prisma.QcStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcStatusPayload>
          }
          createMany: {
            args: Prisma.QcStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QcStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcStatusPayload>
          }
          update: {
            args: Prisma.QcStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcStatusPayload>
          }
          deleteMany: {
            args: Prisma.QcStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QcStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QcStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcStatusPayload>
          }
          aggregate: {
            args: Prisma.QcStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQcStatus>
          }
          groupBy: {
            args: Prisma.QcStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<QcStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.QcStatusCountArgs<ExtArgs>
            result: $Utils.Optional<QcStatusCountAggregateOutputType> | number
          }
        }
      }
      QcPhotos: {
        payload: Prisma.$QcPhotosPayload<ExtArgs>
        fields: Prisma.QcPhotosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QcPhotosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcPhotosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QcPhotosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcPhotosPayload>
          }
          findFirst: {
            args: Prisma.QcPhotosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcPhotosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QcPhotosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcPhotosPayload>
          }
          findMany: {
            args: Prisma.QcPhotosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcPhotosPayload>[]
          }
          create: {
            args: Prisma.QcPhotosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcPhotosPayload>
          }
          createMany: {
            args: Prisma.QcPhotosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QcPhotosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcPhotosPayload>
          }
          update: {
            args: Prisma.QcPhotosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcPhotosPayload>
          }
          deleteMany: {
            args: Prisma.QcPhotosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QcPhotosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QcPhotosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcPhotosPayload>
          }
          aggregate: {
            args: Prisma.QcPhotosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQcPhotos>
          }
          groupBy: {
            args: Prisma.QcPhotosGroupByArgs<ExtArgs>
            result: $Utils.Optional<QcPhotosGroupByOutputType>[]
          }
          count: {
            args: Prisma.QcPhotosCountArgs<ExtArgs>
            result: $Utils.Optional<QcPhotosCountAggregateOutputType> | number
          }
        }
      }
      SecurityPhotos: {
        payload: Prisma.$SecurityPhotosPayload<ExtArgs>
        fields: Prisma.SecurityPhotosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityPhotosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityPhotosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityPhotosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityPhotosPayload>
          }
          findFirst: {
            args: Prisma.SecurityPhotosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityPhotosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityPhotosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityPhotosPayload>
          }
          findMany: {
            args: Prisma.SecurityPhotosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityPhotosPayload>[]
          }
          create: {
            args: Prisma.SecurityPhotosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityPhotosPayload>
          }
          createMany: {
            args: Prisma.SecurityPhotosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SecurityPhotosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityPhotosPayload>
          }
          update: {
            args: Prisma.SecurityPhotosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityPhotosPayload>
          }
          deleteMany: {
            args: Prisma.SecurityPhotosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityPhotosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SecurityPhotosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityPhotosPayload>
          }
          aggregate: {
            args: Prisma.SecurityPhotosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityPhotos>
          }
          groupBy: {
            args: Prisma.SecurityPhotosGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityPhotosGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityPhotosCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityPhotosCountAggregateOutputType> | number
          }
        }
      }
      WeighingsPhotos: {
        payload: Prisma.$WeighingsPhotosPayload<ExtArgs>
        fields: Prisma.WeighingsPhotosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeighingsPhotosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPhotosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeighingsPhotosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPhotosPayload>
          }
          findFirst: {
            args: Prisma.WeighingsPhotosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPhotosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeighingsPhotosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPhotosPayload>
          }
          findMany: {
            args: Prisma.WeighingsPhotosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPhotosPayload>[]
          }
          create: {
            args: Prisma.WeighingsPhotosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPhotosPayload>
          }
          createMany: {
            args: Prisma.WeighingsPhotosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WeighingsPhotosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPhotosPayload>
          }
          update: {
            args: Prisma.WeighingsPhotosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPhotosPayload>
          }
          deleteMany: {
            args: Prisma.WeighingsPhotosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeighingsPhotosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeighingsPhotosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeighingsPhotosPayload>
          }
          aggregate: {
            args: Prisma.WeighingsPhotosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeighingsPhotos>
          }
          groupBy: {
            args: Prisma.WeighingsPhotosGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeighingsPhotosGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeighingsPhotosCountArgs<ExtArgs>
            result: $Utils.Optional<WeighingsPhotosCountAggregateOutputType> | number
          }
        }
      }
      QcHistories: {
        payload: Prisma.$QcHistoriesPayload<ExtArgs>
        fields: Prisma.QcHistoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QcHistoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcHistoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QcHistoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcHistoriesPayload>
          }
          findFirst: {
            args: Prisma.QcHistoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcHistoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QcHistoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcHistoriesPayload>
          }
          findMany: {
            args: Prisma.QcHistoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcHistoriesPayload>[]
          }
          create: {
            args: Prisma.QcHistoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcHistoriesPayload>
          }
          createMany: {
            args: Prisma.QcHistoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QcHistoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcHistoriesPayload>
          }
          update: {
            args: Prisma.QcHistoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcHistoriesPayload>
          }
          deleteMany: {
            args: Prisma.QcHistoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QcHistoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QcHistoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcHistoriesPayload>
          }
          aggregate: {
            args: Prisma.QcHistoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQcHistories>
          }
          groupBy: {
            args: Prisma.QcHistoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<QcHistoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.QcHistoriesCountArgs<ExtArgs>
            result: $Utils.Optional<QcHistoriesCountAggregateOutputType> | number
          }
        }
      }
      ArrivalStatuses: {
        payload: Prisma.$ArrivalStatusesPayload<ExtArgs>
        fields: Prisma.ArrivalStatusesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArrivalStatusesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalStatusesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArrivalStatusesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalStatusesPayload>
          }
          findFirst: {
            args: Prisma.ArrivalStatusesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalStatusesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArrivalStatusesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalStatusesPayload>
          }
          findMany: {
            args: Prisma.ArrivalStatusesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalStatusesPayload>[]
          }
          create: {
            args: Prisma.ArrivalStatusesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalStatusesPayload>
          }
          createMany: {
            args: Prisma.ArrivalStatusesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ArrivalStatusesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalStatusesPayload>
          }
          update: {
            args: Prisma.ArrivalStatusesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalStatusesPayload>
          }
          deleteMany: {
            args: Prisma.ArrivalStatusesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArrivalStatusesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArrivalStatusesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArrivalStatusesPayload>
          }
          aggregate: {
            args: Prisma.ArrivalStatusesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArrivalStatuses>
          }
          groupBy: {
            args: Prisma.ArrivalStatusesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArrivalStatusesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArrivalStatusesCountArgs<ExtArgs>
            result: $Utils.Optional<ArrivalStatusesCountAggregateOutputType> | number
          }
        }
      }
      ParameterSettings: {
        payload: Prisma.$ParameterSettingsPayload<ExtArgs>
        fields: Prisma.ParameterSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParameterSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParameterSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterSettingsPayload>
          }
          findFirst: {
            args: Prisma.ParameterSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParameterSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterSettingsPayload>
          }
          findMany: {
            args: Prisma.ParameterSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterSettingsPayload>[]
          }
          create: {
            args: Prisma.ParameterSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterSettingsPayload>
          }
          createMany: {
            args: Prisma.ParameterSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParameterSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterSettingsPayload>
          }
          update: {
            args: Prisma.ParameterSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterSettingsPayload>
          }
          deleteMany: {
            args: Prisma.ParameterSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParameterSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParameterSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterSettingsPayload>
          }
          aggregate: {
            args: Prisma.ParameterSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParameterSettings>
          }
          groupBy: {
            args: Prisma.ParameterSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParameterSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParameterSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<ParameterSettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: UsersOmit
    suppliers?: SuppliersOmit
    materials?: MaterialsOmit
    conditions?: ConditionsOmit
    parameters?: ParametersOmit
    arrivals?: ArrivalsOmit
    arrivalItems?: ArrivalItemsOmit
    weighings?: WeighingsOmit
    notifications?: NotificationsOmit
    qcResults?: QcResultsOmit
    qcStatus?: QcStatusOmit
    qcPhotos?: QcPhotosOmit
    securityPhotos?: SecurityPhotosOmit
    weighingsPhotos?: WeighingsPhotosOmit
    qcHistories?: QcHistoriesOmit
    arrivalStatuses?: ArrivalStatusesOmit
    parameterSettings?: ParameterSettingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    QcHistories: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QcHistories?: boolean | UsersCountOutputTypeCountQcHistoriesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountQcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcHistoriesWhereInput
  }


  /**
   * Count Type SuppliersCountOutputType
   */

  export type SuppliersCountOutputType = {
    Arrivals: number
  }

  export type SuppliersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Arrivals?: boolean | SuppliersCountOutputTypeCountArrivalsArgs
  }

  // Custom InputTypes
  /**
   * SuppliersCountOutputType without action
   */
  export type SuppliersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuppliersCountOutputType
     */
    select?: SuppliersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuppliersCountOutputType without action
   */
  export type SuppliersCountOutputTypeCountArrivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalsWhereInput
  }


  /**
   * Count Type MaterialsCountOutputType
   */

  export type MaterialsCountOutputType = {
    ArrivalItems: number
  }

  export type MaterialsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ArrivalItems?: boolean | MaterialsCountOutputTypeCountArrivalItemsArgs
  }

  // Custom InputTypes
  /**
   * MaterialsCountOutputType without action
   */
  export type MaterialsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialsCountOutputType
     */
    select?: MaterialsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialsCountOutputType without action
   */
  export type MaterialsCountOutputTypeCountArrivalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalItemsWhereInput
  }


  /**
   * Count Type ConditionsCountOutputType
   */

  export type ConditionsCountOutputType = {
    ArrivalItems: number
  }

  export type ConditionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ArrivalItems?: boolean | ConditionsCountOutputTypeCountArrivalItemsArgs
  }

  // Custom InputTypes
  /**
   * ConditionsCountOutputType without action
   */
  export type ConditionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionsCountOutputType
     */
    select?: ConditionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConditionsCountOutputType without action
   */
  export type ConditionsCountOutputTypeCountArrivalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalItemsWhereInput
  }


  /**
   * Count Type ParametersCountOutputType
   */

  export type ParametersCountOutputType = {
    ArrivalItems: number
    QcResults: number
    settings: number
  }

  export type ParametersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ArrivalItems?: boolean | ParametersCountOutputTypeCountArrivalItemsArgs
    QcResults?: boolean | ParametersCountOutputTypeCountQcResultsArgs
    settings?: boolean | ParametersCountOutputTypeCountSettingsArgs
  }

  // Custom InputTypes
  /**
   * ParametersCountOutputType without action
   */
  export type ParametersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametersCountOutputType
     */
    select?: ParametersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParametersCountOutputType without action
   */
  export type ParametersCountOutputTypeCountArrivalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalItemsWhereInput
  }

  /**
   * ParametersCountOutputType without action
   */
  export type ParametersCountOutputTypeCountQcResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcResultsWhereInput
  }

  /**
   * ParametersCountOutputType without action
   */
  export type ParametersCountOutputTypeCountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParameterSettingsWhereInput
  }


  /**
   * Count Type ArrivalsCountOutputType
   */

  export type ArrivalsCountOutputType = {
    ArrivalItems: number
    QcHistories: number
    SecurityPhotos: number
  }

  export type ArrivalsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ArrivalItems?: boolean | ArrivalsCountOutputTypeCountArrivalItemsArgs
    QcHistories?: boolean | ArrivalsCountOutputTypeCountQcHistoriesArgs
    SecurityPhotos?: boolean | ArrivalsCountOutputTypeCountSecurityPhotosArgs
  }

  // Custom InputTypes
  /**
   * ArrivalsCountOutputType without action
   */
  export type ArrivalsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalsCountOutputType
     */
    select?: ArrivalsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArrivalsCountOutputType without action
   */
  export type ArrivalsCountOutputTypeCountArrivalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalItemsWhereInput
  }

  /**
   * ArrivalsCountOutputType without action
   */
  export type ArrivalsCountOutputTypeCountQcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcHistoriesWhereInput
  }

  /**
   * ArrivalsCountOutputType without action
   */
  export type ArrivalsCountOutputTypeCountSecurityPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityPhotosWhereInput
  }


  /**
   * Count Type ArrivalItemsCountOutputType
   */

  export type ArrivalItemsCountOutputType = {
    QcResults: number
    QcPhotos: number
    Weighings: number
    WeighingsPhotos: number
    QcHistories: number
  }

  export type ArrivalItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QcResults?: boolean | ArrivalItemsCountOutputTypeCountQcResultsArgs
    QcPhotos?: boolean | ArrivalItemsCountOutputTypeCountQcPhotosArgs
    Weighings?: boolean | ArrivalItemsCountOutputTypeCountWeighingsArgs
    WeighingsPhotos?: boolean | ArrivalItemsCountOutputTypeCountWeighingsPhotosArgs
    QcHistories?: boolean | ArrivalItemsCountOutputTypeCountQcHistoriesArgs
  }

  // Custom InputTypes
  /**
   * ArrivalItemsCountOutputType without action
   */
  export type ArrivalItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItemsCountOutputType
     */
    select?: ArrivalItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArrivalItemsCountOutputType without action
   */
  export type ArrivalItemsCountOutputTypeCountQcResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcResultsWhereInput
  }

  /**
   * ArrivalItemsCountOutputType without action
   */
  export type ArrivalItemsCountOutputTypeCountQcPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcPhotosWhereInput
  }

  /**
   * ArrivalItemsCountOutputType without action
   */
  export type ArrivalItemsCountOutputTypeCountWeighingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeighingsWhereInput
  }

  /**
   * ArrivalItemsCountOutputType without action
   */
  export type ArrivalItemsCountOutputTypeCountWeighingsPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeighingsPhotosWhereInput
  }

  /**
   * ArrivalItemsCountOutputType without action
   */
  export type ArrivalItemsCountOutputTypeCountQcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcHistoriesWhereInput
  }


  /**
   * Count Type QcStatusCountOutputType
   */

  export type QcStatusCountOutputType = {
    ArrivalItems: number
    QcHistories: number
  }

  export type QcStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ArrivalItems?: boolean | QcStatusCountOutputTypeCountArrivalItemsArgs
    QcHistories?: boolean | QcStatusCountOutputTypeCountQcHistoriesArgs
  }

  // Custom InputTypes
  /**
   * QcStatusCountOutputType without action
   */
  export type QcStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatusCountOutputType
     */
    select?: QcStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QcStatusCountOutputType without action
   */
  export type QcStatusCountOutputTypeCountArrivalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalItemsWhereInput
  }

  /**
   * QcStatusCountOutputType without action
   */
  export type QcStatusCountOutputTypeCountQcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcHistoriesWhereInput
  }


  /**
   * Count Type QcHistoriesCountOutputType
   */

  export type QcHistoriesCountOutputType = {
    QcResults: number
  }

  export type QcHistoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QcResults?: boolean | QcHistoriesCountOutputTypeCountQcResultsArgs
  }

  // Custom InputTypes
  /**
   * QcHistoriesCountOutputType without action
   */
  export type QcHistoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistoriesCountOutputType
     */
    select?: QcHistoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QcHistoriesCountOutputType without action
   */
  export type QcHistoriesCountOutputTypeCountQcResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcResultsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    username: string | null
    email: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type UsersMaxAggregateOutputType = {
    username: string | null
    email: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type UsersCountAggregateOutputType = {
    username: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    id: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    username?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UsersMaxAggregateInputType = {
    username?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UsersCountAggregateInputType = {
    username?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    username: string
    email: string
    password: string
    role: string
    createdAt: Date
    updatedAt: Date
    id: string
    createdBy: string | null
    updatedBy: string | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    username?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    QcHistories?: boolean | Users$QcHistoriesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type UsersSelectScalar = {
    username?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"username" | "email" | "password" | "role" | "createdAt" | "updatedAt" | "id" | "createdBy" | "updatedBy", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QcHistories?: boolean | Users$QcHistoriesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      QcHistories: Prisma.$QcHistoriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      username: string
      email: string
      password: string
      role: string
      createdAt: Date
      updatedAt: Date
      id: string
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const usersWithUsernameOnly = await prisma.users.findMany({ select: { username: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    QcHistories<T extends Users$QcHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Users$QcHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly username: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly role: FieldRef<"Users", 'String'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
    readonly id: FieldRef<"Users", 'String'>
    readonly createdBy: FieldRef<"Users", 'String'>
    readonly updatedBy: FieldRef<"Users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.QcHistories
   */
  export type Users$QcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    where?: QcHistoriesWhereInput
    orderBy?: QcHistoriesOrderByWithRelationInput | QcHistoriesOrderByWithRelationInput[]
    cursor?: QcHistoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcHistoriesScalarFieldEnum | QcHistoriesScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Suppliers
   */

  export type AggregateSuppliers = {
    _count: SuppliersCountAggregateOutputType | null
    _avg: SuppliersAvgAggregateOutputType | null
    _sum: SuppliersSumAggregateOutputType | null
    _min: SuppliersMinAggregateOutputType | null
    _max: SuppliersMaxAggregateOutputType | null
  }

  export type SuppliersAvgAggregateOutputType = {
    id: number | null
  }

  export type SuppliersSumAggregateOutputType = {
    id: number | null
  }

  export type SuppliersMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SuppliersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SuppliersCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    email: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SuppliersAvgAggregateInputType = {
    id?: true
  }

  export type SuppliersSumAggregateInputType = {
    id?: true
  }

  export type SuppliersMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SuppliersMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SuppliersCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SuppliersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to aggregate.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SuppliersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuppliersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuppliersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuppliersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuppliersMaxAggregateInputType
  }

  export type GetSuppliersAggregateType<T extends SuppliersAggregateArgs> = {
        [P in keyof T & keyof AggregateSuppliers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuppliers[P]>
      : GetScalarType<T[P], AggregateSuppliers[P]>
  }




  export type SuppliersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuppliersWhereInput
    orderBy?: SuppliersOrderByWithAggregationInput | SuppliersOrderByWithAggregationInput[]
    by: SuppliersScalarFieldEnum[] | SuppliersScalarFieldEnum
    having?: SuppliersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuppliersCountAggregateInputType | true
    _avg?: SuppliersAvgAggregateInputType
    _sum?: SuppliersSumAggregateInputType
    _min?: SuppliersMinAggregateInputType
    _max?: SuppliersMaxAggregateInputType
  }

  export type SuppliersGroupByOutputType = {
    id: number
    name: string
    address: string | null
    phone: string | null
    email: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: SuppliersCountAggregateOutputType | null
    _avg: SuppliersAvgAggregateOutputType | null
    _sum: SuppliersSumAggregateOutputType | null
    _min: SuppliersMinAggregateOutputType | null
    _max: SuppliersMaxAggregateOutputType | null
  }

  type GetSuppliersGroupByPayload<T extends SuppliersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuppliersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuppliersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuppliersGroupByOutputType[P]>
            : GetScalarType<T[P], SuppliersGroupByOutputType[P]>
        }
      >
    >


  export type SuppliersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    Arrivals?: boolean | Suppliers$ArrivalsArgs<ExtArgs>
    _count?: boolean | SuppliersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suppliers"]>



  export type SuppliersSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type SuppliersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "email" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["suppliers"]>
  export type SuppliersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Arrivals?: boolean | Suppliers$ArrivalsArgs<ExtArgs>
    _count?: boolean | SuppliersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SuppliersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Suppliers"
    objects: {
      Arrivals: Prisma.$ArrivalsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      phone: string | null
      email: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["suppliers"]>
    composites: {}
  }

  type SuppliersGetPayload<S extends boolean | null | undefined | SuppliersDefaultArgs> = $Result.GetResult<Prisma.$SuppliersPayload, S>

  type SuppliersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuppliersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuppliersCountAggregateInputType | true
    }

  export interface SuppliersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Suppliers'], meta: { name: 'Suppliers' } }
    /**
     * Find zero or one Suppliers that matches the filter.
     * @param {SuppliersFindUniqueArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuppliersFindUniqueArgs>(args: SelectSubset<T, SuppliersFindUniqueArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Suppliers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuppliersFindUniqueOrThrowArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuppliersFindUniqueOrThrowArgs>(args: SelectSubset<T, SuppliersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersFindFirstArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuppliersFindFirstArgs>(args?: SelectSubset<T, SuppliersFindFirstArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suppliers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersFindFirstOrThrowArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuppliersFindFirstOrThrowArgs>(args?: SelectSubset<T, SuppliersFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.suppliers.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.suppliers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suppliersWithIdOnly = await prisma.suppliers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuppliersFindManyArgs>(args?: SelectSubset<T, SuppliersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Suppliers.
     * @param {SuppliersCreateArgs} args - Arguments to create a Suppliers.
     * @example
     * // Create one Suppliers
     * const Suppliers = await prisma.suppliers.create({
     *   data: {
     *     // ... data to create a Suppliers
     *   }
     * })
     * 
     */
    create<T extends SuppliersCreateArgs>(args: SelectSubset<T, SuppliersCreateArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SuppliersCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const suppliers = await prisma.suppliers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuppliersCreateManyArgs>(args?: SelectSubset<T, SuppliersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Suppliers.
     * @param {SuppliersDeleteArgs} args - Arguments to delete one Suppliers.
     * @example
     * // Delete one Suppliers
     * const Suppliers = await prisma.suppliers.delete({
     *   where: {
     *     // ... filter to delete one Suppliers
     *   }
     * })
     * 
     */
    delete<T extends SuppliersDeleteArgs>(args: SelectSubset<T, SuppliersDeleteArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Suppliers.
     * @param {SuppliersUpdateArgs} args - Arguments to update one Suppliers.
     * @example
     * // Update one Suppliers
     * const suppliers = await prisma.suppliers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuppliersUpdateArgs>(args: SelectSubset<T, SuppliersUpdateArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SuppliersDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.suppliers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuppliersDeleteManyArgs>(args?: SelectSubset<T, SuppliersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const suppliers = await prisma.suppliers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuppliersUpdateManyArgs>(args: SelectSubset<T, SuppliersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Suppliers.
     * @param {SuppliersUpsertArgs} args - Arguments to update or create a Suppliers.
     * @example
     * // Update or create a Suppliers
     * const suppliers = await prisma.suppliers.upsert({
     *   create: {
     *     // ... data to create a Suppliers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suppliers we want to update
     *   }
     * })
     */
    upsert<T extends SuppliersUpsertArgs>(args: SelectSubset<T, SuppliersUpsertArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.suppliers.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SuppliersCountArgs>(
      args?: Subset<T, SuppliersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuppliersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuppliersAggregateArgs>(args: Subset<T, SuppliersAggregateArgs>): Prisma.PrismaPromise<GetSuppliersAggregateType<T>>

    /**
     * Group by Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuppliersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuppliersGroupByArgs['orderBy'] }
        : { orderBy?: SuppliersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuppliersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuppliersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Suppliers model
   */
  readonly fields: SuppliersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Suppliers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuppliersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Arrivals<T extends Suppliers$ArrivalsArgs<ExtArgs> = {}>(args?: Subset<T, Suppliers$ArrivalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Suppliers model
   */
  interface SuppliersFieldRefs {
    readonly id: FieldRef<"Suppliers", 'Int'>
    readonly name: FieldRef<"Suppliers", 'String'>
    readonly address: FieldRef<"Suppliers", 'String'>
    readonly phone: FieldRef<"Suppliers", 'String'>
    readonly email: FieldRef<"Suppliers", 'String'>
    readonly createdAt: FieldRef<"Suppliers", 'DateTime'>
    readonly createdBy: FieldRef<"Suppliers", 'String'>
    readonly updatedAt: FieldRef<"Suppliers", 'DateTime'>
    readonly updatedBy: FieldRef<"Suppliers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Suppliers findUnique
   */
  export type SuppliersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where: SuppliersWhereUniqueInput
  }

  /**
   * Suppliers findUniqueOrThrow
   */
  export type SuppliersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where: SuppliersWhereUniqueInput
  }

  /**
   * Suppliers findFirst
   */
  export type SuppliersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SuppliersScalarFieldEnum | SuppliersScalarFieldEnum[]
  }

  /**
   * Suppliers findFirstOrThrow
   */
  export type SuppliersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SuppliersScalarFieldEnum | SuppliersScalarFieldEnum[]
  }

  /**
   * Suppliers findMany
   */
  export type SuppliersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SuppliersScalarFieldEnum | SuppliersScalarFieldEnum[]
  }

  /**
   * Suppliers create
   */
  export type SuppliersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * The data needed to create a Suppliers.
     */
    data: XOR<SuppliersCreateInput, SuppliersUncheckedCreateInput>
  }

  /**
   * Suppliers createMany
   */
  export type SuppliersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SuppliersCreateManyInput | SuppliersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Suppliers update
   */
  export type SuppliersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * The data needed to update a Suppliers.
     */
    data: XOR<SuppliersUpdateInput, SuppliersUncheckedUpdateInput>
    /**
     * Choose, which Suppliers to update.
     */
    where: SuppliersWhereUniqueInput
  }

  /**
   * Suppliers updateMany
   */
  export type SuppliersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SuppliersUpdateManyMutationInput, SuppliersUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SuppliersWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Suppliers upsert
   */
  export type SuppliersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * The filter to search for the Suppliers to update in case it exists.
     */
    where: SuppliersWhereUniqueInput
    /**
     * In case the Suppliers found by the `where` argument doesn't exist, create a new Suppliers with this data.
     */
    create: XOR<SuppliersCreateInput, SuppliersUncheckedCreateInput>
    /**
     * In case the Suppliers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuppliersUpdateInput, SuppliersUncheckedUpdateInput>
  }

  /**
   * Suppliers delete
   */
  export type SuppliersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter which Suppliers to delete.
     */
    where: SuppliersWhereUniqueInput
  }

  /**
   * Suppliers deleteMany
   */
  export type SuppliersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SuppliersWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Suppliers.Arrivals
   */
  export type Suppliers$ArrivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    where?: ArrivalsWhereInput
    orderBy?: ArrivalsOrderByWithRelationInput | ArrivalsOrderByWithRelationInput[]
    cursor?: ArrivalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArrivalsScalarFieldEnum | ArrivalsScalarFieldEnum[]
  }

  /**
   * Suppliers without action
   */
  export type SuppliersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
  }


  /**
   * Model Materials
   */

  export type AggregateMaterials = {
    _count: MaterialsCountAggregateOutputType | null
    _avg: MaterialsAvgAggregateOutputType | null
    _sum: MaterialsSumAggregateOutputType | null
    _min: MaterialsMinAggregateOutputType | null
    _max: MaterialsMaxAggregateOutputType | null
  }

  export type MaterialsAvgAggregateOutputType = {
    id: number | null
  }

  export type MaterialsSumAggregateOutputType = {
    id: number | null
  }

  export type MaterialsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type MaterialsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type MaterialsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type MaterialsAvgAggregateInputType = {
    id?: true
  }

  export type MaterialsSumAggregateInputType = {
    id?: true
  }

  export type MaterialsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type MaterialsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type MaterialsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type MaterialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to aggregate.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialsMaxAggregateInputType
  }

  export type GetMaterialsAggregateType<T extends MaterialsAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterials[P]>
      : GetScalarType<T[P], AggregateMaterials[P]>
  }




  export type MaterialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialsWhereInput
    orderBy?: MaterialsOrderByWithAggregationInput | MaterialsOrderByWithAggregationInput[]
    by: MaterialsScalarFieldEnum[] | MaterialsScalarFieldEnum
    having?: MaterialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialsCountAggregateInputType | true
    _avg?: MaterialsAvgAggregateInputType
    _sum?: MaterialsSumAggregateInputType
    _min?: MaterialsMinAggregateInputType
    _max?: MaterialsMaxAggregateInputType
  }

  export type MaterialsGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: MaterialsCountAggregateOutputType | null
    _avg: MaterialsAvgAggregateOutputType | null
    _sum: MaterialsSumAggregateOutputType | null
    _min: MaterialsMinAggregateOutputType | null
    _max: MaterialsMaxAggregateOutputType | null
  }

  type GetMaterialsGroupByPayload<T extends MaterialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialsGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialsGroupByOutputType[P]>
        }
      >
    >


  export type MaterialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    ArrivalItems?: boolean | Materials$ArrivalItemsArgs<ExtArgs>
    _count?: boolean | MaterialsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materials"]>



  export type MaterialsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type MaterialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["materials"]>
  export type MaterialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ArrivalItems?: boolean | Materials$ArrivalItemsArgs<ExtArgs>
    _count?: boolean | MaterialsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MaterialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Materials"
    objects: {
      ArrivalItems: Prisma.$ArrivalItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["materials"]>
    composites: {}
  }

  type MaterialsGetPayload<S extends boolean | null | undefined | MaterialsDefaultArgs> = $Result.GetResult<Prisma.$MaterialsPayload, S>

  type MaterialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialsCountAggregateInputType | true
    }

  export interface MaterialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Materials'], meta: { name: 'Materials' } }
    /**
     * Find zero or one Materials that matches the filter.
     * @param {MaterialsFindUniqueArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialsFindUniqueArgs>(args: SelectSubset<T, MaterialsFindUniqueArgs<ExtArgs>>): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Materials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialsFindUniqueOrThrowArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialsFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsFindFirstArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialsFindFirstArgs>(args?: SelectSubset<T, MaterialsFindFirstArgs<ExtArgs>>): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsFindFirstOrThrowArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialsFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.materials.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.materials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialsWithIdOnly = await prisma.materials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialsFindManyArgs>(args?: SelectSubset<T, MaterialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Materials.
     * @param {MaterialsCreateArgs} args - Arguments to create a Materials.
     * @example
     * // Create one Materials
     * const Materials = await prisma.materials.create({
     *   data: {
     *     // ... data to create a Materials
     *   }
     * })
     * 
     */
    create<T extends MaterialsCreateArgs>(args: SelectSubset<T, MaterialsCreateArgs<ExtArgs>>): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialsCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const materials = await prisma.materials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialsCreateManyArgs>(args?: SelectSubset<T, MaterialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Materials.
     * @param {MaterialsDeleteArgs} args - Arguments to delete one Materials.
     * @example
     * // Delete one Materials
     * const Materials = await prisma.materials.delete({
     *   where: {
     *     // ... filter to delete one Materials
     *   }
     * })
     * 
     */
    delete<T extends MaterialsDeleteArgs>(args: SelectSubset<T, MaterialsDeleteArgs<ExtArgs>>): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Materials.
     * @param {MaterialsUpdateArgs} args - Arguments to update one Materials.
     * @example
     * // Update one Materials
     * const materials = await prisma.materials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialsUpdateArgs>(args: SelectSubset<T, MaterialsUpdateArgs<ExtArgs>>): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialsDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.materials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialsDeleteManyArgs>(args?: SelectSubset<T, MaterialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const materials = await prisma.materials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialsUpdateManyArgs>(args: SelectSubset<T, MaterialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materials.
     * @param {MaterialsUpsertArgs} args - Arguments to update or create a Materials.
     * @example
     * // Update or create a Materials
     * const materials = await prisma.materials.upsert({
     *   create: {
     *     // ... data to create a Materials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materials we want to update
     *   }
     * })
     */
    upsert<T extends MaterialsUpsertArgs>(args: SelectSubset<T, MaterialsUpsertArgs<ExtArgs>>): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.materials.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialsCountArgs>(
      args?: Subset<T, MaterialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialsAggregateArgs>(args: Subset<T, MaterialsAggregateArgs>): Prisma.PrismaPromise<GetMaterialsAggregateType<T>>

    /**
     * Group by Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialsGroupByArgs['orderBy'] }
        : { orderBy?: MaterialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Materials model
   */
  readonly fields: MaterialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Materials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ArrivalItems<T extends Materials$ArrivalItemsArgs<ExtArgs> = {}>(args?: Subset<T, Materials$ArrivalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Materials model
   */
  interface MaterialsFieldRefs {
    readonly id: FieldRef<"Materials", 'Int'>
    readonly name: FieldRef<"Materials", 'String'>
    readonly description: FieldRef<"Materials", 'String'>
    readonly createdAt: FieldRef<"Materials", 'DateTime'>
    readonly createdBy: FieldRef<"Materials", 'String'>
    readonly updatedAt: FieldRef<"Materials", 'DateTime'>
    readonly updatedBy: FieldRef<"Materials", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Materials findUnique
   */
  export type MaterialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materials
     */
    omit?: MaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where: MaterialsWhereUniqueInput
  }

  /**
   * Materials findUniqueOrThrow
   */
  export type MaterialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materials
     */
    omit?: MaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where: MaterialsWhereUniqueInput
  }

  /**
   * Materials findFirst
   */
  export type MaterialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materials
     */
    omit?: MaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }

  /**
   * Materials findFirstOrThrow
   */
  export type MaterialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materials
     */
    omit?: MaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }

  /**
   * Materials findMany
   */
  export type MaterialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materials
     */
    omit?: MaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }

  /**
   * Materials create
   */
  export type MaterialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materials
     */
    omit?: MaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * The data needed to create a Materials.
     */
    data: XOR<MaterialsCreateInput, MaterialsUncheckedCreateInput>
  }

  /**
   * Materials createMany
   */
  export type MaterialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialsCreateManyInput | MaterialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Materials update
   */
  export type MaterialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materials
     */
    omit?: MaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * The data needed to update a Materials.
     */
    data: XOR<MaterialsUpdateInput, MaterialsUncheckedUpdateInput>
    /**
     * Choose, which Materials to update.
     */
    where: MaterialsWhereUniqueInput
  }

  /**
   * Materials updateMany
   */
  export type MaterialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialsUpdateManyMutationInput, MaterialsUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialsWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Materials upsert
   */
  export type MaterialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materials
     */
    omit?: MaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * The filter to search for the Materials to update in case it exists.
     */
    where: MaterialsWhereUniqueInput
    /**
     * In case the Materials found by the `where` argument doesn't exist, create a new Materials with this data.
     */
    create: XOR<MaterialsCreateInput, MaterialsUncheckedCreateInput>
    /**
     * In case the Materials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialsUpdateInput, MaterialsUncheckedUpdateInput>
  }

  /**
   * Materials delete
   */
  export type MaterialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materials
     */
    omit?: MaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter which Materials to delete.
     */
    where: MaterialsWhereUniqueInput
  }

  /**
   * Materials deleteMany
   */
  export type MaterialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialsWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Materials.ArrivalItems
   */
  export type Materials$ArrivalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    where?: ArrivalItemsWhereInput
    orderBy?: ArrivalItemsOrderByWithRelationInput | ArrivalItemsOrderByWithRelationInput[]
    cursor?: ArrivalItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArrivalItemsScalarFieldEnum | ArrivalItemsScalarFieldEnum[]
  }

  /**
   * Materials without action
   */
  export type MaterialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materials
     */
    omit?: MaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
  }


  /**
   * Model Conditions
   */

  export type AggregateConditions = {
    _count: ConditionsCountAggregateOutputType | null
    _avg: ConditionsAvgAggregateOutputType | null
    _sum: ConditionsSumAggregateOutputType | null
    _min: ConditionsMinAggregateOutputType | null
    _max: ConditionsMaxAggregateOutputType | null
  }

  export type ConditionsAvgAggregateOutputType = {
    id: number | null
  }

  export type ConditionsSumAggregateOutputType = {
    id: number | null
  }

  export type ConditionsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ConditionsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ConditionsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ConditionsAvgAggregateInputType = {
    id?: true
  }

  export type ConditionsSumAggregateInputType = {
    id?: true
  }

  export type ConditionsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ConditionsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ConditionsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ConditionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conditions to aggregate.
     */
    where?: ConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionsOrderByWithRelationInput | ConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conditions
    **/
    _count?: true | ConditionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConditionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConditionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConditionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConditionsMaxAggregateInputType
  }

  export type GetConditionsAggregateType<T extends ConditionsAggregateArgs> = {
        [P in keyof T & keyof AggregateConditions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConditions[P]>
      : GetScalarType<T[P], AggregateConditions[P]>
  }




  export type ConditionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConditionsWhereInput
    orderBy?: ConditionsOrderByWithAggregationInput | ConditionsOrderByWithAggregationInput[]
    by: ConditionsScalarFieldEnum[] | ConditionsScalarFieldEnum
    having?: ConditionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConditionsCountAggregateInputType | true
    _avg?: ConditionsAvgAggregateInputType
    _sum?: ConditionsSumAggregateInputType
    _min?: ConditionsMinAggregateInputType
    _max?: ConditionsMaxAggregateInputType
  }

  export type ConditionsGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: ConditionsCountAggregateOutputType | null
    _avg: ConditionsAvgAggregateOutputType | null
    _sum: ConditionsSumAggregateOutputType | null
    _min: ConditionsMinAggregateOutputType | null
    _max: ConditionsMaxAggregateOutputType | null
  }

  type GetConditionsGroupByPayload<T extends ConditionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConditionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConditionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConditionsGroupByOutputType[P]>
            : GetScalarType<T[P], ConditionsGroupByOutputType[P]>
        }
      >
    >


  export type ConditionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    ArrivalItems?: boolean | Conditions$ArrivalItemsArgs<ExtArgs>
    _count?: boolean | ConditionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conditions"]>



  export type ConditionsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ConditionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["conditions"]>
  export type ConditionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ArrivalItems?: boolean | Conditions$ArrivalItemsArgs<ExtArgs>
    _count?: boolean | ConditionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ConditionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conditions"
    objects: {
      ArrivalItems: Prisma.$ArrivalItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["conditions"]>
    composites: {}
  }

  type ConditionsGetPayload<S extends boolean | null | undefined | ConditionsDefaultArgs> = $Result.GetResult<Prisma.$ConditionsPayload, S>

  type ConditionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConditionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConditionsCountAggregateInputType | true
    }

  export interface ConditionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conditions'], meta: { name: 'Conditions' } }
    /**
     * Find zero or one Conditions that matches the filter.
     * @param {ConditionsFindUniqueArgs} args - Arguments to find a Conditions
     * @example
     * // Get one Conditions
     * const conditions = await prisma.conditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConditionsFindUniqueArgs>(args: SelectSubset<T, ConditionsFindUniqueArgs<ExtArgs>>): Prisma__ConditionsClient<$Result.GetResult<Prisma.$ConditionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conditions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConditionsFindUniqueOrThrowArgs} args - Arguments to find a Conditions
     * @example
     * // Get one Conditions
     * const conditions = await prisma.conditions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConditionsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConditionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConditionsClient<$Result.GetResult<Prisma.$ConditionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsFindFirstArgs} args - Arguments to find a Conditions
     * @example
     * // Get one Conditions
     * const conditions = await prisma.conditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConditionsFindFirstArgs>(args?: SelectSubset<T, ConditionsFindFirstArgs<ExtArgs>>): Prisma__ConditionsClient<$Result.GetResult<Prisma.$ConditionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conditions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsFindFirstOrThrowArgs} args - Arguments to find a Conditions
     * @example
     * // Get one Conditions
     * const conditions = await prisma.conditions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConditionsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConditionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConditionsClient<$Result.GetResult<Prisma.$ConditionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conditions
     * const conditions = await prisma.conditions.findMany()
     * 
     * // Get first 10 Conditions
     * const conditions = await prisma.conditions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conditionsWithIdOnly = await prisma.conditions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConditionsFindManyArgs>(args?: SelectSubset<T, ConditionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conditions.
     * @param {ConditionsCreateArgs} args - Arguments to create a Conditions.
     * @example
     * // Create one Conditions
     * const Conditions = await prisma.conditions.create({
     *   data: {
     *     // ... data to create a Conditions
     *   }
     * })
     * 
     */
    create<T extends ConditionsCreateArgs>(args: SelectSubset<T, ConditionsCreateArgs<ExtArgs>>): Prisma__ConditionsClient<$Result.GetResult<Prisma.$ConditionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conditions.
     * @param {ConditionsCreateManyArgs} args - Arguments to create many Conditions.
     * @example
     * // Create many Conditions
     * const conditions = await prisma.conditions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConditionsCreateManyArgs>(args?: SelectSubset<T, ConditionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conditions.
     * @param {ConditionsDeleteArgs} args - Arguments to delete one Conditions.
     * @example
     * // Delete one Conditions
     * const Conditions = await prisma.conditions.delete({
     *   where: {
     *     // ... filter to delete one Conditions
     *   }
     * })
     * 
     */
    delete<T extends ConditionsDeleteArgs>(args: SelectSubset<T, ConditionsDeleteArgs<ExtArgs>>): Prisma__ConditionsClient<$Result.GetResult<Prisma.$ConditionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conditions.
     * @param {ConditionsUpdateArgs} args - Arguments to update one Conditions.
     * @example
     * // Update one Conditions
     * const conditions = await prisma.conditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConditionsUpdateArgs>(args: SelectSubset<T, ConditionsUpdateArgs<ExtArgs>>): Prisma__ConditionsClient<$Result.GetResult<Prisma.$ConditionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conditions.
     * @param {ConditionsDeleteManyArgs} args - Arguments to filter Conditions to delete.
     * @example
     * // Delete a few Conditions
     * const { count } = await prisma.conditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConditionsDeleteManyArgs>(args?: SelectSubset<T, ConditionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conditions
     * const conditions = await prisma.conditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConditionsUpdateManyArgs>(args: SelectSubset<T, ConditionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conditions.
     * @param {ConditionsUpsertArgs} args - Arguments to update or create a Conditions.
     * @example
     * // Update or create a Conditions
     * const conditions = await prisma.conditions.upsert({
     *   create: {
     *     // ... data to create a Conditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conditions we want to update
     *   }
     * })
     */
    upsert<T extends ConditionsUpsertArgs>(args: SelectSubset<T, ConditionsUpsertArgs<ExtArgs>>): Prisma__ConditionsClient<$Result.GetResult<Prisma.$ConditionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsCountArgs} args - Arguments to filter Conditions to count.
     * @example
     * // Count the number of Conditions
     * const count = await prisma.conditions.count({
     *   where: {
     *     // ... the filter for the Conditions we want to count
     *   }
     * })
    **/
    count<T extends ConditionsCountArgs>(
      args?: Subset<T, ConditionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConditionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConditionsAggregateArgs>(args: Subset<T, ConditionsAggregateArgs>): Prisma.PrismaPromise<GetConditionsAggregateType<T>>

    /**
     * Group by Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConditionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConditionsGroupByArgs['orderBy'] }
        : { orderBy?: ConditionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConditionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConditionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conditions model
   */
  readonly fields: ConditionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConditionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ArrivalItems<T extends Conditions$ArrivalItemsArgs<ExtArgs> = {}>(args?: Subset<T, Conditions$ArrivalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conditions model
   */
  interface ConditionsFieldRefs {
    readonly id: FieldRef<"Conditions", 'Int'>
    readonly name: FieldRef<"Conditions", 'String'>
    readonly description: FieldRef<"Conditions", 'String'>
    readonly createdAt: FieldRef<"Conditions", 'DateTime'>
    readonly createdBy: FieldRef<"Conditions", 'String'>
    readonly updatedAt: FieldRef<"Conditions", 'DateTime'>
    readonly updatedBy: FieldRef<"Conditions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conditions findUnique
   */
  export type ConditionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditions
     */
    select?: ConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditions
     */
    omit?: ConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionsInclude<ExtArgs> | null
    /**
     * Filter, which Conditions to fetch.
     */
    where: ConditionsWhereUniqueInput
  }

  /**
   * Conditions findUniqueOrThrow
   */
  export type ConditionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditions
     */
    select?: ConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditions
     */
    omit?: ConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionsInclude<ExtArgs> | null
    /**
     * Filter, which Conditions to fetch.
     */
    where: ConditionsWhereUniqueInput
  }

  /**
   * Conditions findFirst
   */
  export type ConditionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditions
     */
    select?: ConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditions
     */
    omit?: ConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionsInclude<ExtArgs> | null
    /**
     * Filter, which Conditions to fetch.
     */
    where?: ConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionsOrderByWithRelationInput | ConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditions.
     */
    cursor?: ConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditions.
     */
    distinct?: ConditionsScalarFieldEnum | ConditionsScalarFieldEnum[]
  }

  /**
   * Conditions findFirstOrThrow
   */
  export type ConditionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditions
     */
    select?: ConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditions
     */
    omit?: ConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionsInclude<ExtArgs> | null
    /**
     * Filter, which Conditions to fetch.
     */
    where?: ConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionsOrderByWithRelationInput | ConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditions.
     */
    cursor?: ConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditions.
     */
    distinct?: ConditionsScalarFieldEnum | ConditionsScalarFieldEnum[]
  }

  /**
   * Conditions findMany
   */
  export type ConditionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditions
     */
    select?: ConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditions
     */
    omit?: ConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionsInclude<ExtArgs> | null
    /**
     * Filter, which Conditions to fetch.
     */
    where?: ConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionsOrderByWithRelationInput | ConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conditions.
     */
    cursor?: ConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    distinct?: ConditionsScalarFieldEnum | ConditionsScalarFieldEnum[]
  }

  /**
   * Conditions create
   */
  export type ConditionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditions
     */
    select?: ConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditions
     */
    omit?: ConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Conditions.
     */
    data: XOR<ConditionsCreateInput, ConditionsUncheckedCreateInput>
  }

  /**
   * Conditions createMany
   */
  export type ConditionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conditions.
     */
    data: ConditionsCreateManyInput | ConditionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conditions update
   */
  export type ConditionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditions
     */
    select?: ConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditions
     */
    omit?: ConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Conditions.
     */
    data: XOR<ConditionsUpdateInput, ConditionsUncheckedUpdateInput>
    /**
     * Choose, which Conditions to update.
     */
    where: ConditionsWhereUniqueInput
  }

  /**
   * Conditions updateMany
   */
  export type ConditionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conditions.
     */
    data: XOR<ConditionsUpdateManyMutationInput, ConditionsUncheckedUpdateManyInput>
    /**
     * Filter which Conditions to update
     */
    where?: ConditionsWhereInput
    /**
     * Limit how many Conditions to update.
     */
    limit?: number
  }

  /**
   * Conditions upsert
   */
  export type ConditionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditions
     */
    select?: ConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditions
     */
    omit?: ConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Conditions to update in case it exists.
     */
    where: ConditionsWhereUniqueInput
    /**
     * In case the Conditions found by the `where` argument doesn't exist, create a new Conditions with this data.
     */
    create: XOR<ConditionsCreateInput, ConditionsUncheckedCreateInput>
    /**
     * In case the Conditions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConditionsUpdateInput, ConditionsUncheckedUpdateInput>
  }

  /**
   * Conditions delete
   */
  export type ConditionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditions
     */
    select?: ConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditions
     */
    omit?: ConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionsInclude<ExtArgs> | null
    /**
     * Filter which Conditions to delete.
     */
    where: ConditionsWhereUniqueInput
  }

  /**
   * Conditions deleteMany
   */
  export type ConditionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conditions to delete
     */
    where?: ConditionsWhereInput
    /**
     * Limit how many Conditions to delete.
     */
    limit?: number
  }

  /**
   * Conditions.ArrivalItems
   */
  export type Conditions$ArrivalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    where?: ArrivalItemsWhereInput
    orderBy?: ArrivalItemsOrderByWithRelationInput | ArrivalItemsOrderByWithRelationInput[]
    cursor?: ArrivalItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArrivalItemsScalarFieldEnum | ArrivalItemsScalarFieldEnum[]
  }

  /**
   * Conditions without action
   */
  export type ConditionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditions
     */
    select?: ConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditions
     */
    omit?: ConditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionsInclude<ExtArgs> | null
  }


  /**
   * Model Parameters
   */

  export type AggregateParameters = {
    _count: ParametersCountAggregateOutputType | null
    _avg: ParametersAvgAggregateOutputType | null
    _sum: ParametersSumAggregateOutputType | null
    _min: ParametersMinAggregateOutputType | null
    _max: ParametersMaxAggregateOutputType | null
  }

  export type ParametersAvgAggregateOutputType = {
    id: number | null
  }

  export type ParametersSumAggregateOutputType = {
    id: number | null
  }

  export type ParametersMinAggregateOutputType = {
    id: number | null
    name: string | null
    unit: string | null
    type: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ParametersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    unit: string | null
    type: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ParametersCountAggregateOutputType = {
    id: number
    name: number
    unit: number
    type: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ParametersAvgAggregateInputType = {
    id?: true
  }

  export type ParametersSumAggregateInputType = {
    id?: true
  }

  export type ParametersMinAggregateInputType = {
    id?: true
    name?: true
    unit?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ParametersMaxAggregateInputType = {
    id?: true
    name?: true
    unit?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ParametersCountAggregateInputType = {
    id?: true
    name?: true
    unit?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ParametersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parameters to aggregate.
     */
    where?: ParametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParametersOrderByWithRelationInput | ParametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parameters
    **/
    _count?: true | ParametersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParametersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParametersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParametersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParametersMaxAggregateInputType
  }

  export type GetParametersAggregateType<T extends ParametersAggregateArgs> = {
        [P in keyof T & keyof AggregateParameters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParameters[P]>
      : GetScalarType<T[P], AggregateParameters[P]>
  }




  export type ParametersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParametersWhereInput
    orderBy?: ParametersOrderByWithAggregationInput | ParametersOrderByWithAggregationInput[]
    by: ParametersScalarFieldEnum[] | ParametersScalarFieldEnum
    having?: ParametersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParametersCountAggregateInputType | true
    _avg?: ParametersAvgAggregateInputType
    _sum?: ParametersSumAggregateInputType
    _min?: ParametersMinAggregateInputType
    _max?: ParametersMaxAggregateInputType
  }

  export type ParametersGroupByOutputType = {
    id: number
    name: string
    unit: string | null
    type: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: ParametersCountAggregateOutputType | null
    _avg: ParametersAvgAggregateOutputType | null
    _sum: ParametersSumAggregateOutputType | null
    _min: ParametersMinAggregateOutputType | null
    _max: ParametersMaxAggregateOutputType | null
  }

  type GetParametersGroupByPayload<T extends ParametersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParametersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParametersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParametersGroupByOutputType[P]>
            : GetScalarType<T[P], ParametersGroupByOutputType[P]>
        }
      >
    >


  export type ParametersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    unit?: boolean
    type?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    ArrivalItems?: boolean | Parameters$ArrivalItemsArgs<ExtArgs>
    QcResults?: boolean | Parameters$QcResultsArgs<ExtArgs>
    settings?: boolean | Parameters$settingsArgs<ExtArgs>
    _count?: boolean | ParametersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parameters"]>



  export type ParametersSelectScalar = {
    id?: boolean
    name?: boolean
    unit?: boolean
    type?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ParametersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "unit" | "type" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["parameters"]>
  export type ParametersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ArrivalItems?: boolean | Parameters$ArrivalItemsArgs<ExtArgs>
    QcResults?: boolean | Parameters$QcResultsArgs<ExtArgs>
    settings?: boolean | Parameters$settingsArgs<ExtArgs>
    _count?: boolean | ParametersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ParametersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parameters"
    objects: {
      ArrivalItems: Prisma.$ArrivalItemsPayload<ExtArgs>[]
      QcResults: Prisma.$QcResultsPayload<ExtArgs>[]
      settings: Prisma.$ParameterSettingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      unit: string | null
      type: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["parameters"]>
    composites: {}
  }

  type ParametersGetPayload<S extends boolean | null | undefined | ParametersDefaultArgs> = $Result.GetResult<Prisma.$ParametersPayload, S>

  type ParametersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParametersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParametersCountAggregateInputType | true
    }

  export interface ParametersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parameters'], meta: { name: 'Parameters' } }
    /**
     * Find zero or one Parameters that matches the filter.
     * @param {ParametersFindUniqueArgs} args - Arguments to find a Parameters
     * @example
     * // Get one Parameters
     * const parameters = await prisma.parameters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParametersFindUniqueArgs>(args: SelectSubset<T, ParametersFindUniqueArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parameters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParametersFindUniqueOrThrowArgs} args - Arguments to find a Parameters
     * @example
     * // Get one Parameters
     * const parameters = await prisma.parameters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParametersFindUniqueOrThrowArgs>(args: SelectSubset<T, ParametersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametersFindFirstArgs} args - Arguments to find a Parameters
     * @example
     * // Get one Parameters
     * const parameters = await prisma.parameters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParametersFindFirstArgs>(args?: SelectSubset<T, ParametersFindFirstArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parameters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametersFindFirstOrThrowArgs} args - Arguments to find a Parameters
     * @example
     * // Get one Parameters
     * const parameters = await prisma.parameters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParametersFindFirstOrThrowArgs>(args?: SelectSubset<T, ParametersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parameters
     * const parameters = await prisma.parameters.findMany()
     * 
     * // Get first 10 Parameters
     * const parameters = await prisma.parameters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parametersWithIdOnly = await prisma.parameters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParametersFindManyArgs>(args?: SelectSubset<T, ParametersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parameters.
     * @param {ParametersCreateArgs} args - Arguments to create a Parameters.
     * @example
     * // Create one Parameters
     * const Parameters = await prisma.parameters.create({
     *   data: {
     *     // ... data to create a Parameters
     *   }
     * })
     * 
     */
    create<T extends ParametersCreateArgs>(args: SelectSubset<T, ParametersCreateArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parameters.
     * @param {ParametersCreateManyArgs} args - Arguments to create many Parameters.
     * @example
     * // Create many Parameters
     * const parameters = await prisma.parameters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParametersCreateManyArgs>(args?: SelectSubset<T, ParametersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parameters.
     * @param {ParametersDeleteArgs} args - Arguments to delete one Parameters.
     * @example
     * // Delete one Parameters
     * const Parameters = await prisma.parameters.delete({
     *   where: {
     *     // ... filter to delete one Parameters
     *   }
     * })
     * 
     */
    delete<T extends ParametersDeleteArgs>(args: SelectSubset<T, ParametersDeleteArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parameters.
     * @param {ParametersUpdateArgs} args - Arguments to update one Parameters.
     * @example
     * // Update one Parameters
     * const parameters = await prisma.parameters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParametersUpdateArgs>(args: SelectSubset<T, ParametersUpdateArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parameters.
     * @param {ParametersDeleteManyArgs} args - Arguments to filter Parameters to delete.
     * @example
     * // Delete a few Parameters
     * const { count } = await prisma.parameters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParametersDeleteManyArgs>(args?: SelectSubset<T, ParametersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parameters
     * const parameters = await prisma.parameters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParametersUpdateManyArgs>(args: SelectSubset<T, ParametersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parameters.
     * @param {ParametersUpsertArgs} args - Arguments to update or create a Parameters.
     * @example
     * // Update or create a Parameters
     * const parameters = await prisma.parameters.upsert({
     *   create: {
     *     // ... data to create a Parameters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parameters we want to update
     *   }
     * })
     */
    upsert<T extends ParametersUpsertArgs>(args: SelectSubset<T, ParametersUpsertArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametersCountArgs} args - Arguments to filter Parameters to count.
     * @example
     * // Count the number of Parameters
     * const count = await prisma.parameters.count({
     *   where: {
     *     // ... the filter for the Parameters we want to count
     *   }
     * })
    **/
    count<T extends ParametersCountArgs>(
      args?: Subset<T, ParametersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParametersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParametersAggregateArgs>(args: Subset<T, ParametersAggregateArgs>): Prisma.PrismaPromise<GetParametersAggregateType<T>>

    /**
     * Group by Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParametersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParametersGroupByArgs['orderBy'] }
        : { orderBy?: ParametersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParametersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParametersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parameters model
   */
  readonly fields: ParametersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parameters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParametersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ArrivalItems<T extends Parameters$ArrivalItemsArgs<ExtArgs> = {}>(args?: Subset<T, Parameters$ArrivalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    QcResults<T extends Parameters$QcResultsArgs<ExtArgs> = {}>(args?: Subset<T, Parameters$QcResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends Parameters$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Parameters$settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParameterSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parameters model
   */
  interface ParametersFieldRefs {
    readonly id: FieldRef<"Parameters", 'Int'>
    readonly name: FieldRef<"Parameters", 'String'>
    readonly unit: FieldRef<"Parameters", 'String'>
    readonly type: FieldRef<"Parameters", 'String'>
    readonly createdAt: FieldRef<"Parameters", 'DateTime'>
    readonly createdBy: FieldRef<"Parameters", 'String'>
    readonly updatedAt: FieldRef<"Parameters", 'DateTime'>
    readonly updatedBy: FieldRef<"Parameters", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Parameters findUnique
   */
  export type ParametersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    /**
     * Filter, which Parameters to fetch.
     */
    where: ParametersWhereUniqueInput
  }

  /**
   * Parameters findUniqueOrThrow
   */
  export type ParametersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    /**
     * Filter, which Parameters to fetch.
     */
    where: ParametersWhereUniqueInput
  }

  /**
   * Parameters findFirst
   */
  export type ParametersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    /**
     * Filter, which Parameters to fetch.
     */
    where?: ParametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParametersOrderByWithRelationInput | ParametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parameters.
     */
    cursor?: ParametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parameters.
     */
    distinct?: ParametersScalarFieldEnum | ParametersScalarFieldEnum[]
  }

  /**
   * Parameters findFirstOrThrow
   */
  export type ParametersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    /**
     * Filter, which Parameters to fetch.
     */
    where?: ParametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParametersOrderByWithRelationInput | ParametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parameters.
     */
    cursor?: ParametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parameters.
     */
    distinct?: ParametersScalarFieldEnum | ParametersScalarFieldEnum[]
  }

  /**
   * Parameters findMany
   */
  export type ParametersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    /**
     * Filter, which Parameters to fetch.
     */
    where?: ParametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParametersOrderByWithRelationInput | ParametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parameters.
     */
    cursor?: ParametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    distinct?: ParametersScalarFieldEnum | ParametersScalarFieldEnum[]
  }

  /**
   * Parameters create
   */
  export type ParametersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    /**
     * The data needed to create a Parameters.
     */
    data: XOR<ParametersCreateInput, ParametersUncheckedCreateInput>
  }

  /**
   * Parameters createMany
   */
  export type ParametersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parameters.
     */
    data: ParametersCreateManyInput | ParametersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parameters update
   */
  export type ParametersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    /**
     * The data needed to update a Parameters.
     */
    data: XOR<ParametersUpdateInput, ParametersUncheckedUpdateInput>
    /**
     * Choose, which Parameters to update.
     */
    where: ParametersWhereUniqueInput
  }

  /**
   * Parameters updateMany
   */
  export type ParametersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parameters.
     */
    data: XOR<ParametersUpdateManyMutationInput, ParametersUncheckedUpdateManyInput>
    /**
     * Filter which Parameters to update
     */
    where?: ParametersWhereInput
    /**
     * Limit how many Parameters to update.
     */
    limit?: number
  }

  /**
   * Parameters upsert
   */
  export type ParametersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    /**
     * The filter to search for the Parameters to update in case it exists.
     */
    where: ParametersWhereUniqueInput
    /**
     * In case the Parameters found by the `where` argument doesn't exist, create a new Parameters with this data.
     */
    create: XOR<ParametersCreateInput, ParametersUncheckedCreateInput>
    /**
     * In case the Parameters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParametersUpdateInput, ParametersUncheckedUpdateInput>
  }

  /**
   * Parameters delete
   */
  export type ParametersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    /**
     * Filter which Parameters to delete.
     */
    where: ParametersWhereUniqueInput
  }

  /**
   * Parameters deleteMany
   */
  export type ParametersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parameters to delete
     */
    where?: ParametersWhereInput
    /**
     * Limit how many Parameters to delete.
     */
    limit?: number
  }

  /**
   * Parameters.ArrivalItems
   */
  export type Parameters$ArrivalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    where?: ArrivalItemsWhereInput
    orderBy?: ArrivalItemsOrderByWithRelationInput | ArrivalItemsOrderByWithRelationInput[]
    cursor?: ArrivalItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArrivalItemsScalarFieldEnum | ArrivalItemsScalarFieldEnum[]
  }

  /**
   * Parameters.QcResults
   */
  export type Parameters$QcResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    where?: QcResultsWhereInput
    orderBy?: QcResultsOrderByWithRelationInput | QcResultsOrderByWithRelationInput[]
    cursor?: QcResultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcResultsScalarFieldEnum | QcResultsScalarFieldEnum[]
  }

  /**
   * Parameters.settings
   */
  export type Parameters$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
    where?: ParameterSettingsWhereInput
    orderBy?: ParameterSettingsOrderByWithRelationInput | ParameterSettingsOrderByWithRelationInput[]
    cursor?: ParameterSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParameterSettingsScalarFieldEnum | ParameterSettingsScalarFieldEnum[]
  }

  /**
   * Parameters without action
   */
  export type ParametersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
  }


  /**
   * Model Arrivals
   */

  export type AggregateArrivals = {
    _count: ArrivalsCountAggregateOutputType | null
    _avg: ArrivalsAvgAggregateOutputType | null
    _sum: ArrivalsSumAggregateOutputType | null
    _min: ArrivalsMinAggregateOutputType | null
    _max: ArrivalsMaxAggregateOutputType | null
  }

  export type ArrivalsAvgAggregateOutputType = {
    id: number | null
    supplierId: number | null
  }

  export type ArrivalsSumAggregateOutputType = {
    id: number | null
    supplierId: number | null
  }

  export type ArrivalsMinAggregateOutputType = {
    id: number | null
    idKedatangan: string | null
    supplierId: number | null
    arrivalDate: Date | null
    arrivalTime: string | null
    nopol: string | null
    suratJalan: string | null
    city: string | null
    note: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ArrivalsMaxAggregateOutputType = {
    id: number | null
    idKedatangan: string | null
    supplierId: number | null
    arrivalDate: Date | null
    arrivalTime: string | null
    nopol: string | null
    suratJalan: string | null
    city: string | null
    note: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ArrivalsCountAggregateOutputType = {
    id: number
    idKedatangan: number
    supplierId: number
    arrivalDate: number
    arrivalTime: number
    nopol: number
    suratJalan: number
    city: number
    note: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ArrivalsAvgAggregateInputType = {
    id?: true
    supplierId?: true
  }

  export type ArrivalsSumAggregateInputType = {
    id?: true
    supplierId?: true
  }

  export type ArrivalsMinAggregateInputType = {
    id?: true
    idKedatangan?: true
    supplierId?: true
    arrivalDate?: true
    arrivalTime?: true
    nopol?: true
    suratJalan?: true
    city?: true
    note?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ArrivalsMaxAggregateInputType = {
    id?: true
    idKedatangan?: true
    supplierId?: true
    arrivalDate?: true
    arrivalTime?: true
    nopol?: true
    suratJalan?: true
    city?: true
    note?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ArrivalsCountAggregateInputType = {
    id?: true
    idKedatangan?: true
    supplierId?: true
    arrivalDate?: true
    arrivalTime?: true
    nopol?: true
    suratJalan?: true
    city?: true
    note?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ArrivalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Arrivals to aggregate.
     */
    where?: ArrivalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arrivals to fetch.
     */
    orderBy?: ArrivalsOrderByWithRelationInput | ArrivalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArrivalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Arrivals
    **/
    _count?: true | ArrivalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArrivalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArrivalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArrivalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArrivalsMaxAggregateInputType
  }

  export type GetArrivalsAggregateType<T extends ArrivalsAggregateArgs> = {
        [P in keyof T & keyof AggregateArrivals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArrivals[P]>
      : GetScalarType<T[P], AggregateArrivals[P]>
  }




  export type ArrivalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalsWhereInput
    orderBy?: ArrivalsOrderByWithAggregationInput | ArrivalsOrderByWithAggregationInput[]
    by: ArrivalsScalarFieldEnum[] | ArrivalsScalarFieldEnum
    having?: ArrivalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArrivalsCountAggregateInputType | true
    _avg?: ArrivalsAvgAggregateInputType
    _sum?: ArrivalsSumAggregateInputType
    _min?: ArrivalsMinAggregateInputType
    _max?: ArrivalsMaxAggregateInputType
  }

  export type ArrivalsGroupByOutputType = {
    id: number
    idKedatangan: string
    supplierId: number
    arrivalDate: Date
    arrivalTime: string | null
    nopol: string | null
    suratJalan: string | null
    city: string | null
    note: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: ArrivalsCountAggregateOutputType | null
    _avg: ArrivalsAvgAggregateOutputType | null
    _sum: ArrivalsSumAggregateOutputType | null
    _min: ArrivalsMinAggregateOutputType | null
    _max: ArrivalsMaxAggregateOutputType | null
  }

  type GetArrivalsGroupByPayload<T extends ArrivalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArrivalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArrivalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArrivalsGroupByOutputType[P]>
            : GetScalarType<T[P], ArrivalsGroupByOutputType[P]>
        }
      >
    >


  export type ArrivalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idKedatangan?: boolean
    supplierId?: boolean
    arrivalDate?: boolean
    arrivalTime?: boolean
    nopol?: boolean
    suratJalan?: boolean
    city?: boolean
    note?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    supplier?: boolean | SuppliersDefaultArgs<ExtArgs>
    ArrivalItems?: boolean | Arrivals$ArrivalItemsArgs<ExtArgs>
    QcHistories?: boolean | Arrivals$QcHistoriesArgs<ExtArgs>
    SecurityPhotos?: boolean | Arrivals$SecurityPhotosArgs<ExtArgs>
    ArrivalStatuses?: boolean | Arrivals$ArrivalStatusesArgs<ExtArgs>
    _count?: boolean | ArrivalsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["arrivals"]>



  export type ArrivalsSelectScalar = {
    id?: boolean
    idKedatangan?: boolean
    supplierId?: boolean
    arrivalDate?: boolean
    arrivalTime?: boolean
    nopol?: boolean
    suratJalan?: boolean
    city?: boolean
    note?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ArrivalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idKedatangan" | "supplierId" | "arrivalDate" | "arrivalTime" | "nopol" | "suratJalan" | "city" | "note" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["arrivals"]>
  export type ArrivalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SuppliersDefaultArgs<ExtArgs>
    ArrivalItems?: boolean | Arrivals$ArrivalItemsArgs<ExtArgs>
    QcHistories?: boolean | Arrivals$QcHistoriesArgs<ExtArgs>
    SecurityPhotos?: boolean | Arrivals$SecurityPhotosArgs<ExtArgs>
    ArrivalStatuses?: boolean | Arrivals$ArrivalStatusesArgs<ExtArgs>
    _count?: boolean | ArrivalsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ArrivalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Arrivals"
    objects: {
      supplier: Prisma.$SuppliersPayload<ExtArgs>
      ArrivalItems: Prisma.$ArrivalItemsPayload<ExtArgs>[]
      QcHistories: Prisma.$QcHistoriesPayload<ExtArgs>[]
      SecurityPhotos: Prisma.$SecurityPhotosPayload<ExtArgs>[]
      ArrivalStatuses: Prisma.$ArrivalStatusesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idKedatangan: string
      supplierId: number
      arrivalDate: Date
      arrivalTime: string | null
      nopol: string | null
      suratJalan: string | null
      city: string | null
      note: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["arrivals"]>
    composites: {}
  }

  type ArrivalsGetPayload<S extends boolean | null | undefined | ArrivalsDefaultArgs> = $Result.GetResult<Prisma.$ArrivalsPayload, S>

  type ArrivalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArrivalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArrivalsCountAggregateInputType | true
    }

  export interface ArrivalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Arrivals'], meta: { name: 'Arrivals' } }
    /**
     * Find zero or one Arrivals that matches the filter.
     * @param {ArrivalsFindUniqueArgs} args - Arguments to find a Arrivals
     * @example
     * // Get one Arrivals
     * const arrivals = await prisma.arrivals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArrivalsFindUniqueArgs>(args: SelectSubset<T, ArrivalsFindUniqueArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Arrivals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArrivalsFindUniqueOrThrowArgs} args - Arguments to find a Arrivals
     * @example
     * // Get one Arrivals
     * const arrivals = await prisma.arrivals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArrivalsFindUniqueOrThrowArgs>(args: SelectSubset<T, ArrivalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Arrivals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalsFindFirstArgs} args - Arguments to find a Arrivals
     * @example
     * // Get one Arrivals
     * const arrivals = await prisma.arrivals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArrivalsFindFirstArgs>(args?: SelectSubset<T, ArrivalsFindFirstArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Arrivals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalsFindFirstOrThrowArgs} args - Arguments to find a Arrivals
     * @example
     * // Get one Arrivals
     * const arrivals = await prisma.arrivals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArrivalsFindFirstOrThrowArgs>(args?: SelectSubset<T, ArrivalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Arrivals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Arrivals
     * const arrivals = await prisma.arrivals.findMany()
     * 
     * // Get first 10 Arrivals
     * const arrivals = await prisma.arrivals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const arrivalsWithIdOnly = await prisma.arrivals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArrivalsFindManyArgs>(args?: SelectSubset<T, ArrivalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Arrivals.
     * @param {ArrivalsCreateArgs} args - Arguments to create a Arrivals.
     * @example
     * // Create one Arrivals
     * const Arrivals = await prisma.arrivals.create({
     *   data: {
     *     // ... data to create a Arrivals
     *   }
     * })
     * 
     */
    create<T extends ArrivalsCreateArgs>(args: SelectSubset<T, ArrivalsCreateArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Arrivals.
     * @param {ArrivalsCreateManyArgs} args - Arguments to create many Arrivals.
     * @example
     * // Create many Arrivals
     * const arrivals = await prisma.arrivals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArrivalsCreateManyArgs>(args?: SelectSubset<T, ArrivalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Arrivals.
     * @param {ArrivalsDeleteArgs} args - Arguments to delete one Arrivals.
     * @example
     * // Delete one Arrivals
     * const Arrivals = await prisma.arrivals.delete({
     *   where: {
     *     // ... filter to delete one Arrivals
     *   }
     * })
     * 
     */
    delete<T extends ArrivalsDeleteArgs>(args: SelectSubset<T, ArrivalsDeleteArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Arrivals.
     * @param {ArrivalsUpdateArgs} args - Arguments to update one Arrivals.
     * @example
     * // Update one Arrivals
     * const arrivals = await prisma.arrivals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArrivalsUpdateArgs>(args: SelectSubset<T, ArrivalsUpdateArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Arrivals.
     * @param {ArrivalsDeleteManyArgs} args - Arguments to filter Arrivals to delete.
     * @example
     * // Delete a few Arrivals
     * const { count } = await prisma.arrivals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArrivalsDeleteManyArgs>(args?: SelectSubset<T, ArrivalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Arrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Arrivals
     * const arrivals = await prisma.arrivals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArrivalsUpdateManyArgs>(args: SelectSubset<T, ArrivalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Arrivals.
     * @param {ArrivalsUpsertArgs} args - Arguments to update or create a Arrivals.
     * @example
     * // Update or create a Arrivals
     * const arrivals = await prisma.arrivals.upsert({
     *   create: {
     *     // ... data to create a Arrivals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Arrivals we want to update
     *   }
     * })
     */
    upsert<T extends ArrivalsUpsertArgs>(args: SelectSubset<T, ArrivalsUpsertArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Arrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalsCountArgs} args - Arguments to filter Arrivals to count.
     * @example
     * // Count the number of Arrivals
     * const count = await prisma.arrivals.count({
     *   where: {
     *     // ... the filter for the Arrivals we want to count
     *   }
     * })
    **/
    count<T extends ArrivalsCountArgs>(
      args?: Subset<T, ArrivalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArrivalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Arrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArrivalsAggregateArgs>(args: Subset<T, ArrivalsAggregateArgs>): Prisma.PrismaPromise<GetArrivalsAggregateType<T>>

    /**
     * Group by Arrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArrivalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArrivalsGroupByArgs['orderBy'] }
        : { orderBy?: ArrivalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArrivalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArrivalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Arrivals model
   */
  readonly fields: ArrivalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Arrivals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArrivalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends SuppliersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuppliersDefaultArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ArrivalItems<T extends Arrivals$ArrivalItemsArgs<ExtArgs> = {}>(args?: Subset<T, Arrivals$ArrivalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    QcHistories<T extends Arrivals$QcHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Arrivals$QcHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SecurityPhotos<T extends Arrivals$SecurityPhotosArgs<ExtArgs> = {}>(args?: Subset<T, Arrivals$SecurityPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityPhotosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ArrivalStatuses<T extends Arrivals$ArrivalStatusesArgs<ExtArgs> = {}>(args?: Subset<T, Arrivals$ArrivalStatusesArgs<ExtArgs>>): Prisma__ArrivalStatusesClient<$Result.GetResult<Prisma.$ArrivalStatusesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Arrivals model
   */
  interface ArrivalsFieldRefs {
    readonly id: FieldRef<"Arrivals", 'Int'>
    readonly idKedatangan: FieldRef<"Arrivals", 'String'>
    readonly supplierId: FieldRef<"Arrivals", 'Int'>
    readonly arrivalDate: FieldRef<"Arrivals", 'DateTime'>
    readonly arrivalTime: FieldRef<"Arrivals", 'String'>
    readonly nopol: FieldRef<"Arrivals", 'String'>
    readonly suratJalan: FieldRef<"Arrivals", 'String'>
    readonly city: FieldRef<"Arrivals", 'String'>
    readonly note: FieldRef<"Arrivals", 'String'>
    readonly createdAt: FieldRef<"Arrivals", 'DateTime'>
    readonly createdBy: FieldRef<"Arrivals", 'String'>
    readonly updatedAt: FieldRef<"Arrivals", 'DateTime'>
    readonly updatedBy: FieldRef<"Arrivals", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Arrivals findUnique
   */
  export type ArrivalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    /**
     * Filter, which Arrivals to fetch.
     */
    where: ArrivalsWhereUniqueInput
  }

  /**
   * Arrivals findUniqueOrThrow
   */
  export type ArrivalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    /**
     * Filter, which Arrivals to fetch.
     */
    where: ArrivalsWhereUniqueInput
  }

  /**
   * Arrivals findFirst
   */
  export type ArrivalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    /**
     * Filter, which Arrivals to fetch.
     */
    where?: ArrivalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arrivals to fetch.
     */
    orderBy?: ArrivalsOrderByWithRelationInput | ArrivalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Arrivals.
     */
    cursor?: ArrivalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Arrivals.
     */
    distinct?: ArrivalsScalarFieldEnum | ArrivalsScalarFieldEnum[]
  }

  /**
   * Arrivals findFirstOrThrow
   */
  export type ArrivalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    /**
     * Filter, which Arrivals to fetch.
     */
    where?: ArrivalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arrivals to fetch.
     */
    orderBy?: ArrivalsOrderByWithRelationInput | ArrivalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Arrivals.
     */
    cursor?: ArrivalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Arrivals.
     */
    distinct?: ArrivalsScalarFieldEnum | ArrivalsScalarFieldEnum[]
  }

  /**
   * Arrivals findMany
   */
  export type ArrivalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    /**
     * Filter, which Arrivals to fetch.
     */
    where?: ArrivalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arrivals to fetch.
     */
    orderBy?: ArrivalsOrderByWithRelationInput | ArrivalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Arrivals.
     */
    cursor?: ArrivalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arrivals.
     */
    skip?: number
    distinct?: ArrivalsScalarFieldEnum | ArrivalsScalarFieldEnum[]
  }

  /**
   * Arrivals create
   */
  export type ArrivalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    /**
     * The data needed to create a Arrivals.
     */
    data: XOR<ArrivalsCreateInput, ArrivalsUncheckedCreateInput>
  }

  /**
   * Arrivals createMany
   */
  export type ArrivalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Arrivals.
     */
    data: ArrivalsCreateManyInput | ArrivalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Arrivals update
   */
  export type ArrivalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    /**
     * The data needed to update a Arrivals.
     */
    data: XOR<ArrivalsUpdateInput, ArrivalsUncheckedUpdateInput>
    /**
     * Choose, which Arrivals to update.
     */
    where: ArrivalsWhereUniqueInput
  }

  /**
   * Arrivals updateMany
   */
  export type ArrivalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Arrivals.
     */
    data: XOR<ArrivalsUpdateManyMutationInput, ArrivalsUncheckedUpdateManyInput>
    /**
     * Filter which Arrivals to update
     */
    where?: ArrivalsWhereInput
    /**
     * Limit how many Arrivals to update.
     */
    limit?: number
  }

  /**
   * Arrivals upsert
   */
  export type ArrivalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    /**
     * The filter to search for the Arrivals to update in case it exists.
     */
    where: ArrivalsWhereUniqueInput
    /**
     * In case the Arrivals found by the `where` argument doesn't exist, create a new Arrivals with this data.
     */
    create: XOR<ArrivalsCreateInput, ArrivalsUncheckedCreateInput>
    /**
     * In case the Arrivals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArrivalsUpdateInput, ArrivalsUncheckedUpdateInput>
  }

  /**
   * Arrivals delete
   */
  export type ArrivalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    /**
     * Filter which Arrivals to delete.
     */
    where: ArrivalsWhereUniqueInput
  }

  /**
   * Arrivals deleteMany
   */
  export type ArrivalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Arrivals to delete
     */
    where?: ArrivalsWhereInput
    /**
     * Limit how many Arrivals to delete.
     */
    limit?: number
  }

  /**
   * Arrivals.ArrivalItems
   */
  export type Arrivals$ArrivalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    where?: ArrivalItemsWhereInput
    orderBy?: ArrivalItemsOrderByWithRelationInput | ArrivalItemsOrderByWithRelationInput[]
    cursor?: ArrivalItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArrivalItemsScalarFieldEnum | ArrivalItemsScalarFieldEnum[]
  }

  /**
   * Arrivals.QcHistories
   */
  export type Arrivals$QcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    where?: QcHistoriesWhereInput
    orderBy?: QcHistoriesOrderByWithRelationInput | QcHistoriesOrderByWithRelationInput[]
    cursor?: QcHistoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcHistoriesScalarFieldEnum | QcHistoriesScalarFieldEnum[]
  }

  /**
   * Arrivals.SecurityPhotos
   */
  export type Arrivals$SecurityPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
    where?: SecurityPhotosWhereInput
    orderBy?: SecurityPhotosOrderByWithRelationInput | SecurityPhotosOrderByWithRelationInput[]
    cursor?: SecurityPhotosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityPhotosScalarFieldEnum | SecurityPhotosScalarFieldEnum[]
  }

  /**
   * Arrivals.ArrivalStatuses
   */
  export type Arrivals$ArrivalStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
    where?: ArrivalStatusesWhereInput
  }

  /**
   * Arrivals without action
   */
  export type ArrivalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
  }


  /**
   * Model ArrivalItems
   */

  export type AggregateArrivalItems = {
    _count: ArrivalItemsCountAggregateOutputType | null
    _avg: ArrivalItemsAvgAggregateOutputType | null
    _sum: ArrivalItemsSumAggregateOutputType | null
    _min: ArrivalItemsMinAggregateOutputType | null
    _max: ArrivalItemsMaxAggregateOutputType | null
  }

  export type ArrivalItemsAvgAggregateOutputType = {
    id: number | null
    arrivalId: number | null
    materialId: number | null
    conditionId: number | null
    parameterId: number | null
    quantity: number | null
    qcStatusId: number | null
    qcSample: number | null
    qcKotoran: number | null
    totalBerat: number | null
    pengeringan: number | null
  }

  export type ArrivalItemsSumAggregateOutputType = {
    id: number | null
    arrivalId: number | null
    materialId: number | null
    conditionId: number | null
    parameterId: number | null
    quantity: number | null
    qcStatusId: number | null
    qcSample: number | null
    qcKotoran: number | null
    totalBerat: number | null
    pengeringan: number | null
  }

  export type ArrivalItemsMinAggregateOutputType = {
    id: number | null
    arrivalId: number | null
    materialId: number | null
    conditionId: number | null
    parameterId: number | null
    conditionCategory: string | null
    quantity: number | null
    note: string | null
    itemName: string | null
    qcNote: string | null
    qcStatusId: number | null
    qcAnalysis: string | null
    qcSample: number | null
    qcKotoran: number | null
    totalBerat: number | null
    pengeringan: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    statusQc: boolean | null
  }

  export type ArrivalItemsMaxAggregateOutputType = {
    id: number | null
    arrivalId: number | null
    materialId: number | null
    conditionId: number | null
    parameterId: number | null
    conditionCategory: string | null
    quantity: number | null
    note: string | null
    itemName: string | null
    qcNote: string | null
    qcStatusId: number | null
    qcAnalysis: string | null
    qcSample: number | null
    qcKotoran: number | null
    totalBerat: number | null
    pengeringan: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    statusQc: boolean | null
  }

  export type ArrivalItemsCountAggregateOutputType = {
    id: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId: number
    conditionCategory: number
    quantity: number
    note: number
    itemName: number
    qcNote: number
    qcStatusId: number
    qcAnalysis: number
    qcSample: number
    qcKotoran: number
    totalBerat: number
    pengeringan: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    statusQc: number
    _all: number
  }


  export type ArrivalItemsAvgAggregateInputType = {
    id?: true
    arrivalId?: true
    materialId?: true
    conditionId?: true
    parameterId?: true
    quantity?: true
    qcStatusId?: true
    qcSample?: true
    qcKotoran?: true
    totalBerat?: true
    pengeringan?: true
  }

  export type ArrivalItemsSumAggregateInputType = {
    id?: true
    arrivalId?: true
    materialId?: true
    conditionId?: true
    parameterId?: true
    quantity?: true
    qcStatusId?: true
    qcSample?: true
    qcKotoran?: true
    totalBerat?: true
    pengeringan?: true
  }

  export type ArrivalItemsMinAggregateInputType = {
    id?: true
    arrivalId?: true
    materialId?: true
    conditionId?: true
    parameterId?: true
    conditionCategory?: true
    quantity?: true
    note?: true
    itemName?: true
    qcNote?: true
    qcStatusId?: true
    qcAnalysis?: true
    qcSample?: true
    qcKotoran?: true
    totalBerat?: true
    pengeringan?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    statusQc?: true
  }

  export type ArrivalItemsMaxAggregateInputType = {
    id?: true
    arrivalId?: true
    materialId?: true
    conditionId?: true
    parameterId?: true
    conditionCategory?: true
    quantity?: true
    note?: true
    itemName?: true
    qcNote?: true
    qcStatusId?: true
    qcAnalysis?: true
    qcSample?: true
    qcKotoran?: true
    totalBerat?: true
    pengeringan?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    statusQc?: true
  }

  export type ArrivalItemsCountAggregateInputType = {
    id?: true
    arrivalId?: true
    materialId?: true
    conditionId?: true
    parameterId?: true
    conditionCategory?: true
    quantity?: true
    note?: true
    itemName?: true
    qcNote?: true
    qcStatusId?: true
    qcAnalysis?: true
    qcSample?: true
    qcKotoran?: true
    totalBerat?: true
    pengeringan?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    statusQc?: true
    _all?: true
  }

  export type ArrivalItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArrivalItems to aggregate.
     */
    where?: ArrivalItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArrivalItems to fetch.
     */
    orderBy?: ArrivalItemsOrderByWithRelationInput | ArrivalItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArrivalItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArrivalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArrivalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArrivalItems
    **/
    _count?: true | ArrivalItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArrivalItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArrivalItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArrivalItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArrivalItemsMaxAggregateInputType
  }

  export type GetArrivalItemsAggregateType<T extends ArrivalItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateArrivalItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArrivalItems[P]>
      : GetScalarType<T[P], AggregateArrivalItems[P]>
  }




  export type ArrivalItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalItemsWhereInput
    orderBy?: ArrivalItemsOrderByWithAggregationInput | ArrivalItemsOrderByWithAggregationInput[]
    by: ArrivalItemsScalarFieldEnum[] | ArrivalItemsScalarFieldEnum
    having?: ArrivalItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArrivalItemsCountAggregateInputType | true
    _avg?: ArrivalItemsAvgAggregateInputType
    _sum?: ArrivalItemsSumAggregateInputType
    _min?: ArrivalItemsMinAggregateInputType
    _max?: ArrivalItemsMaxAggregateInputType
  }

  export type ArrivalItemsGroupByOutputType = {
    id: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId: number | null
    conditionCategory: string | null
    quantity: number
    note: string | null
    itemName: string | null
    qcNote: string | null
    qcStatusId: number | null
    qcAnalysis: string | null
    qcSample: number | null
    qcKotoran: number | null
    totalBerat: number | null
    pengeringan: number | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    statusQc: boolean
    _count: ArrivalItemsCountAggregateOutputType | null
    _avg: ArrivalItemsAvgAggregateOutputType | null
    _sum: ArrivalItemsSumAggregateOutputType | null
    _min: ArrivalItemsMinAggregateOutputType | null
    _max: ArrivalItemsMaxAggregateOutputType | null
  }

  type GetArrivalItemsGroupByPayload<T extends ArrivalItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArrivalItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArrivalItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArrivalItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ArrivalItemsGroupByOutputType[P]>
        }
      >
    >


  export type ArrivalItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arrivalId?: boolean
    materialId?: boolean
    conditionId?: boolean
    parameterId?: boolean
    conditionCategory?: boolean
    quantity?: boolean
    note?: boolean
    itemName?: boolean
    qcNote?: boolean
    qcStatusId?: boolean
    qcAnalysis?: boolean
    qcSample?: boolean
    qcKotoran?: boolean
    totalBerat?: boolean
    pengeringan?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    statusQc?: boolean
    arrival?: boolean | ArrivalsDefaultArgs<ExtArgs>
    material?: boolean | MaterialsDefaultArgs<ExtArgs>
    condition?: boolean | ConditionsDefaultArgs<ExtArgs>
    parameter?: boolean | ArrivalItems$parameterArgs<ExtArgs>
    qcStatus?: boolean | ArrivalItems$qcStatusArgs<ExtArgs>
    QcResults?: boolean | ArrivalItems$QcResultsArgs<ExtArgs>
    QcPhotos?: boolean | ArrivalItems$QcPhotosArgs<ExtArgs>
    Weighings?: boolean | ArrivalItems$WeighingsArgs<ExtArgs>
    WeighingsPhotos?: boolean | ArrivalItems$WeighingsPhotosArgs<ExtArgs>
    QcHistories?: boolean | ArrivalItems$QcHistoriesArgs<ExtArgs>
    _count?: boolean | ArrivalItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["arrivalItems"]>



  export type ArrivalItemsSelectScalar = {
    id?: boolean
    arrivalId?: boolean
    materialId?: boolean
    conditionId?: boolean
    parameterId?: boolean
    conditionCategory?: boolean
    quantity?: boolean
    note?: boolean
    itemName?: boolean
    qcNote?: boolean
    qcStatusId?: boolean
    qcAnalysis?: boolean
    qcSample?: boolean
    qcKotoran?: boolean
    totalBerat?: boolean
    pengeringan?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    statusQc?: boolean
  }

  export type ArrivalItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "arrivalId" | "materialId" | "conditionId" | "parameterId" | "conditionCategory" | "quantity" | "note" | "itemName" | "qcNote" | "qcStatusId" | "qcAnalysis" | "qcSample" | "qcKotoran" | "totalBerat" | "pengeringan" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "statusQc", ExtArgs["result"]["arrivalItems"]>
  export type ArrivalItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrival?: boolean | ArrivalsDefaultArgs<ExtArgs>
    material?: boolean | MaterialsDefaultArgs<ExtArgs>
    condition?: boolean | ConditionsDefaultArgs<ExtArgs>
    parameter?: boolean | ArrivalItems$parameterArgs<ExtArgs>
    qcStatus?: boolean | ArrivalItems$qcStatusArgs<ExtArgs>
    QcResults?: boolean | ArrivalItems$QcResultsArgs<ExtArgs>
    QcPhotos?: boolean | ArrivalItems$QcPhotosArgs<ExtArgs>
    Weighings?: boolean | ArrivalItems$WeighingsArgs<ExtArgs>
    WeighingsPhotos?: boolean | ArrivalItems$WeighingsPhotosArgs<ExtArgs>
    QcHistories?: boolean | ArrivalItems$QcHistoriesArgs<ExtArgs>
    _count?: boolean | ArrivalItemsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ArrivalItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArrivalItems"
    objects: {
      arrival: Prisma.$ArrivalsPayload<ExtArgs>
      material: Prisma.$MaterialsPayload<ExtArgs>
      condition: Prisma.$ConditionsPayload<ExtArgs>
      parameter: Prisma.$ParametersPayload<ExtArgs> | null
      qcStatus: Prisma.$QcStatusPayload<ExtArgs> | null
      QcResults: Prisma.$QcResultsPayload<ExtArgs>[]
      QcPhotos: Prisma.$QcPhotosPayload<ExtArgs>[]
      Weighings: Prisma.$WeighingsPayload<ExtArgs>[]
      WeighingsPhotos: Prisma.$WeighingsPhotosPayload<ExtArgs>[]
      QcHistories: Prisma.$QcHistoriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      arrivalId: number
      materialId: number
      conditionId: number
      parameterId: number | null
      conditionCategory: string | null
      quantity: number
      note: string | null
      itemName: string | null
      qcNote: string | null
      qcStatusId: number | null
      qcAnalysis: string | null
      qcSample: number | null
      qcKotoran: number | null
      totalBerat: number | null
      pengeringan: number | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
      statusQc: boolean
    }, ExtArgs["result"]["arrivalItems"]>
    composites: {}
  }

  type ArrivalItemsGetPayload<S extends boolean | null | undefined | ArrivalItemsDefaultArgs> = $Result.GetResult<Prisma.$ArrivalItemsPayload, S>

  type ArrivalItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArrivalItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArrivalItemsCountAggregateInputType | true
    }

  export interface ArrivalItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArrivalItems'], meta: { name: 'ArrivalItems' } }
    /**
     * Find zero or one ArrivalItems that matches the filter.
     * @param {ArrivalItemsFindUniqueArgs} args - Arguments to find a ArrivalItems
     * @example
     * // Get one ArrivalItems
     * const arrivalItems = await prisma.arrivalItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArrivalItemsFindUniqueArgs>(args: SelectSubset<T, ArrivalItemsFindUniqueArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArrivalItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArrivalItemsFindUniqueOrThrowArgs} args - Arguments to find a ArrivalItems
     * @example
     * // Get one ArrivalItems
     * const arrivalItems = await prisma.arrivalItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArrivalItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, ArrivalItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArrivalItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalItemsFindFirstArgs} args - Arguments to find a ArrivalItems
     * @example
     * // Get one ArrivalItems
     * const arrivalItems = await prisma.arrivalItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArrivalItemsFindFirstArgs>(args?: SelectSubset<T, ArrivalItemsFindFirstArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArrivalItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalItemsFindFirstOrThrowArgs} args - Arguments to find a ArrivalItems
     * @example
     * // Get one ArrivalItems
     * const arrivalItems = await prisma.arrivalItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArrivalItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, ArrivalItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArrivalItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArrivalItems
     * const arrivalItems = await prisma.arrivalItems.findMany()
     * 
     * // Get first 10 ArrivalItems
     * const arrivalItems = await prisma.arrivalItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const arrivalItemsWithIdOnly = await prisma.arrivalItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArrivalItemsFindManyArgs>(args?: SelectSubset<T, ArrivalItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArrivalItems.
     * @param {ArrivalItemsCreateArgs} args - Arguments to create a ArrivalItems.
     * @example
     * // Create one ArrivalItems
     * const ArrivalItems = await prisma.arrivalItems.create({
     *   data: {
     *     // ... data to create a ArrivalItems
     *   }
     * })
     * 
     */
    create<T extends ArrivalItemsCreateArgs>(args: SelectSubset<T, ArrivalItemsCreateArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArrivalItems.
     * @param {ArrivalItemsCreateManyArgs} args - Arguments to create many ArrivalItems.
     * @example
     * // Create many ArrivalItems
     * const arrivalItems = await prisma.arrivalItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArrivalItemsCreateManyArgs>(args?: SelectSubset<T, ArrivalItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArrivalItems.
     * @param {ArrivalItemsDeleteArgs} args - Arguments to delete one ArrivalItems.
     * @example
     * // Delete one ArrivalItems
     * const ArrivalItems = await prisma.arrivalItems.delete({
     *   where: {
     *     // ... filter to delete one ArrivalItems
     *   }
     * })
     * 
     */
    delete<T extends ArrivalItemsDeleteArgs>(args: SelectSubset<T, ArrivalItemsDeleteArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArrivalItems.
     * @param {ArrivalItemsUpdateArgs} args - Arguments to update one ArrivalItems.
     * @example
     * // Update one ArrivalItems
     * const arrivalItems = await prisma.arrivalItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArrivalItemsUpdateArgs>(args: SelectSubset<T, ArrivalItemsUpdateArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArrivalItems.
     * @param {ArrivalItemsDeleteManyArgs} args - Arguments to filter ArrivalItems to delete.
     * @example
     * // Delete a few ArrivalItems
     * const { count } = await prisma.arrivalItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArrivalItemsDeleteManyArgs>(args?: SelectSubset<T, ArrivalItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArrivalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArrivalItems
     * const arrivalItems = await prisma.arrivalItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArrivalItemsUpdateManyArgs>(args: SelectSubset<T, ArrivalItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArrivalItems.
     * @param {ArrivalItemsUpsertArgs} args - Arguments to update or create a ArrivalItems.
     * @example
     * // Update or create a ArrivalItems
     * const arrivalItems = await prisma.arrivalItems.upsert({
     *   create: {
     *     // ... data to create a ArrivalItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArrivalItems we want to update
     *   }
     * })
     */
    upsert<T extends ArrivalItemsUpsertArgs>(args: SelectSubset<T, ArrivalItemsUpsertArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArrivalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalItemsCountArgs} args - Arguments to filter ArrivalItems to count.
     * @example
     * // Count the number of ArrivalItems
     * const count = await prisma.arrivalItems.count({
     *   where: {
     *     // ... the filter for the ArrivalItems we want to count
     *   }
     * })
    **/
    count<T extends ArrivalItemsCountArgs>(
      args?: Subset<T, ArrivalItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArrivalItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArrivalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArrivalItemsAggregateArgs>(args: Subset<T, ArrivalItemsAggregateArgs>): Prisma.PrismaPromise<GetArrivalItemsAggregateType<T>>

    /**
     * Group by ArrivalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArrivalItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArrivalItemsGroupByArgs['orderBy'] }
        : { orderBy?: ArrivalItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArrivalItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArrivalItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArrivalItems model
   */
  readonly fields: ArrivalItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArrivalItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArrivalItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    arrival<T extends ArrivalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalsDefaultArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    material<T extends MaterialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialsDefaultArgs<ExtArgs>>): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    condition<T extends ConditionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConditionsDefaultArgs<ExtArgs>>): Prisma__ConditionsClient<$Result.GetResult<Prisma.$ConditionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parameter<T extends ArrivalItems$parameterArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItems$parameterArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    qcStatus<T extends ArrivalItems$qcStatusArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItems$qcStatusArgs<ExtArgs>>): Prisma__QcStatusClient<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    QcResults<T extends ArrivalItems$QcResultsArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItems$QcResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    QcPhotos<T extends ArrivalItems$QcPhotosArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItems$QcPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcPhotosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Weighings<T extends ArrivalItems$WeighingsArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItems$WeighingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeighingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WeighingsPhotos<T extends ArrivalItems$WeighingsPhotosArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItems$WeighingsPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeighingsPhotosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    QcHistories<T extends ArrivalItems$QcHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItems$QcHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArrivalItems model
   */
  interface ArrivalItemsFieldRefs {
    readonly id: FieldRef<"ArrivalItems", 'Int'>
    readonly arrivalId: FieldRef<"ArrivalItems", 'Int'>
    readonly materialId: FieldRef<"ArrivalItems", 'Int'>
    readonly conditionId: FieldRef<"ArrivalItems", 'Int'>
    readonly parameterId: FieldRef<"ArrivalItems", 'Int'>
    readonly conditionCategory: FieldRef<"ArrivalItems", 'String'>
    readonly quantity: FieldRef<"ArrivalItems", 'Float'>
    readonly note: FieldRef<"ArrivalItems", 'String'>
    readonly itemName: FieldRef<"ArrivalItems", 'String'>
    readonly qcNote: FieldRef<"ArrivalItems", 'String'>
    readonly qcStatusId: FieldRef<"ArrivalItems", 'Int'>
    readonly qcAnalysis: FieldRef<"ArrivalItems", 'String'>
    readonly qcSample: FieldRef<"ArrivalItems", 'Float'>
    readonly qcKotoran: FieldRef<"ArrivalItems", 'Float'>
    readonly totalBerat: FieldRef<"ArrivalItems", 'Float'>
    readonly pengeringan: FieldRef<"ArrivalItems", 'Float'>
    readonly createdAt: FieldRef<"ArrivalItems", 'DateTime'>
    readonly createdBy: FieldRef<"ArrivalItems", 'String'>
    readonly updatedAt: FieldRef<"ArrivalItems", 'DateTime'>
    readonly updatedBy: FieldRef<"ArrivalItems", 'String'>
    readonly statusQc: FieldRef<"ArrivalItems", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ArrivalItems findUnique
   */
  export type ArrivalItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    /**
     * Filter, which ArrivalItems to fetch.
     */
    where: ArrivalItemsWhereUniqueInput
  }

  /**
   * ArrivalItems findUniqueOrThrow
   */
  export type ArrivalItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    /**
     * Filter, which ArrivalItems to fetch.
     */
    where: ArrivalItemsWhereUniqueInput
  }

  /**
   * ArrivalItems findFirst
   */
  export type ArrivalItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    /**
     * Filter, which ArrivalItems to fetch.
     */
    where?: ArrivalItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArrivalItems to fetch.
     */
    orderBy?: ArrivalItemsOrderByWithRelationInput | ArrivalItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArrivalItems.
     */
    cursor?: ArrivalItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArrivalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArrivalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArrivalItems.
     */
    distinct?: ArrivalItemsScalarFieldEnum | ArrivalItemsScalarFieldEnum[]
  }

  /**
   * ArrivalItems findFirstOrThrow
   */
  export type ArrivalItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    /**
     * Filter, which ArrivalItems to fetch.
     */
    where?: ArrivalItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArrivalItems to fetch.
     */
    orderBy?: ArrivalItemsOrderByWithRelationInput | ArrivalItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArrivalItems.
     */
    cursor?: ArrivalItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArrivalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArrivalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArrivalItems.
     */
    distinct?: ArrivalItemsScalarFieldEnum | ArrivalItemsScalarFieldEnum[]
  }

  /**
   * ArrivalItems findMany
   */
  export type ArrivalItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    /**
     * Filter, which ArrivalItems to fetch.
     */
    where?: ArrivalItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArrivalItems to fetch.
     */
    orderBy?: ArrivalItemsOrderByWithRelationInput | ArrivalItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArrivalItems.
     */
    cursor?: ArrivalItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArrivalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArrivalItems.
     */
    skip?: number
    distinct?: ArrivalItemsScalarFieldEnum | ArrivalItemsScalarFieldEnum[]
  }

  /**
   * ArrivalItems create
   */
  export type ArrivalItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a ArrivalItems.
     */
    data: XOR<ArrivalItemsCreateInput, ArrivalItemsUncheckedCreateInput>
  }

  /**
   * ArrivalItems createMany
   */
  export type ArrivalItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArrivalItems.
     */
    data: ArrivalItemsCreateManyInput | ArrivalItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArrivalItems update
   */
  export type ArrivalItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a ArrivalItems.
     */
    data: XOR<ArrivalItemsUpdateInput, ArrivalItemsUncheckedUpdateInput>
    /**
     * Choose, which ArrivalItems to update.
     */
    where: ArrivalItemsWhereUniqueInput
  }

  /**
   * ArrivalItems updateMany
   */
  export type ArrivalItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArrivalItems.
     */
    data: XOR<ArrivalItemsUpdateManyMutationInput, ArrivalItemsUncheckedUpdateManyInput>
    /**
     * Filter which ArrivalItems to update
     */
    where?: ArrivalItemsWhereInput
    /**
     * Limit how many ArrivalItems to update.
     */
    limit?: number
  }

  /**
   * ArrivalItems upsert
   */
  export type ArrivalItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the ArrivalItems to update in case it exists.
     */
    where: ArrivalItemsWhereUniqueInput
    /**
     * In case the ArrivalItems found by the `where` argument doesn't exist, create a new ArrivalItems with this data.
     */
    create: XOR<ArrivalItemsCreateInput, ArrivalItemsUncheckedCreateInput>
    /**
     * In case the ArrivalItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArrivalItemsUpdateInput, ArrivalItemsUncheckedUpdateInput>
  }

  /**
   * ArrivalItems delete
   */
  export type ArrivalItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    /**
     * Filter which ArrivalItems to delete.
     */
    where: ArrivalItemsWhereUniqueInput
  }

  /**
   * ArrivalItems deleteMany
   */
  export type ArrivalItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArrivalItems to delete
     */
    where?: ArrivalItemsWhereInput
    /**
     * Limit how many ArrivalItems to delete.
     */
    limit?: number
  }

  /**
   * ArrivalItems.parameter
   */
  export type ArrivalItems$parameterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    where?: ParametersWhereInput
  }

  /**
   * ArrivalItems.qcStatus
   */
  export type ArrivalItems$qcStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
    where?: QcStatusWhereInput
  }

  /**
   * ArrivalItems.QcResults
   */
  export type ArrivalItems$QcResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    where?: QcResultsWhereInput
    orderBy?: QcResultsOrderByWithRelationInput | QcResultsOrderByWithRelationInput[]
    cursor?: QcResultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcResultsScalarFieldEnum | QcResultsScalarFieldEnum[]
  }

  /**
   * ArrivalItems.QcPhotos
   */
  export type ArrivalItems$QcPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
    where?: QcPhotosWhereInput
    orderBy?: QcPhotosOrderByWithRelationInput | QcPhotosOrderByWithRelationInput[]
    cursor?: QcPhotosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcPhotosScalarFieldEnum | QcPhotosScalarFieldEnum[]
  }

  /**
   * ArrivalItems.Weighings
   */
  export type ArrivalItems$WeighingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
    where?: WeighingsWhereInput
    orderBy?: WeighingsOrderByWithRelationInput | WeighingsOrderByWithRelationInput[]
    cursor?: WeighingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeighingsScalarFieldEnum | WeighingsScalarFieldEnum[]
  }

  /**
   * ArrivalItems.WeighingsPhotos
   */
  export type ArrivalItems$WeighingsPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
    where?: WeighingsPhotosWhereInput
    orderBy?: WeighingsPhotosOrderByWithRelationInput | WeighingsPhotosOrderByWithRelationInput[]
    cursor?: WeighingsPhotosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeighingsPhotosScalarFieldEnum | WeighingsPhotosScalarFieldEnum[]
  }

  /**
   * ArrivalItems.QcHistories
   */
  export type ArrivalItems$QcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    where?: QcHistoriesWhereInput
    orderBy?: QcHistoriesOrderByWithRelationInput | QcHistoriesOrderByWithRelationInput[]
    cursor?: QcHistoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcHistoriesScalarFieldEnum | QcHistoriesScalarFieldEnum[]
  }

  /**
   * ArrivalItems without action
   */
  export type ArrivalItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
  }


  /**
   * Model Weighings
   */

  export type AggregateWeighings = {
    _count: WeighingsCountAggregateOutputType | null
    _avg: WeighingsAvgAggregateOutputType | null
    _sum: WeighingsSumAggregateOutputType | null
    _min: WeighingsMinAggregateOutputType | null
    _max: WeighingsMaxAggregateOutputType | null
  }

  export type WeighingsAvgAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    weight: number | null
  }

  export type WeighingsSumAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    weight: number | null
  }

  export type WeighingsMinAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    weight: number | null
    note: string | null
    weighingDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type WeighingsMaxAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    weight: number | null
    note: string | null
    weighingDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type WeighingsCountAggregateOutputType = {
    id: number
    arrivalItemId: number
    weight: number
    note: number
    weighingDate: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type WeighingsAvgAggregateInputType = {
    id?: true
    arrivalItemId?: true
    weight?: true
  }

  export type WeighingsSumAggregateInputType = {
    id?: true
    arrivalItemId?: true
    weight?: true
  }

  export type WeighingsMinAggregateInputType = {
    id?: true
    arrivalItemId?: true
    weight?: true
    note?: true
    weighingDate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type WeighingsMaxAggregateInputType = {
    id?: true
    arrivalItemId?: true
    weight?: true
    note?: true
    weighingDate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type WeighingsCountAggregateInputType = {
    id?: true
    arrivalItemId?: true
    weight?: true
    note?: true
    weighingDate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type WeighingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weighings to aggregate.
     */
    where?: WeighingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weighings to fetch.
     */
    orderBy?: WeighingsOrderByWithRelationInput | WeighingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeighingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weighings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weighings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weighings
    **/
    _count?: true | WeighingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeighingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeighingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeighingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeighingsMaxAggregateInputType
  }

  export type GetWeighingsAggregateType<T extends WeighingsAggregateArgs> = {
        [P in keyof T & keyof AggregateWeighings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeighings[P]>
      : GetScalarType<T[P], AggregateWeighings[P]>
  }




  export type WeighingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeighingsWhereInput
    orderBy?: WeighingsOrderByWithAggregationInput | WeighingsOrderByWithAggregationInput[]
    by: WeighingsScalarFieldEnum[] | WeighingsScalarFieldEnum
    having?: WeighingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeighingsCountAggregateInputType | true
    _avg?: WeighingsAvgAggregateInputType
    _sum?: WeighingsSumAggregateInputType
    _min?: WeighingsMinAggregateInputType
    _max?: WeighingsMaxAggregateInputType
  }

  export type WeighingsGroupByOutputType = {
    id: number
    arrivalItemId: number
    weight: number
    note: string | null
    weighingDate: Date
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: WeighingsCountAggregateOutputType | null
    _avg: WeighingsAvgAggregateOutputType | null
    _sum: WeighingsSumAggregateOutputType | null
    _min: WeighingsMinAggregateOutputType | null
    _max: WeighingsMaxAggregateOutputType | null
  }

  type GetWeighingsGroupByPayload<T extends WeighingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeighingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeighingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeighingsGroupByOutputType[P]>
            : GetScalarType<T[P], WeighingsGroupByOutputType[P]>
        }
      >
    >


  export type WeighingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arrivalItemId?: boolean
    weight?: boolean
    note?: boolean
    weighingDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    arrivalItem?: boolean | ArrivalItemsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weighings"]>



  export type WeighingsSelectScalar = {
    id?: boolean
    arrivalItemId?: boolean
    weight?: boolean
    note?: boolean
    weighingDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type WeighingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "arrivalItemId" | "weight" | "note" | "weighingDate" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["weighings"]>
  export type WeighingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrivalItem?: boolean | ArrivalItemsDefaultArgs<ExtArgs>
  }

  export type $WeighingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weighings"
    objects: {
      arrivalItem: Prisma.$ArrivalItemsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      arrivalItemId: number
      weight: number
      note: string | null
      weighingDate: Date
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["weighings"]>
    composites: {}
  }

  type WeighingsGetPayload<S extends boolean | null | undefined | WeighingsDefaultArgs> = $Result.GetResult<Prisma.$WeighingsPayload, S>

  type WeighingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeighingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeighingsCountAggregateInputType | true
    }

  export interface WeighingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weighings'], meta: { name: 'Weighings' } }
    /**
     * Find zero or one Weighings that matches the filter.
     * @param {WeighingsFindUniqueArgs} args - Arguments to find a Weighings
     * @example
     * // Get one Weighings
     * const weighings = await prisma.weighings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeighingsFindUniqueArgs>(args: SelectSubset<T, WeighingsFindUniqueArgs<ExtArgs>>): Prisma__WeighingsClient<$Result.GetResult<Prisma.$WeighingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weighings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeighingsFindUniqueOrThrowArgs} args - Arguments to find a Weighings
     * @example
     * // Get one Weighings
     * const weighings = await prisma.weighings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeighingsFindUniqueOrThrowArgs>(args: SelectSubset<T, WeighingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeighingsClient<$Result.GetResult<Prisma.$WeighingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weighings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsFindFirstArgs} args - Arguments to find a Weighings
     * @example
     * // Get one Weighings
     * const weighings = await prisma.weighings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeighingsFindFirstArgs>(args?: SelectSubset<T, WeighingsFindFirstArgs<ExtArgs>>): Prisma__WeighingsClient<$Result.GetResult<Prisma.$WeighingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weighings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsFindFirstOrThrowArgs} args - Arguments to find a Weighings
     * @example
     * // Get one Weighings
     * const weighings = await prisma.weighings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeighingsFindFirstOrThrowArgs>(args?: SelectSubset<T, WeighingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeighingsClient<$Result.GetResult<Prisma.$WeighingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weighings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weighings
     * const weighings = await prisma.weighings.findMany()
     * 
     * // Get first 10 Weighings
     * const weighings = await prisma.weighings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weighingsWithIdOnly = await prisma.weighings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeighingsFindManyArgs>(args?: SelectSubset<T, WeighingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeighingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weighings.
     * @param {WeighingsCreateArgs} args - Arguments to create a Weighings.
     * @example
     * // Create one Weighings
     * const Weighings = await prisma.weighings.create({
     *   data: {
     *     // ... data to create a Weighings
     *   }
     * })
     * 
     */
    create<T extends WeighingsCreateArgs>(args: SelectSubset<T, WeighingsCreateArgs<ExtArgs>>): Prisma__WeighingsClient<$Result.GetResult<Prisma.$WeighingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weighings.
     * @param {WeighingsCreateManyArgs} args - Arguments to create many Weighings.
     * @example
     * // Create many Weighings
     * const weighings = await prisma.weighings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeighingsCreateManyArgs>(args?: SelectSubset<T, WeighingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Weighings.
     * @param {WeighingsDeleteArgs} args - Arguments to delete one Weighings.
     * @example
     * // Delete one Weighings
     * const Weighings = await prisma.weighings.delete({
     *   where: {
     *     // ... filter to delete one Weighings
     *   }
     * })
     * 
     */
    delete<T extends WeighingsDeleteArgs>(args: SelectSubset<T, WeighingsDeleteArgs<ExtArgs>>): Prisma__WeighingsClient<$Result.GetResult<Prisma.$WeighingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weighings.
     * @param {WeighingsUpdateArgs} args - Arguments to update one Weighings.
     * @example
     * // Update one Weighings
     * const weighings = await prisma.weighings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeighingsUpdateArgs>(args: SelectSubset<T, WeighingsUpdateArgs<ExtArgs>>): Prisma__WeighingsClient<$Result.GetResult<Prisma.$WeighingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weighings.
     * @param {WeighingsDeleteManyArgs} args - Arguments to filter Weighings to delete.
     * @example
     * // Delete a few Weighings
     * const { count } = await prisma.weighings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeighingsDeleteManyArgs>(args?: SelectSubset<T, WeighingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weighings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weighings
     * const weighings = await prisma.weighings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeighingsUpdateManyArgs>(args: SelectSubset<T, WeighingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Weighings.
     * @param {WeighingsUpsertArgs} args - Arguments to update or create a Weighings.
     * @example
     * // Update or create a Weighings
     * const weighings = await prisma.weighings.upsert({
     *   create: {
     *     // ... data to create a Weighings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weighings we want to update
     *   }
     * })
     */
    upsert<T extends WeighingsUpsertArgs>(args: SelectSubset<T, WeighingsUpsertArgs<ExtArgs>>): Prisma__WeighingsClient<$Result.GetResult<Prisma.$WeighingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weighings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsCountArgs} args - Arguments to filter Weighings to count.
     * @example
     * // Count the number of Weighings
     * const count = await prisma.weighings.count({
     *   where: {
     *     // ... the filter for the Weighings we want to count
     *   }
     * })
    **/
    count<T extends WeighingsCountArgs>(
      args?: Subset<T, WeighingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeighingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weighings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeighingsAggregateArgs>(args: Subset<T, WeighingsAggregateArgs>): Prisma.PrismaPromise<GetWeighingsAggregateType<T>>

    /**
     * Group by Weighings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeighingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeighingsGroupByArgs['orderBy'] }
        : { orderBy?: WeighingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeighingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeighingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weighings model
   */
  readonly fields: WeighingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weighings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeighingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    arrivalItem<T extends ArrivalItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItemsDefaultArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weighings model
   */
  interface WeighingsFieldRefs {
    readonly id: FieldRef<"Weighings", 'Int'>
    readonly arrivalItemId: FieldRef<"Weighings", 'Int'>
    readonly weight: FieldRef<"Weighings", 'Float'>
    readonly note: FieldRef<"Weighings", 'String'>
    readonly weighingDate: FieldRef<"Weighings", 'DateTime'>
    readonly createdAt: FieldRef<"Weighings", 'DateTime'>
    readonly createdBy: FieldRef<"Weighings", 'String'>
    readonly updatedAt: FieldRef<"Weighings", 'DateTime'>
    readonly updatedBy: FieldRef<"Weighings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Weighings findUnique
   */
  export type WeighingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
    /**
     * Filter, which Weighings to fetch.
     */
    where: WeighingsWhereUniqueInput
  }

  /**
   * Weighings findUniqueOrThrow
   */
  export type WeighingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
    /**
     * Filter, which Weighings to fetch.
     */
    where: WeighingsWhereUniqueInput
  }

  /**
   * Weighings findFirst
   */
  export type WeighingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
    /**
     * Filter, which Weighings to fetch.
     */
    where?: WeighingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weighings to fetch.
     */
    orderBy?: WeighingsOrderByWithRelationInput | WeighingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weighings.
     */
    cursor?: WeighingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weighings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weighings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weighings.
     */
    distinct?: WeighingsScalarFieldEnum | WeighingsScalarFieldEnum[]
  }

  /**
   * Weighings findFirstOrThrow
   */
  export type WeighingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
    /**
     * Filter, which Weighings to fetch.
     */
    where?: WeighingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weighings to fetch.
     */
    orderBy?: WeighingsOrderByWithRelationInput | WeighingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weighings.
     */
    cursor?: WeighingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weighings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weighings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weighings.
     */
    distinct?: WeighingsScalarFieldEnum | WeighingsScalarFieldEnum[]
  }

  /**
   * Weighings findMany
   */
  export type WeighingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
    /**
     * Filter, which Weighings to fetch.
     */
    where?: WeighingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weighings to fetch.
     */
    orderBy?: WeighingsOrderByWithRelationInput | WeighingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weighings.
     */
    cursor?: WeighingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weighings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weighings.
     */
    skip?: number
    distinct?: WeighingsScalarFieldEnum | WeighingsScalarFieldEnum[]
  }

  /**
   * Weighings create
   */
  export type WeighingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Weighings.
     */
    data: XOR<WeighingsCreateInput, WeighingsUncheckedCreateInput>
  }

  /**
   * Weighings createMany
   */
  export type WeighingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weighings.
     */
    data: WeighingsCreateManyInput | WeighingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weighings update
   */
  export type WeighingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Weighings.
     */
    data: XOR<WeighingsUpdateInput, WeighingsUncheckedUpdateInput>
    /**
     * Choose, which Weighings to update.
     */
    where: WeighingsWhereUniqueInput
  }

  /**
   * Weighings updateMany
   */
  export type WeighingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weighings.
     */
    data: XOR<WeighingsUpdateManyMutationInput, WeighingsUncheckedUpdateManyInput>
    /**
     * Filter which Weighings to update
     */
    where?: WeighingsWhereInput
    /**
     * Limit how many Weighings to update.
     */
    limit?: number
  }

  /**
   * Weighings upsert
   */
  export type WeighingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Weighings to update in case it exists.
     */
    where: WeighingsWhereUniqueInput
    /**
     * In case the Weighings found by the `where` argument doesn't exist, create a new Weighings with this data.
     */
    create: XOR<WeighingsCreateInput, WeighingsUncheckedCreateInput>
    /**
     * In case the Weighings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeighingsUpdateInput, WeighingsUncheckedUpdateInput>
  }

  /**
   * Weighings delete
   */
  export type WeighingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
    /**
     * Filter which Weighings to delete.
     */
    where: WeighingsWhereUniqueInput
  }

  /**
   * Weighings deleteMany
   */
  export type WeighingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weighings to delete
     */
    where?: WeighingsWhereInput
    /**
     * Limit how many Weighings to delete.
     */
    limit?: number
  }

  /**
   * Weighings without action
   */
  export type WeighingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weighings
     */
    select?: WeighingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weighings
     */
    omit?: WeighingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsInclude<ExtArgs> | null
  }


  /**
   * Model Notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    table: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    table: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    table: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    table?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    table?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    table?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to aggregate.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithAggregationInput | NotificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    table: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    table?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notifications"]>



  export type NotificationsSelectScalar = {
    id?: boolean
    table?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "table" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["notifications"]>

  export type $NotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      table: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type NotificationsGetPayload<S extends boolean | null | undefined | NotificationsDefaultArgs> = $Result.GetResult<Prisma.$NotificationsPayload, S>

  type NotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface NotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notifications'], meta: { name: 'Notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationsFindUniqueArgs>(args: SelectSubset<T, NotificationsFindUniqueArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationsFindFirstArgs>(args?: SelectSubset<T, NotificationsFindFirstArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationsFindManyArgs>(args?: SelectSubset<T, NotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends NotificationsCreateArgs>(args: SelectSubset<T, NotificationsCreateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationsCreateManyArgs>(args?: SelectSubset<T, NotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends NotificationsDeleteArgs>(args: SelectSubset<T, NotificationsDeleteArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationsUpdateArgs>(args: SelectSubset<T, NotificationsUpdateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationsDeleteManyArgs>(args?: SelectSubset<T, NotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationsUpdateManyArgs>(args: SelectSubset<T, NotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends NotificationsUpsertArgs>(args: SelectSubset<T, NotificationsUpsertArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notifications model
   */
  readonly fields: NotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notifications model
   */
  interface NotificationsFieldRefs {
    readonly id: FieldRef<"Notifications", 'Int'>
    readonly table: FieldRef<"Notifications", 'String'>
    readonly description: FieldRef<"Notifications", 'String'>
    readonly createdAt: FieldRef<"Notifications", 'DateTime'>
    readonly updatedAt: FieldRef<"Notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notifications findUnique
   */
  export type NotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findFirst
   */
  export type NotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications create
   */
  export type NotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * The data needed to create a Notifications.
     */
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }

  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * The data needed to update a Notifications.
     */
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     */
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     */
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }

  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Filter which Notifications to delete.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notifications without action
   */
  export type NotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
  }


  /**
   * Model QcResults
   */

  export type AggregateQcResults = {
    _count: QcResultsCountAggregateOutputType | null
    _avg: QcResultsAvgAggregateOutputType | null
    _sum: QcResultsSumAggregateOutputType | null
    _min: QcResultsMinAggregateOutputType | null
    _max: QcResultsMaxAggregateOutputType | null
  }

  export type QcResultsAvgAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    parameterId: number | null
    historyId: number | null
  }

  export type QcResultsSumAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    parameterId: number | null
    historyId: number | null
  }

  export type QcResultsMinAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    parameterId: number | null
    historyId: number | null
    resultKey: string | null
    value: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type QcResultsMaxAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    parameterId: number | null
    historyId: number | null
    resultKey: string | null
    value: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type QcResultsCountAggregateOutputType = {
    id: number
    arrivalItemId: number
    parameterId: number
    historyId: number
    resultKey: number
    value: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type QcResultsAvgAggregateInputType = {
    id?: true
    arrivalItemId?: true
    parameterId?: true
    historyId?: true
  }

  export type QcResultsSumAggregateInputType = {
    id?: true
    arrivalItemId?: true
    parameterId?: true
    historyId?: true
  }

  export type QcResultsMinAggregateInputType = {
    id?: true
    arrivalItemId?: true
    parameterId?: true
    historyId?: true
    resultKey?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type QcResultsMaxAggregateInputType = {
    id?: true
    arrivalItemId?: true
    parameterId?: true
    historyId?: true
    resultKey?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type QcResultsCountAggregateInputType = {
    id?: true
    arrivalItemId?: true
    parameterId?: true
    historyId?: true
    resultKey?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type QcResultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QcResults to aggregate.
     */
    where?: QcResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcResults to fetch.
     */
    orderBy?: QcResultsOrderByWithRelationInput | QcResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QcResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QcResults
    **/
    _count?: true | QcResultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QcResultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QcResultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QcResultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QcResultsMaxAggregateInputType
  }

  export type GetQcResultsAggregateType<T extends QcResultsAggregateArgs> = {
        [P in keyof T & keyof AggregateQcResults]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQcResults[P]>
      : GetScalarType<T[P], AggregateQcResults[P]>
  }




  export type QcResultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcResultsWhereInput
    orderBy?: QcResultsOrderByWithAggregationInput | QcResultsOrderByWithAggregationInput[]
    by: QcResultsScalarFieldEnum[] | QcResultsScalarFieldEnum
    having?: QcResultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QcResultsCountAggregateInputType | true
    _avg?: QcResultsAvgAggregateInputType
    _sum?: QcResultsSumAggregateInputType
    _min?: QcResultsMinAggregateInputType
    _max?: QcResultsMaxAggregateInputType
  }

  export type QcResultsGroupByOutputType = {
    id: number
    arrivalItemId: number
    parameterId: number
    historyId: number | null
    resultKey: string
    value: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: QcResultsCountAggregateOutputType | null
    _avg: QcResultsAvgAggregateOutputType | null
    _sum: QcResultsSumAggregateOutputType | null
    _min: QcResultsMinAggregateOutputType | null
    _max: QcResultsMaxAggregateOutputType | null
  }

  type GetQcResultsGroupByPayload<T extends QcResultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QcResultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QcResultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QcResultsGroupByOutputType[P]>
            : GetScalarType<T[P], QcResultsGroupByOutputType[P]>
        }
      >
    >


  export type QcResultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arrivalItemId?: boolean
    parameterId?: boolean
    historyId?: boolean
    resultKey?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    arrivalItem?: boolean | ArrivalItemsDefaultArgs<ExtArgs>
    parameter?: boolean | QcResults$parameterArgs<ExtArgs>
    history?: boolean | QcResults$historyArgs<ExtArgs>
  }, ExtArgs["result"]["qcResults"]>



  export type QcResultsSelectScalar = {
    id?: boolean
    arrivalItemId?: boolean
    parameterId?: boolean
    historyId?: boolean
    resultKey?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type QcResultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "arrivalItemId" | "parameterId" | "historyId" | "resultKey" | "value" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["qcResults"]>
  export type QcResultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrivalItem?: boolean | ArrivalItemsDefaultArgs<ExtArgs>
    parameter?: boolean | QcResults$parameterArgs<ExtArgs>
    history?: boolean | QcResults$historyArgs<ExtArgs>
  }

  export type $QcResultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QcResults"
    objects: {
      arrivalItem: Prisma.$ArrivalItemsPayload<ExtArgs>
      parameter: Prisma.$ParametersPayload<ExtArgs> | null
      history: Prisma.$QcHistoriesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      arrivalItemId: number
      parameterId: number
      historyId: number | null
      resultKey: string
      value: string
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["qcResults"]>
    composites: {}
  }

  type QcResultsGetPayload<S extends boolean | null | undefined | QcResultsDefaultArgs> = $Result.GetResult<Prisma.$QcResultsPayload, S>

  type QcResultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QcResultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QcResultsCountAggregateInputType | true
    }

  export interface QcResultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QcResults'], meta: { name: 'QcResults' } }
    /**
     * Find zero or one QcResults that matches the filter.
     * @param {QcResultsFindUniqueArgs} args - Arguments to find a QcResults
     * @example
     * // Get one QcResults
     * const qcResults = await prisma.qcResults.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QcResultsFindUniqueArgs>(args: SelectSubset<T, QcResultsFindUniqueArgs<ExtArgs>>): Prisma__QcResultsClient<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QcResults that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QcResultsFindUniqueOrThrowArgs} args - Arguments to find a QcResults
     * @example
     * // Get one QcResults
     * const qcResults = await prisma.qcResults.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QcResultsFindUniqueOrThrowArgs>(args: SelectSubset<T, QcResultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QcResultsClient<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultsFindFirstArgs} args - Arguments to find a QcResults
     * @example
     * // Get one QcResults
     * const qcResults = await prisma.qcResults.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QcResultsFindFirstArgs>(args?: SelectSubset<T, QcResultsFindFirstArgs<ExtArgs>>): Prisma__QcResultsClient<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcResults that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultsFindFirstOrThrowArgs} args - Arguments to find a QcResults
     * @example
     * // Get one QcResults
     * const qcResults = await prisma.qcResults.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QcResultsFindFirstOrThrowArgs>(args?: SelectSubset<T, QcResultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__QcResultsClient<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QcResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QcResults
     * const qcResults = await prisma.qcResults.findMany()
     * 
     * // Get first 10 QcResults
     * const qcResults = await prisma.qcResults.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qcResultsWithIdOnly = await prisma.qcResults.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QcResultsFindManyArgs>(args?: SelectSubset<T, QcResultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QcResults.
     * @param {QcResultsCreateArgs} args - Arguments to create a QcResults.
     * @example
     * // Create one QcResults
     * const QcResults = await prisma.qcResults.create({
     *   data: {
     *     // ... data to create a QcResults
     *   }
     * })
     * 
     */
    create<T extends QcResultsCreateArgs>(args: SelectSubset<T, QcResultsCreateArgs<ExtArgs>>): Prisma__QcResultsClient<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QcResults.
     * @param {QcResultsCreateManyArgs} args - Arguments to create many QcResults.
     * @example
     * // Create many QcResults
     * const qcResults = await prisma.qcResults.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QcResultsCreateManyArgs>(args?: SelectSubset<T, QcResultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QcResults.
     * @param {QcResultsDeleteArgs} args - Arguments to delete one QcResults.
     * @example
     * // Delete one QcResults
     * const QcResults = await prisma.qcResults.delete({
     *   where: {
     *     // ... filter to delete one QcResults
     *   }
     * })
     * 
     */
    delete<T extends QcResultsDeleteArgs>(args: SelectSubset<T, QcResultsDeleteArgs<ExtArgs>>): Prisma__QcResultsClient<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QcResults.
     * @param {QcResultsUpdateArgs} args - Arguments to update one QcResults.
     * @example
     * // Update one QcResults
     * const qcResults = await prisma.qcResults.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QcResultsUpdateArgs>(args: SelectSubset<T, QcResultsUpdateArgs<ExtArgs>>): Prisma__QcResultsClient<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QcResults.
     * @param {QcResultsDeleteManyArgs} args - Arguments to filter QcResults to delete.
     * @example
     * // Delete a few QcResults
     * const { count } = await prisma.qcResults.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QcResultsDeleteManyArgs>(args?: SelectSubset<T, QcResultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QcResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QcResults
     * const qcResults = await prisma.qcResults.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QcResultsUpdateManyArgs>(args: SelectSubset<T, QcResultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QcResults.
     * @param {QcResultsUpsertArgs} args - Arguments to update or create a QcResults.
     * @example
     * // Update or create a QcResults
     * const qcResults = await prisma.qcResults.upsert({
     *   create: {
     *     // ... data to create a QcResults
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QcResults we want to update
     *   }
     * })
     */
    upsert<T extends QcResultsUpsertArgs>(args: SelectSubset<T, QcResultsUpsertArgs<ExtArgs>>): Prisma__QcResultsClient<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QcResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultsCountArgs} args - Arguments to filter QcResults to count.
     * @example
     * // Count the number of QcResults
     * const count = await prisma.qcResults.count({
     *   where: {
     *     // ... the filter for the QcResults we want to count
     *   }
     * })
    **/
    count<T extends QcResultsCountArgs>(
      args?: Subset<T, QcResultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QcResultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QcResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QcResultsAggregateArgs>(args: Subset<T, QcResultsAggregateArgs>): Prisma.PrismaPromise<GetQcResultsAggregateType<T>>

    /**
     * Group by QcResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QcResultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QcResultsGroupByArgs['orderBy'] }
        : { orderBy?: QcResultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QcResultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQcResultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QcResults model
   */
  readonly fields: QcResultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QcResults.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QcResultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    arrivalItem<T extends ArrivalItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItemsDefaultArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parameter<T extends QcResults$parameterArgs<ExtArgs> = {}>(args?: Subset<T, QcResults$parameterArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    history<T extends QcResults$historyArgs<ExtArgs> = {}>(args?: Subset<T, QcResults$historyArgs<ExtArgs>>): Prisma__QcHistoriesClient<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QcResults model
   */
  interface QcResultsFieldRefs {
    readonly id: FieldRef<"QcResults", 'Int'>
    readonly arrivalItemId: FieldRef<"QcResults", 'Int'>
    readonly parameterId: FieldRef<"QcResults", 'Int'>
    readonly historyId: FieldRef<"QcResults", 'Int'>
    readonly resultKey: FieldRef<"QcResults", 'String'>
    readonly value: FieldRef<"QcResults", 'String'>
    readonly createdAt: FieldRef<"QcResults", 'DateTime'>
    readonly createdBy: FieldRef<"QcResults", 'String'>
    readonly updatedAt: FieldRef<"QcResults", 'DateTime'>
    readonly updatedBy: FieldRef<"QcResults", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QcResults findUnique
   */
  export type QcResultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    /**
     * Filter, which QcResults to fetch.
     */
    where: QcResultsWhereUniqueInput
  }

  /**
   * QcResults findUniqueOrThrow
   */
  export type QcResultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    /**
     * Filter, which QcResults to fetch.
     */
    where: QcResultsWhereUniqueInput
  }

  /**
   * QcResults findFirst
   */
  export type QcResultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    /**
     * Filter, which QcResults to fetch.
     */
    where?: QcResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcResults to fetch.
     */
    orderBy?: QcResultsOrderByWithRelationInput | QcResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QcResults.
     */
    cursor?: QcResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QcResults.
     */
    distinct?: QcResultsScalarFieldEnum | QcResultsScalarFieldEnum[]
  }

  /**
   * QcResults findFirstOrThrow
   */
  export type QcResultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    /**
     * Filter, which QcResults to fetch.
     */
    where?: QcResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcResults to fetch.
     */
    orderBy?: QcResultsOrderByWithRelationInput | QcResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QcResults.
     */
    cursor?: QcResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QcResults.
     */
    distinct?: QcResultsScalarFieldEnum | QcResultsScalarFieldEnum[]
  }

  /**
   * QcResults findMany
   */
  export type QcResultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    /**
     * Filter, which QcResults to fetch.
     */
    where?: QcResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcResults to fetch.
     */
    orderBy?: QcResultsOrderByWithRelationInput | QcResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QcResults.
     */
    cursor?: QcResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcResults.
     */
    skip?: number
    distinct?: QcResultsScalarFieldEnum | QcResultsScalarFieldEnum[]
  }

  /**
   * QcResults create
   */
  export type QcResultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    /**
     * The data needed to create a QcResults.
     */
    data: XOR<QcResultsCreateInput, QcResultsUncheckedCreateInput>
  }

  /**
   * QcResults createMany
   */
  export type QcResultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QcResults.
     */
    data: QcResultsCreateManyInput | QcResultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QcResults update
   */
  export type QcResultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    /**
     * The data needed to update a QcResults.
     */
    data: XOR<QcResultsUpdateInput, QcResultsUncheckedUpdateInput>
    /**
     * Choose, which QcResults to update.
     */
    where: QcResultsWhereUniqueInput
  }

  /**
   * QcResults updateMany
   */
  export type QcResultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QcResults.
     */
    data: XOR<QcResultsUpdateManyMutationInput, QcResultsUncheckedUpdateManyInput>
    /**
     * Filter which QcResults to update
     */
    where?: QcResultsWhereInput
    /**
     * Limit how many QcResults to update.
     */
    limit?: number
  }

  /**
   * QcResults upsert
   */
  export type QcResultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    /**
     * The filter to search for the QcResults to update in case it exists.
     */
    where: QcResultsWhereUniqueInput
    /**
     * In case the QcResults found by the `where` argument doesn't exist, create a new QcResults with this data.
     */
    create: XOR<QcResultsCreateInput, QcResultsUncheckedCreateInput>
    /**
     * In case the QcResults was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QcResultsUpdateInput, QcResultsUncheckedUpdateInput>
  }

  /**
   * QcResults delete
   */
  export type QcResultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    /**
     * Filter which QcResults to delete.
     */
    where: QcResultsWhereUniqueInput
  }

  /**
   * QcResults deleteMany
   */
  export type QcResultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QcResults to delete
     */
    where?: QcResultsWhereInput
    /**
     * Limit how many QcResults to delete.
     */
    limit?: number
  }

  /**
   * QcResults.parameter
   */
  export type QcResults$parameterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameters
     */
    select?: ParametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameters
     */
    omit?: ParametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametersInclude<ExtArgs> | null
    where?: ParametersWhereInput
  }

  /**
   * QcResults.history
   */
  export type QcResults$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    where?: QcHistoriesWhereInput
  }

  /**
   * QcResults without action
   */
  export type QcResultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
  }


  /**
   * Model QcStatus
   */

  export type AggregateQcStatus = {
    _count: QcStatusCountAggregateOutputType | null
    _avg: QcStatusAvgAggregateOutputType | null
    _sum: QcStatusSumAggregateOutputType | null
    _min: QcStatusMinAggregateOutputType | null
    _max: QcStatusMaxAggregateOutputType | null
  }

  export type QcStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type QcStatusSumAggregateOutputType = {
    id: number | null
  }

  export type QcStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type QcStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type QcStatusCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type QcStatusAvgAggregateInputType = {
    id?: true
  }

  export type QcStatusSumAggregateInputType = {
    id?: true
  }

  export type QcStatusMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type QcStatusMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type QcStatusCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type QcStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QcStatus to aggregate.
     */
    where?: QcStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcStatuses to fetch.
     */
    orderBy?: QcStatusOrderByWithRelationInput | QcStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QcStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QcStatuses
    **/
    _count?: true | QcStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QcStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QcStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QcStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QcStatusMaxAggregateInputType
  }

  export type GetQcStatusAggregateType<T extends QcStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateQcStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQcStatus[P]>
      : GetScalarType<T[P], AggregateQcStatus[P]>
  }




  export type QcStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcStatusWhereInput
    orderBy?: QcStatusOrderByWithAggregationInput | QcStatusOrderByWithAggregationInput[]
    by: QcStatusScalarFieldEnum[] | QcStatusScalarFieldEnum
    having?: QcStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QcStatusCountAggregateInputType | true
    _avg?: QcStatusAvgAggregateInputType
    _sum?: QcStatusSumAggregateInputType
    _min?: QcStatusMinAggregateInputType
    _max?: QcStatusMaxAggregateInputType
  }

  export type QcStatusGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: QcStatusCountAggregateOutputType | null
    _avg: QcStatusAvgAggregateOutputType | null
    _sum: QcStatusSumAggregateOutputType | null
    _min: QcStatusMinAggregateOutputType | null
    _max: QcStatusMaxAggregateOutputType | null
  }

  type GetQcStatusGroupByPayload<T extends QcStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QcStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QcStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QcStatusGroupByOutputType[P]>
            : GetScalarType<T[P], QcStatusGroupByOutputType[P]>
        }
      >
    >


  export type QcStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ArrivalItems?: boolean | QcStatus$ArrivalItemsArgs<ExtArgs>
    QcHistories?: boolean | QcStatus$QcHistoriesArgs<ExtArgs>
    _count?: boolean | QcStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qcStatus"]>



  export type QcStatusSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type QcStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["qcStatus"]>
  export type QcStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ArrivalItems?: boolean | QcStatus$ArrivalItemsArgs<ExtArgs>
    QcHistories?: boolean | QcStatus$QcHistoriesArgs<ExtArgs>
    _count?: boolean | QcStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QcStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QcStatus"
    objects: {
      ArrivalItems: Prisma.$ArrivalItemsPayload<ExtArgs>[]
      QcHistories: Prisma.$QcHistoriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["qcStatus"]>
    composites: {}
  }

  type QcStatusGetPayload<S extends boolean | null | undefined | QcStatusDefaultArgs> = $Result.GetResult<Prisma.$QcStatusPayload, S>

  type QcStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QcStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QcStatusCountAggregateInputType | true
    }

  export interface QcStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QcStatus'], meta: { name: 'QcStatus' } }
    /**
     * Find zero or one QcStatus that matches the filter.
     * @param {QcStatusFindUniqueArgs} args - Arguments to find a QcStatus
     * @example
     * // Get one QcStatus
     * const qcStatus = await prisma.qcStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QcStatusFindUniqueArgs>(args: SelectSubset<T, QcStatusFindUniqueArgs<ExtArgs>>): Prisma__QcStatusClient<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QcStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QcStatusFindUniqueOrThrowArgs} args - Arguments to find a QcStatus
     * @example
     * // Get one QcStatus
     * const qcStatus = await prisma.qcStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QcStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, QcStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QcStatusClient<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcStatusFindFirstArgs} args - Arguments to find a QcStatus
     * @example
     * // Get one QcStatus
     * const qcStatus = await prisma.qcStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QcStatusFindFirstArgs>(args?: SelectSubset<T, QcStatusFindFirstArgs<ExtArgs>>): Prisma__QcStatusClient<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcStatusFindFirstOrThrowArgs} args - Arguments to find a QcStatus
     * @example
     * // Get one QcStatus
     * const qcStatus = await prisma.qcStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QcStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, QcStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__QcStatusClient<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QcStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QcStatuses
     * const qcStatuses = await prisma.qcStatus.findMany()
     * 
     * // Get first 10 QcStatuses
     * const qcStatuses = await prisma.qcStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qcStatusWithIdOnly = await prisma.qcStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QcStatusFindManyArgs>(args?: SelectSubset<T, QcStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QcStatus.
     * @param {QcStatusCreateArgs} args - Arguments to create a QcStatus.
     * @example
     * // Create one QcStatus
     * const QcStatus = await prisma.qcStatus.create({
     *   data: {
     *     // ... data to create a QcStatus
     *   }
     * })
     * 
     */
    create<T extends QcStatusCreateArgs>(args: SelectSubset<T, QcStatusCreateArgs<ExtArgs>>): Prisma__QcStatusClient<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QcStatuses.
     * @param {QcStatusCreateManyArgs} args - Arguments to create many QcStatuses.
     * @example
     * // Create many QcStatuses
     * const qcStatus = await prisma.qcStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QcStatusCreateManyArgs>(args?: SelectSubset<T, QcStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QcStatus.
     * @param {QcStatusDeleteArgs} args - Arguments to delete one QcStatus.
     * @example
     * // Delete one QcStatus
     * const QcStatus = await prisma.qcStatus.delete({
     *   where: {
     *     // ... filter to delete one QcStatus
     *   }
     * })
     * 
     */
    delete<T extends QcStatusDeleteArgs>(args: SelectSubset<T, QcStatusDeleteArgs<ExtArgs>>): Prisma__QcStatusClient<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QcStatus.
     * @param {QcStatusUpdateArgs} args - Arguments to update one QcStatus.
     * @example
     * // Update one QcStatus
     * const qcStatus = await prisma.qcStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QcStatusUpdateArgs>(args: SelectSubset<T, QcStatusUpdateArgs<ExtArgs>>): Prisma__QcStatusClient<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QcStatuses.
     * @param {QcStatusDeleteManyArgs} args - Arguments to filter QcStatuses to delete.
     * @example
     * // Delete a few QcStatuses
     * const { count } = await prisma.qcStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QcStatusDeleteManyArgs>(args?: SelectSubset<T, QcStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QcStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QcStatuses
     * const qcStatus = await prisma.qcStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QcStatusUpdateManyArgs>(args: SelectSubset<T, QcStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QcStatus.
     * @param {QcStatusUpsertArgs} args - Arguments to update or create a QcStatus.
     * @example
     * // Update or create a QcStatus
     * const qcStatus = await prisma.qcStatus.upsert({
     *   create: {
     *     // ... data to create a QcStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QcStatus we want to update
     *   }
     * })
     */
    upsert<T extends QcStatusUpsertArgs>(args: SelectSubset<T, QcStatusUpsertArgs<ExtArgs>>): Prisma__QcStatusClient<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QcStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcStatusCountArgs} args - Arguments to filter QcStatuses to count.
     * @example
     * // Count the number of QcStatuses
     * const count = await prisma.qcStatus.count({
     *   where: {
     *     // ... the filter for the QcStatuses we want to count
     *   }
     * })
    **/
    count<T extends QcStatusCountArgs>(
      args?: Subset<T, QcStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QcStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QcStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QcStatusAggregateArgs>(args: Subset<T, QcStatusAggregateArgs>): Prisma.PrismaPromise<GetQcStatusAggregateType<T>>

    /**
     * Group by QcStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QcStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QcStatusGroupByArgs['orderBy'] }
        : { orderBy?: QcStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QcStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQcStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QcStatus model
   */
  readonly fields: QcStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QcStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QcStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ArrivalItems<T extends QcStatus$ArrivalItemsArgs<ExtArgs> = {}>(args?: Subset<T, QcStatus$ArrivalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    QcHistories<T extends QcStatus$QcHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, QcStatus$QcHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QcStatus model
   */
  interface QcStatusFieldRefs {
    readonly id: FieldRef<"QcStatus", 'Int'>
    readonly name: FieldRef<"QcStatus", 'String'>
    readonly description: FieldRef<"QcStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QcStatus findUnique
   */
  export type QcStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
    /**
     * Filter, which QcStatus to fetch.
     */
    where: QcStatusWhereUniqueInput
  }

  /**
   * QcStatus findUniqueOrThrow
   */
  export type QcStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
    /**
     * Filter, which QcStatus to fetch.
     */
    where: QcStatusWhereUniqueInput
  }

  /**
   * QcStatus findFirst
   */
  export type QcStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
    /**
     * Filter, which QcStatus to fetch.
     */
    where?: QcStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcStatuses to fetch.
     */
    orderBy?: QcStatusOrderByWithRelationInput | QcStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QcStatuses.
     */
    cursor?: QcStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QcStatuses.
     */
    distinct?: QcStatusScalarFieldEnum | QcStatusScalarFieldEnum[]
  }

  /**
   * QcStatus findFirstOrThrow
   */
  export type QcStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
    /**
     * Filter, which QcStatus to fetch.
     */
    where?: QcStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcStatuses to fetch.
     */
    orderBy?: QcStatusOrderByWithRelationInput | QcStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QcStatuses.
     */
    cursor?: QcStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QcStatuses.
     */
    distinct?: QcStatusScalarFieldEnum | QcStatusScalarFieldEnum[]
  }

  /**
   * QcStatus findMany
   */
  export type QcStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
    /**
     * Filter, which QcStatuses to fetch.
     */
    where?: QcStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcStatuses to fetch.
     */
    orderBy?: QcStatusOrderByWithRelationInput | QcStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QcStatuses.
     */
    cursor?: QcStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcStatuses.
     */
    skip?: number
    distinct?: QcStatusScalarFieldEnum | QcStatusScalarFieldEnum[]
  }

  /**
   * QcStatus create
   */
  export type QcStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a QcStatus.
     */
    data: XOR<QcStatusCreateInput, QcStatusUncheckedCreateInput>
  }

  /**
   * QcStatus createMany
   */
  export type QcStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QcStatuses.
     */
    data: QcStatusCreateManyInput | QcStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QcStatus update
   */
  export type QcStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a QcStatus.
     */
    data: XOR<QcStatusUpdateInput, QcStatusUncheckedUpdateInput>
    /**
     * Choose, which QcStatus to update.
     */
    where: QcStatusWhereUniqueInput
  }

  /**
   * QcStatus updateMany
   */
  export type QcStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QcStatuses.
     */
    data: XOR<QcStatusUpdateManyMutationInput, QcStatusUncheckedUpdateManyInput>
    /**
     * Filter which QcStatuses to update
     */
    where?: QcStatusWhereInput
    /**
     * Limit how many QcStatuses to update.
     */
    limit?: number
  }

  /**
   * QcStatus upsert
   */
  export type QcStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the QcStatus to update in case it exists.
     */
    where: QcStatusWhereUniqueInput
    /**
     * In case the QcStatus found by the `where` argument doesn't exist, create a new QcStatus with this data.
     */
    create: XOR<QcStatusCreateInput, QcStatusUncheckedCreateInput>
    /**
     * In case the QcStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QcStatusUpdateInput, QcStatusUncheckedUpdateInput>
  }

  /**
   * QcStatus delete
   */
  export type QcStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
    /**
     * Filter which QcStatus to delete.
     */
    where: QcStatusWhereUniqueInput
  }

  /**
   * QcStatus deleteMany
   */
  export type QcStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QcStatuses to delete
     */
    where?: QcStatusWhereInput
    /**
     * Limit how many QcStatuses to delete.
     */
    limit?: number
  }

  /**
   * QcStatus.ArrivalItems
   */
  export type QcStatus$ArrivalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    where?: ArrivalItemsWhereInput
    orderBy?: ArrivalItemsOrderByWithRelationInput | ArrivalItemsOrderByWithRelationInput[]
    cursor?: ArrivalItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArrivalItemsScalarFieldEnum | ArrivalItemsScalarFieldEnum[]
  }

  /**
   * QcStatus.QcHistories
   */
  export type QcStatus$QcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    where?: QcHistoriesWhereInput
    orderBy?: QcHistoriesOrderByWithRelationInput | QcHistoriesOrderByWithRelationInput[]
    cursor?: QcHistoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcHistoriesScalarFieldEnum | QcHistoriesScalarFieldEnum[]
  }

  /**
   * QcStatus without action
   */
  export type QcStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcStatus
     */
    select?: QcStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcStatus
     */
    omit?: QcStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcStatusInclude<ExtArgs> | null
  }


  /**
   * Model QcPhotos
   */

  export type AggregateQcPhotos = {
    _count: QcPhotosCountAggregateOutputType | null
    _avg: QcPhotosAvgAggregateOutputType | null
    _sum: QcPhotosSumAggregateOutputType | null
    _min: QcPhotosMinAggregateOutputType | null
    _max: QcPhotosMaxAggregateOutputType | null
  }

  export type QcPhotosAvgAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
  }

  export type QcPhotosSumAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
  }

  export type QcPhotosMinAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    photo: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type QcPhotosMaxAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    photo: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type QcPhotosCountAggregateOutputType = {
    id: number
    arrivalItemId: number
    photo: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type QcPhotosAvgAggregateInputType = {
    id?: true
    arrivalItemId?: true
  }

  export type QcPhotosSumAggregateInputType = {
    id?: true
    arrivalItemId?: true
  }

  export type QcPhotosMinAggregateInputType = {
    id?: true
    arrivalItemId?: true
    photo?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type QcPhotosMaxAggregateInputType = {
    id?: true
    arrivalItemId?: true
    photo?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type QcPhotosCountAggregateInputType = {
    id?: true
    arrivalItemId?: true
    photo?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type QcPhotosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QcPhotos to aggregate.
     */
    where?: QcPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcPhotos to fetch.
     */
    orderBy?: QcPhotosOrderByWithRelationInput | QcPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QcPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QcPhotos
    **/
    _count?: true | QcPhotosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QcPhotosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QcPhotosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QcPhotosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QcPhotosMaxAggregateInputType
  }

  export type GetQcPhotosAggregateType<T extends QcPhotosAggregateArgs> = {
        [P in keyof T & keyof AggregateQcPhotos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQcPhotos[P]>
      : GetScalarType<T[P], AggregateQcPhotos[P]>
  }




  export type QcPhotosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcPhotosWhereInput
    orderBy?: QcPhotosOrderByWithAggregationInput | QcPhotosOrderByWithAggregationInput[]
    by: QcPhotosScalarFieldEnum[] | QcPhotosScalarFieldEnum
    having?: QcPhotosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QcPhotosCountAggregateInputType | true
    _avg?: QcPhotosAvgAggregateInputType
    _sum?: QcPhotosSumAggregateInputType
    _min?: QcPhotosMinAggregateInputType
    _max?: QcPhotosMaxAggregateInputType
  }

  export type QcPhotosGroupByOutputType = {
    id: number
    arrivalItemId: number
    photo: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: QcPhotosCountAggregateOutputType | null
    _avg: QcPhotosAvgAggregateOutputType | null
    _sum: QcPhotosSumAggregateOutputType | null
    _min: QcPhotosMinAggregateOutputType | null
    _max: QcPhotosMaxAggregateOutputType | null
  }

  type GetQcPhotosGroupByPayload<T extends QcPhotosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QcPhotosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QcPhotosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QcPhotosGroupByOutputType[P]>
            : GetScalarType<T[P], QcPhotosGroupByOutputType[P]>
        }
      >
    >


  export type QcPhotosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arrivalItemId?: boolean
    photo?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    arrivalItem?: boolean | ArrivalItemsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qcPhotos"]>



  export type QcPhotosSelectScalar = {
    id?: boolean
    arrivalItemId?: boolean
    photo?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type QcPhotosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "arrivalItemId" | "photo" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["qcPhotos"]>
  export type QcPhotosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrivalItem?: boolean | ArrivalItemsDefaultArgs<ExtArgs>
  }

  export type $QcPhotosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QcPhotos"
    objects: {
      arrivalItem: Prisma.$ArrivalItemsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      arrivalItemId: number
      photo: string
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["qcPhotos"]>
    composites: {}
  }

  type QcPhotosGetPayload<S extends boolean | null | undefined | QcPhotosDefaultArgs> = $Result.GetResult<Prisma.$QcPhotosPayload, S>

  type QcPhotosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QcPhotosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QcPhotosCountAggregateInputType | true
    }

  export interface QcPhotosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QcPhotos'], meta: { name: 'QcPhotos' } }
    /**
     * Find zero or one QcPhotos that matches the filter.
     * @param {QcPhotosFindUniqueArgs} args - Arguments to find a QcPhotos
     * @example
     * // Get one QcPhotos
     * const qcPhotos = await prisma.qcPhotos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QcPhotosFindUniqueArgs>(args: SelectSubset<T, QcPhotosFindUniqueArgs<ExtArgs>>): Prisma__QcPhotosClient<$Result.GetResult<Prisma.$QcPhotosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QcPhotos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QcPhotosFindUniqueOrThrowArgs} args - Arguments to find a QcPhotos
     * @example
     * // Get one QcPhotos
     * const qcPhotos = await prisma.qcPhotos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QcPhotosFindUniqueOrThrowArgs>(args: SelectSubset<T, QcPhotosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QcPhotosClient<$Result.GetResult<Prisma.$QcPhotosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcPhotosFindFirstArgs} args - Arguments to find a QcPhotos
     * @example
     * // Get one QcPhotos
     * const qcPhotos = await prisma.qcPhotos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QcPhotosFindFirstArgs>(args?: SelectSubset<T, QcPhotosFindFirstArgs<ExtArgs>>): Prisma__QcPhotosClient<$Result.GetResult<Prisma.$QcPhotosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcPhotos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcPhotosFindFirstOrThrowArgs} args - Arguments to find a QcPhotos
     * @example
     * // Get one QcPhotos
     * const qcPhotos = await prisma.qcPhotos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QcPhotosFindFirstOrThrowArgs>(args?: SelectSubset<T, QcPhotosFindFirstOrThrowArgs<ExtArgs>>): Prisma__QcPhotosClient<$Result.GetResult<Prisma.$QcPhotosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QcPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcPhotosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QcPhotos
     * const qcPhotos = await prisma.qcPhotos.findMany()
     * 
     * // Get first 10 QcPhotos
     * const qcPhotos = await prisma.qcPhotos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qcPhotosWithIdOnly = await prisma.qcPhotos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QcPhotosFindManyArgs>(args?: SelectSubset<T, QcPhotosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcPhotosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QcPhotos.
     * @param {QcPhotosCreateArgs} args - Arguments to create a QcPhotos.
     * @example
     * // Create one QcPhotos
     * const QcPhotos = await prisma.qcPhotos.create({
     *   data: {
     *     // ... data to create a QcPhotos
     *   }
     * })
     * 
     */
    create<T extends QcPhotosCreateArgs>(args: SelectSubset<T, QcPhotosCreateArgs<ExtArgs>>): Prisma__QcPhotosClient<$Result.GetResult<Prisma.$QcPhotosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QcPhotos.
     * @param {QcPhotosCreateManyArgs} args - Arguments to create many QcPhotos.
     * @example
     * // Create many QcPhotos
     * const qcPhotos = await prisma.qcPhotos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QcPhotosCreateManyArgs>(args?: SelectSubset<T, QcPhotosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QcPhotos.
     * @param {QcPhotosDeleteArgs} args - Arguments to delete one QcPhotos.
     * @example
     * // Delete one QcPhotos
     * const QcPhotos = await prisma.qcPhotos.delete({
     *   where: {
     *     // ... filter to delete one QcPhotos
     *   }
     * })
     * 
     */
    delete<T extends QcPhotosDeleteArgs>(args: SelectSubset<T, QcPhotosDeleteArgs<ExtArgs>>): Prisma__QcPhotosClient<$Result.GetResult<Prisma.$QcPhotosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QcPhotos.
     * @param {QcPhotosUpdateArgs} args - Arguments to update one QcPhotos.
     * @example
     * // Update one QcPhotos
     * const qcPhotos = await prisma.qcPhotos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QcPhotosUpdateArgs>(args: SelectSubset<T, QcPhotosUpdateArgs<ExtArgs>>): Prisma__QcPhotosClient<$Result.GetResult<Prisma.$QcPhotosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QcPhotos.
     * @param {QcPhotosDeleteManyArgs} args - Arguments to filter QcPhotos to delete.
     * @example
     * // Delete a few QcPhotos
     * const { count } = await prisma.qcPhotos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QcPhotosDeleteManyArgs>(args?: SelectSubset<T, QcPhotosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QcPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcPhotosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QcPhotos
     * const qcPhotos = await prisma.qcPhotos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QcPhotosUpdateManyArgs>(args: SelectSubset<T, QcPhotosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QcPhotos.
     * @param {QcPhotosUpsertArgs} args - Arguments to update or create a QcPhotos.
     * @example
     * // Update or create a QcPhotos
     * const qcPhotos = await prisma.qcPhotos.upsert({
     *   create: {
     *     // ... data to create a QcPhotos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QcPhotos we want to update
     *   }
     * })
     */
    upsert<T extends QcPhotosUpsertArgs>(args: SelectSubset<T, QcPhotosUpsertArgs<ExtArgs>>): Prisma__QcPhotosClient<$Result.GetResult<Prisma.$QcPhotosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QcPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcPhotosCountArgs} args - Arguments to filter QcPhotos to count.
     * @example
     * // Count the number of QcPhotos
     * const count = await prisma.qcPhotos.count({
     *   where: {
     *     // ... the filter for the QcPhotos we want to count
     *   }
     * })
    **/
    count<T extends QcPhotosCountArgs>(
      args?: Subset<T, QcPhotosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QcPhotosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QcPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcPhotosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QcPhotosAggregateArgs>(args: Subset<T, QcPhotosAggregateArgs>): Prisma.PrismaPromise<GetQcPhotosAggregateType<T>>

    /**
     * Group by QcPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcPhotosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QcPhotosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QcPhotosGroupByArgs['orderBy'] }
        : { orderBy?: QcPhotosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QcPhotosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQcPhotosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QcPhotos model
   */
  readonly fields: QcPhotosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QcPhotos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QcPhotosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    arrivalItem<T extends ArrivalItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItemsDefaultArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QcPhotos model
   */
  interface QcPhotosFieldRefs {
    readonly id: FieldRef<"QcPhotos", 'Int'>
    readonly arrivalItemId: FieldRef<"QcPhotos", 'Int'>
    readonly photo: FieldRef<"QcPhotos", 'String'>
    readonly createdAt: FieldRef<"QcPhotos", 'DateTime'>
    readonly createdBy: FieldRef<"QcPhotos", 'String'>
    readonly updatedAt: FieldRef<"QcPhotos", 'DateTime'>
    readonly updatedBy: FieldRef<"QcPhotos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QcPhotos findUnique
   */
  export type QcPhotosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
    /**
     * Filter, which QcPhotos to fetch.
     */
    where: QcPhotosWhereUniqueInput
  }

  /**
   * QcPhotos findUniqueOrThrow
   */
  export type QcPhotosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
    /**
     * Filter, which QcPhotos to fetch.
     */
    where: QcPhotosWhereUniqueInput
  }

  /**
   * QcPhotos findFirst
   */
  export type QcPhotosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
    /**
     * Filter, which QcPhotos to fetch.
     */
    where?: QcPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcPhotos to fetch.
     */
    orderBy?: QcPhotosOrderByWithRelationInput | QcPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QcPhotos.
     */
    cursor?: QcPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QcPhotos.
     */
    distinct?: QcPhotosScalarFieldEnum | QcPhotosScalarFieldEnum[]
  }

  /**
   * QcPhotos findFirstOrThrow
   */
  export type QcPhotosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
    /**
     * Filter, which QcPhotos to fetch.
     */
    where?: QcPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcPhotos to fetch.
     */
    orderBy?: QcPhotosOrderByWithRelationInput | QcPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QcPhotos.
     */
    cursor?: QcPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QcPhotos.
     */
    distinct?: QcPhotosScalarFieldEnum | QcPhotosScalarFieldEnum[]
  }

  /**
   * QcPhotos findMany
   */
  export type QcPhotosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
    /**
     * Filter, which QcPhotos to fetch.
     */
    where?: QcPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcPhotos to fetch.
     */
    orderBy?: QcPhotosOrderByWithRelationInput | QcPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QcPhotos.
     */
    cursor?: QcPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcPhotos.
     */
    skip?: number
    distinct?: QcPhotosScalarFieldEnum | QcPhotosScalarFieldEnum[]
  }

  /**
   * QcPhotos create
   */
  export type QcPhotosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
    /**
     * The data needed to create a QcPhotos.
     */
    data: XOR<QcPhotosCreateInput, QcPhotosUncheckedCreateInput>
  }

  /**
   * QcPhotos createMany
   */
  export type QcPhotosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QcPhotos.
     */
    data: QcPhotosCreateManyInput | QcPhotosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QcPhotos update
   */
  export type QcPhotosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
    /**
     * The data needed to update a QcPhotos.
     */
    data: XOR<QcPhotosUpdateInput, QcPhotosUncheckedUpdateInput>
    /**
     * Choose, which QcPhotos to update.
     */
    where: QcPhotosWhereUniqueInput
  }

  /**
   * QcPhotos updateMany
   */
  export type QcPhotosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QcPhotos.
     */
    data: XOR<QcPhotosUpdateManyMutationInput, QcPhotosUncheckedUpdateManyInput>
    /**
     * Filter which QcPhotos to update
     */
    where?: QcPhotosWhereInput
    /**
     * Limit how many QcPhotos to update.
     */
    limit?: number
  }

  /**
   * QcPhotos upsert
   */
  export type QcPhotosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
    /**
     * The filter to search for the QcPhotos to update in case it exists.
     */
    where: QcPhotosWhereUniqueInput
    /**
     * In case the QcPhotos found by the `where` argument doesn't exist, create a new QcPhotos with this data.
     */
    create: XOR<QcPhotosCreateInput, QcPhotosUncheckedCreateInput>
    /**
     * In case the QcPhotos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QcPhotosUpdateInput, QcPhotosUncheckedUpdateInput>
  }

  /**
   * QcPhotos delete
   */
  export type QcPhotosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
    /**
     * Filter which QcPhotos to delete.
     */
    where: QcPhotosWhereUniqueInput
  }

  /**
   * QcPhotos deleteMany
   */
  export type QcPhotosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QcPhotos to delete
     */
    where?: QcPhotosWhereInput
    /**
     * Limit how many QcPhotos to delete.
     */
    limit?: number
  }

  /**
   * QcPhotos without action
   */
  export type QcPhotosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcPhotos
     */
    select?: QcPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcPhotos
     */
    omit?: QcPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcPhotosInclude<ExtArgs> | null
  }


  /**
   * Model SecurityPhotos
   */

  export type AggregateSecurityPhotos = {
    _count: SecurityPhotosCountAggregateOutputType | null
    _avg: SecurityPhotosAvgAggregateOutputType | null
    _sum: SecurityPhotosSumAggregateOutputType | null
    _min: SecurityPhotosMinAggregateOutputType | null
    _max: SecurityPhotosMaxAggregateOutputType | null
  }

  export type SecurityPhotosAvgAggregateOutputType = {
    id: number | null
    arrivalId: number | null
  }

  export type SecurityPhotosSumAggregateOutputType = {
    id: number | null
    arrivalId: number | null
  }

  export type SecurityPhotosMinAggregateOutputType = {
    id: number | null
    arrivalId: number | null
    photo: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SecurityPhotosMaxAggregateOutputType = {
    id: number | null
    arrivalId: number | null
    photo: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SecurityPhotosCountAggregateOutputType = {
    id: number
    arrivalId: number
    photo: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SecurityPhotosAvgAggregateInputType = {
    id?: true
    arrivalId?: true
  }

  export type SecurityPhotosSumAggregateInputType = {
    id?: true
    arrivalId?: true
  }

  export type SecurityPhotosMinAggregateInputType = {
    id?: true
    arrivalId?: true
    photo?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SecurityPhotosMaxAggregateInputType = {
    id?: true
    arrivalId?: true
    photo?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SecurityPhotosCountAggregateInputType = {
    id?: true
    arrivalId?: true
    photo?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SecurityPhotosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityPhotos to aggregate.
     */
    where?: SecurityPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityPhotos to fetch.
     */
    orderBy?: SecurityPhotosOrderByWithRelationInput | SecurityPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityPhotos
    **/
    _count?: true | SecurityPhotosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecurityPhotosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecurityPhotosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityPhotosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityPhotosMaxAggregateInputType
  }

  export type GetSecurityPhotosAggregateType<T extends SecurityPhotosAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityPhotos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityPhotos[P]>
      : GetScalarType<T[P], AggregateSecurityPhotos[P]>
  }




  export type SecurityPhotosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityPhotosWhereInput
    orderBy?: SecurityPhotosOrderByWithAggregationInput | SecurityPhotosOrderByWithAggregationInput[]
    by: SecurityPhotosScalarFieldEnum[] | SecurityPhotosScalarFieldEnum
    having?: SecurityPhotosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityPhotosCountAggregateInputType | true
    _avg?: SecurityPhotosAvgAggregateInputType
    _sum?: SecurityPhotosSumAggregateInputType
    _min?: SecurityPhotosMinAggregateInputType
    _max?: SecurityPhotosMaxAggregateInputType
  }

  export type SecurityPhotosGroupByOutputType = {
    id: number
    arrivalId: number
    photo: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: SecurityPhotosCountAggregateOutputType | null
    _avg: SecurityPhotosAvgAggregateOutputType | null
    _sum: SecurityPhotosSumAggregateOutputType | null
    _min: SecurityPhotosMinAggregateOutputType | null
    _max: SecurityPhotosMaxAggregateOutputType | null
  }

  type GetSecurityPhotosGroupByPayload<T extends SecurityPhotosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityPhotosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityPhotosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityPhotosGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityPhotosGroupByOutputType[P]>
        }
      >
    >


  export type SecurityPhotosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arrivalId?: boolean
    photo?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    arrival?: boolean | ArrivalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityPhotos"]>



  export type SecurityPhotosSelectScalar = {
    id?: boolean
    arrivalId?: boolean
    photo?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type SecurityPhotosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "arrivalId" | "photo" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["securityPhotos"]>
  export type SecurityPhotosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrival?: boolean | ArrivalsDefaultArgs<ExtArgs>
  }

  export type $SecurityPhotosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityPhotos"
    objects: {
      arrival: Prisma.$ArrivalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      arrivalId: number
      photo: string
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["securityPhotos"]>
    composites: {}
  }

  type SecurityPhotosGetPayload<S extends boolean | null | undefined | SecurityPhotosDefaultArgs> = $Result.GetResult<Prisma.$SecurityPhotosPayload, S>

  type SecurityPhotosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityPhotosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityPhotosCountAggregateInputType | true
    }

  export interface SecurityPhotosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityPhotos'], meta: { name: 'SecurityPhotos' } }
    /**
     * Find zero or one SecurityPhotos that matches the filter.
     * @param {SecurityPhotosFindUniqueArgs} args - Arguments to find a SecurityPhotos
     * @example
     * // Get one SecurityPhotos
     * const securityPhotos = await prisma.securityPhotos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityPhotosFindUniqueArgs>(args: SelectSubset<T, SecurityPhotosFindUniqueArgs<ExtArgs>>): Prisma__SecurityPhotosClient<$Result.GetResult<Prisma.$SecurityPhotosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityPhotos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityPhotosFindUniqueOrThrowArgs} args - Arguments to find a SecurityPhotos
     * @example
     * // Get one SecurityPhotos
     * const securityPhotos = await prisma.securityPhotos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityPhotosFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityPhotosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityPhotosClient<$Result.GetResult<Prisma.$SecurityPhotosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityPhotosFindFirstArgs} args - Arguments to find a SecurityPhotos
     * @example
     * // Get one SecurityPhotos
     * const securityPhotos = await prisma.securityPhotos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityPhotosFindFirstArgs>(args?: SelectSubset<T, SecurityPhotosFindFirstArgs<ExtArgs>>): Prisma__SecurityPhotosClient<$Result.GetResult<Prisma.$SecurityPhotosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityPhotos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityPhotosFindFirstOrThrowArgs} args - Arguments to find a SecurityPhotos
     * @example
     * // Get one SecurityPhotos
     * const securityPhotos = await prisma.securityPhotos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityPhotosFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityPhotosFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityPhotosClient<$Result.GetResult<Prisma.$SecurityPhotosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityPhotosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityPhotos
     * const securityPhotos = await prisma.securityPhotos.findMany()
     * 
     * // Get first 10 SecurityPhotos
     * const securityPhotos = await prisma.securityPhotos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityPhotosWithIdOnly = await prisma.securityPhotos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityPhotosFindManyArgs>(args?: SelectSubset<T, SecurityPhotosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityPhotosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityPhotos.
     * @param {SecurityPhotosCreateArgs} args - Arguments to create a SecurityPhotos.
     * @example
     * // Create one SecurityPhotos
     * const SecurityPhotos = await prisma.securityPhotos.create({
     *   data: {
     *     // ... data to create a SecurityPhotos
     *   }
     * })
     * 
     */
    create<T extends SecurityPhotosCreateArgs>(args: SelectSubset<T, SecurityPhotosCreateArgs<ExtArgs>>): Prisma__SecurityPhotosClient<$Result.GetResult<Prisma.$SecurityPhotosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityPhotos.
     * @param {SecurityPhotosCreateManyArgs} args - Arguments to create many SecurityPhotos.
     * @example
     * // Create many SecurityPhotos
     * const securityPhotos = await prisma.securityPhotos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityPhotosCreateManyArgs>(args?: SelectSubset<T, SecurityPhotosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SecurityPhotos.
     * @param {SecurityPhotosDeleteArgs} args - Arguments to delete one SecurityPhotos.
     * @example
     * // Delete one SecurityPhotos
     * const SecurityPhotos = await prisma.securityPhotos.delete({
     *   where: {
     *     // ... filter to delete one SecurityPhotos
     *   }
     * })
     * 
     */
    delete<T extends SecurityPhotosDeleteArgs>(args: SelectSubset<T, SecurityPhotosDeleteArgs<ExtArgs>>): Prisma__SecurityPhotosClient<$Result.GetResult<Prisma.$SecurityPhotosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityPhotos.
     * @param {SecurityPhotosUpdateArgs} args - Arguments to update one SecurityPhotos.
     * @example
     * // Update one SecurityPhotos
     * const securityPhotos = await prisma.securityPhotos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityPhotosUpdateArgs>(args: SelectSubset<T, SecurityPhotosUpdateArgs<ExtArgs>>): Prisma__SecurityPhotosClient<$Result.GetResult<Prisma.$SecurityPhotosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityPhotos.
     * @param {SecurityPhotosDeleteManyArgs} args - Arguments to filter SecurityPhotos to delete.
     * @example
     * // Delete a few SecurityPhotos
     * const { count } = await prisma.securityPhotos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityPhotosDeleteManyArgs>(args?: SelectSubset<T, SecurityPhotosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityPhotosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityPhotos
     * const securityPhotos = await prisma.securityPhotos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityPhotosUpdateManyArgs>(args: SelectSubset<T, SecurityPhotosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityPhotos.
     * @param {SecurityPhotosUpsertArgs} args - Arguments to update or create a SecurityPhotos.
     * @example
     * // Update or create a SecurityPhotos
     * const securityPhotos = await prisma.securityPhotos.upsert({
     *   create: {
     *     // ... data to create a SecurityPhotos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityPhotos we want to update
     *   }
     * })
     */
    upsert<T extends SecurityPhotosUpsertArgs>(args: SelectSubset<T, SecurityPhotosUpsertArgs<ExtArgs>>): Prisma__SecurityPhotosClient<$Result.GetResult<Prisma.$SecurityPhotosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityPhotosCountArgs} args - Arguments to filter SecurityPhotos to count.
     * @example
     * // Count the number of SecurityPhotos
     * const count = await prisma.securityPhotos.count({
     *   where: {
     *     // ... the filter for the SecurityPhotos we want to count
     *   }
     * })
    **/
    count<T extends SecurityPhotosCountArgs>(
      args?: Subset<T, SecurityPhotosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityPhotosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityPhotosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityPhotosAggregateArgs>(args: Subset<T, SecurityPhotosAggregateArgs>): Prisma.PrismaPromise<GetSecurityPhotosAggregateType<T>>

    /**
     * Group by SecurityPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityPhotosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityPhotosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityPhotosGroupByArgs['orderBy'] }
        : { orderBy?: SecurityPhotosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityPhotosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityPhotosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityPhotos model
   */
  readonly fields: SecurityPhotosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityPhotos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityPhotosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    arrival<T extends ArrivalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalsDefaultArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityPhotos model
   */
  interface SecurityPhotosFieldRefs {
    readonly id: FieldRef<"SecurityPhotos", 'Int'>
    readonly arrivalId: FieldRef<"SecurityPhotos", 'Int'>
    readonly photo: FieldRef<"SecurityPhotos", 'String'>
    readonly createdAt: FieldRef<"SecurityPhotos", 'DateTime'>
    readonly createdBy: FieldRef<"SecurityPhotos", 'String'>
    readonly updatedAt: FieldRef<"SecurityPhotos", 'DateTime'>
    readonly updatedBy: FieldRef<"SecurityPhotos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SecurityPhotos findUnique
   */
  export type SecurityPhotosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
    /**
     * Filter, which SecurityPhotos to fetch.
     */
    where: SecurityPhotosWhereUniqueInput
  }

  /**
   * SecurityPhotos findUniqueOrThrow
   */
  export type SecurityPhotosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
    /**
     * Filter, which SecurityPhotos to fetch.
     */
    where: SecurityPhotosWhereUniqueInput
  }

  /**
   * SecurityPhotos findFirst
   */
  export type SecurityPhotosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
    /**
     * Filter, which SecurityPhotos to fetch.
     */
    where?: SecurityPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityPhotos to fetch.
     */
    orderBy?: SecurityPhotosOrderByWithRelationInput | SecurityPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityPhotos.
     */
    cursor?: SecurityPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityPhotos.
     */
    distinct?: SecurityPhotosScalarFieldEnum | SecurityPhotosScalarFieldEnum[]
  }

  /**
   * SecurityPhotos findFirstOrThrow
   */
  export type SecurityPhotosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
    /**
     * Filter, which SecurityPhotos to fetch.
     */
    where?: SecurityPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityPhotos to fetch.
     */
    orderBy?: SecurityPhotosOrderByWithRelationInput | SecurityPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityPhotos.
     */
    cursor?: SecurityPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityPhotos.
     */
    distinct?: SecurityPhotosScalarFieldEnum | SecurityPhotosScalarFieldEnum[]
  }

  /**
   * SecurityPhotos findMany
   */
  export type SecurityPhotosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
    /**
     * Filter, which SecurityPhotos to fetch.
     */
    where?: SecurityPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityPhotos to fetch.
     */
    orderBy?: SecurityPhotosOrderByWithRelationInput | SecurityPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityPhotos.
     */
    cursor?: SecurityPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityPhotos.
     */
    skip?: number
    distinct?: SecurityPhotosScalarFieldEnum | SecurityPhotosScalarFieldEnum[]
  }

  /**
   * SecurityPhotos create
   */
  export type SecurityPhotosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityPhotos.
     */
    data: XOR<SecurityPhotosCreateInput, SecurityPhotosUncheckedCreateInput>
  }

  /**
   * SecurityPhotos createMany
   */
  export type SecurityPhotosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityPhotos.
     */
    data: SecurityPhotosCreateManyInput | SecurityPhotosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityPhotos update
   */
  export type SecurityPhotosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityPhotos.
     */
    data: XOR<SecurityPhotosUpdateInput, SecurityPhotosUncheckedUpdateInput>
    /**
     * Choose, which SecurityPhotos to update.
     */
    where: SecurityPhotosWhereUniqueInput
  }

  /**
   * SecurityPhotos updateMany
   */
  export type SecurityPhotosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityPhotos.
     */
    data: XOR<SecurityPhotosUpdateManyMutationInput, SecurityPhotosUncheckedUpdateManyInput>
    /**
     * Filter which SecurityPhotos to update
     */
    where?: SecurityPhotosWhereInput
    /**
     * Limit how many SecurityPhotos to update.
     */
    limit?: number
  }

  /**
   * SecurityPhotos upsert
   */
  export type SecurityPhotosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityPhotos to update in case it exists.
     */
    where: SecurityPhotosWhereUniqueInput
    /**
     * In case the SecurityPhotos found by the `where` argument doesn't exist, create a new SecurityPhotos with this data.
     */
    create: XOR<SecurityPhotosCreateInput, SecurityPhotosUncheckedCreateInput>
    /**
     * In case the SecurityPhotos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityPhotosUpdateInput, SecurityPhotosUncheckedUpdateInput>
  }

  /**
   * SecurityPhotos delete
   */
  export type SecurityPhotosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
    /**
     * Filter which SecurityPhotos to delete.
     */
    where: SecurityPhotosWhereUniqueInput
  }

  /**
   * SecurityPhotos deleteMany
   */
  export type SecurityPhotosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityPhotos to delete
     */
    where?: SecurityPhotosWhereInput
    /**
     * Limit how many SecurityPhotos to delete.
     */
    limit?: number
  }

  /**
   * SecurityPhotos without action
   */
  export type SecurityPhotosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityPhotos
     */
    select?: SecurityPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityPhotos
     */
    omit?: SecurityPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityPhotosInclude<ExtArgs> | null
  }


  /**
   * Model WeighingsPhotos
   */

  export type AggregateWeighingsPhotos = {
    _count: WeighingsPhotosCountAggregateOutputType | null
    _avg: WeighingsPhotosAvgAggregateOutputType | null
    _sum: WeighingsPhotosSumAggregateOutputType | null
    _min: WeighingsPhotosMinAggregateOutputType | null
    _max: WeighingsPhotosMaxAggregateOutputType | null
  }

  export type WeighingsPhotosAvgAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
  }

  export type WeighingsPhotosSumAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
  }

  export type WeighingsPhotosMinAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    photo: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type WeighingsPhotosMaxAggregateOutputType = {
    id: number | null
    arrivalItemId: number | null
    photo: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type WeighingsPhotosCountAggregateOutputType = {
    id: number
    arrivalItemId: number
    photo: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type WeighingsPhotosAvgAggregateInputType = {
    id?: true
    arrivalItemId?: true
  }

  export type WeighingsPhotosSumAggregateInputType = {
    id?: true
    arrivalItemId?: true
  }

  export type WeighingsPhotosMinAggregateInputType = {
    id?: true
    arrivalItemId?: true
    photo?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type WeighingsPhotosMaxAggregateInputType = {
    id?: true
    arrivalItemId?: true
    photo?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type WeighingsPhotosCountAggregateInputType = {
    id?: true
    arrivalItemId?: true
    photo?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type WeighingsPhotosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeighingsPhotos to aggregate.
     */
    where?: WeighingsPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeighingsPhotos to fetch.
     */
    orderBy?: WeighingsPhotosOrderByWithRelationInput | WeighingsPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeighingsPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeighingsPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeighingsPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeighingsPhotos
    **/
    _count?: true | WeighingsPhotosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeighingsPhotosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeighingsPhotosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeighingsPhotosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeighingsPhotosMaxAggregateInputType
  }

  export type GetWeighingsPhotosAggregateType<T extends WeighingsPhotosAggregateArgs> = {
        [P in keyof T & keyof AggregateWeighingsPhotos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeighingsPhotos[P]>
      : GetScalarType<T[P], AggregateWeighingsPhotos[P]>
  }




  export type WeighingsPhotosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeighingsPhotosWhereInput
    orderBy?: WeighingsPhotosOrderByWithAggregationInput | WeighingsPhotosOrderByWithAggregationInput[]
    by: WeighingsPhotosScalarFieldEnum[] | WeighingsPhotosScalarFieldEnum
    having?: WeighingsPhotosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeighingsPhotosCountAggregateInputType | true
    _avg?: WeighingsPhotosAvgAggregateInputType
    _sum?: WeighingsPhotosSumAggregateInputType
    _min?: WeighingsPhotosMinAggregateInputType
    _max?: WeighingsPhotosMaxAggregateInputType
  }

  export type WeighingsPhotosGroupByOutputType = {
    id: number
    arrivalItemId: number
    photo: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: WeighingsPhotosCountAggregateOutputType | null
    _avg: WeighingsPhotosAvgAggregateOutputType | null
    _sum: WeighingsPhotosSumAggregateOutputType | null
    _min: WeighingsPhotosMinAggregateOutputType | null
    _max: WeighingsPhotosMaxAggregateOutputType | null
  }

  type GetWeighingsPhotosGroupByPayload<T extends WeighingsPhotosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeighingsPhotosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeighingsPhotosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeighingsPhotosGroupByOutputType[P]>
            : GetScalarType<T[P], WeighingsPhotosGroupByOutputType[P]>
        }
      >
    >


  export type WeighingsPhotosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arrivalItemId?: boolean
    photo?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    arrivalItem?: boolean | ArrivalItemsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weighingsPhotos"]>



  export type WeighingsPhotosSelectScalar = {
    id?: boolean
    arrivalItemId?: boolean
    photo?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type WeighingsPhotosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "arrivalItemId" | "photo" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["weighingsPhotos"]>
  export type WeighingsPhotosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrivalItem?: boolean | ArrivalItemsDefaultArgs<ExtArgs>
  }

  export type $WeighingsPhotosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeighingsPhotos"
    objects: {
      arrivalItem: Prisma.$ArrivalItemsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      arrivalItemId: number
      photo: string
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["weighingsPhotos"]>
    composites: {}
  }

  type WeighingsPhotosGetPayload<S extends boolean | null | undefined | WeighingsPhotosDefaultArgs> = $Result.GetResult<Prisma.$WeighingsPhotosPayload, S>

  type WeighingsPhotosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeighingsPhotosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeighingsPhotosCountAggregateInputType | true
    }

  export interface WeighingsPhotosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeighingsPhotos'], meta: { name: 'WeighingsPhotos' } }
    /**
     * Find zero or one WeighingsPhotos that matches the filter.
     * @param {WeighingsPhotosFindUniqueArgs} args - Arguments to find a WeighingsPhotos
     * @example
     * // Get one WeighingsPhotos
     * const weighingsPhotos = await prisma.weighingsPhotos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeighingsPhotosFindUniqueArgs>(args: SelectSubset<T, WeighingsPhotosFindUniqueArgs<ExtArgs>>): Prisma__WeighingsPhotosClient<$Result.GetResult<Prisma.$WeighingsPhotosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeighingsPhotos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeighingsPhotosFindUniqueOrThrowArgs} args - Arguments to find a WeighingsPhotos
     * @example
     * // Get one WeighingsPhotos
     * const weighingsPhotos = await prisma.weighingsPhotos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeighingsPhotosFindUniqueOrThrowArgs>(args: SelectSubset<T, WeighingsPhotosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeighingsPhotosClient<$Result.GetResult<Prisma.$WeighingsPhotosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeighingsPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsPhotosFindFirstArgs} args - Arguments to find a WeighingsPhotos
     * @example
     * // Get one WeighingsPhotos
     * const weighingsPhotos = await prisma.weighingsPhotos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeighingsPhotosFindFirstArgs>(args?: SelectSubset<T, WeighingsPhotosFindFirstArgs<ExtArgs>>): Prisma__WeighingsPhotosClient<$Result.GetResult<Prisma.$WeighingsPhotosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeighingsPhotos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsPhotosFindFirstOrThrowArgs} args - Arguments to find a WeighingsPhotos
     * @example
     * // Get one WeighingsPhotos
     * const weighingsPhotos = await prisma.weighingsPhotos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeighingsPhotosFindFirstOrThrowArgs>(args?: SelectSubset<T, WeighingsPhotosFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeighingsPhotosClient<$Result.GetResult<Prisma.$WeighingsPhotosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeighingsPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsPhotosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeighingsPhotos
     * const weighingsPhotos = await prisma.weighingsPhotos.findMany()
     * 
     * // Get first 10 WeighingsPhotos
     * const weighingsPhotos = await prisma.weighingsPhotos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weighingsPhotosWithIdOnly = await prisma.weighingsPhotos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeighingsPhotosFindManyArgs>(args?: SelectSubset<T, WeighingsPhotosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeighingsPhotosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeighingsPhotos.
     * @param {WeighingsPhotosCreateArgs} args - Arguments to create a WeighingsPhotos.
     * @example
     * // Create one WeighingsPhotos
     * const WeighingsPhotos = await prisma.weighingsPhotos.create({
     *   data: {
     *     // ... data to create a WeighingsPhotos
     *   }
     * })
     * 
     */
    create<T extends WeighingsPhotosCreateArgs>(args: SelectSubset<T, WeighingsPhotosCreateArgs<ExtArgs>>): Prisma__WeighingsPhotosClient<$Result.GetResult<Prisma.$WeighingsPhotosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeighingsPhotos.
     * @param {WeighingsPhotosCreateManyArgs} args - Arguments to create many WeighingsPhotos.
     * @example
     * // Create many WeighingsPhotos
     * const weighingsPhotos = await prisma.weighingsPhotos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeighingsPhotosCreateManyArgs>(args?: SelectSubset<T, WeighingsPhotosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WeighingsPhotos.
     * @param {WeighingsPhotosDeleteArgs} args - Arguments to delete one WeighingsPhotos.
     * @example
     * // Delete one WeighingsPhotos
     * const WeighingsPhotos = await prisma.weighingsPhotos.delete({
     *   where: {
     *     // ... filter to delete one WeighingsPhotos
     *   }
     * })
     * 
     */
    delete<T extends WeighingsPhotosDeleteArgs>(args: SelectSubset<T, WeighingsPhotosDeleteArgs<ExtArgs>>): Prisma__WeighingsPhotosClient<$Result.GetResult<Prisma.$WeighingsPhotosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeighingsPhotos.
     * @param {WeighingsPhotosUpdateArgs} args - Arguments to update one WeighingsPhotos.
     * @example
     * // Update one WeighingsPhotos
     * const weighingsPhotos = await prisma.weighingsPhotos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeighingsPhotosUpdateArgs>(args: SelectSubset<T, WeighingsPhotosUpdateArgs<ExtArgs>>): Prisma__WeighingsPhotosClient<$Result.GetResult<Prisma.$WeighingsPhotosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeighingsPhotos.
     * @param {WeighingsPhotosDeleteManyArgs} args - Arguments to filter WeighingsPhotos to delete.
     * @example
     * // Delete a few WeighingsPhotos
     * const { count } = await prisma.weighingsPhotos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeighingsPhotosDeleteManyArgs>(args?: SelectSubset<T, WeighingsPhotosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeighingsPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsPhotosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeighingsPhotos
     * const weighingsPhotos = await prisma.weighingsPhotos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeighingsPhotosUpdateManyArgs>(args: SelectSubset<T, WeighingsPhotosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeighingsPhotos.
     * @param {WeighingsPhotosUpsertArgs} args - Arguments to update or create a WeighingsPhotos.
     * @example
     * // Update or create a WeighingsPhotos
     * const weighingsPhotos = await prisma.weighingsPhotos.upsert({
     *   create: {
     *     // ... data to create a WeighingsPhotos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeighingsPhotos we want to update
     *   }
     * })
     */
    upsert<T extends WeighingsPhotosUpsertArgs>(args: SelectSubset<T, WeighingsPhotosUpsertArgs<ExtArgs>>): Prisma__WeighingsPhotosClient<$Result.GetResult<Prisma.$WeighingsPhotosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeighingsPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsPhotosCountArgs} args - Arguments to filter WeighingsPhotos to count.
     * @example
     * // Count the number of WeighingsPhotos
     * const count = await prisma.weighingsPhotos.count({
     *   where: {
     *     // ... the filter for the WeighingsPhotos we want to count
     *   }
     * })
    **/
    count<T extends WeighingsPhotosCountArgs>(
      args?: Subset<T, WeighingsPhotosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeighingsPhotosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeighingsPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsPhotosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeighingsPhotosAggregateArgs>(args: Subset<T, WeighingsPhotosAggregateArgs>): Prisma.PrismaPromise<GetWeighingsPhotosAggregateType<T>>

    /**
     * Group by WeighingsPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeighingsPhotosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeighingsPhotosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeighingsPhotosGroupByArgs['orderBy'] }
        : { orderBy?: WeighingsPhotosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeighingsPhotosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeighingsPhotosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeighingsPhotos model
   */
  readonly fields: WeighingsPhotosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeighingsPhotos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeighingsPhotosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    arrivalItem<T extends ArrivalItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalItemsDefaultArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeighingsPhotos model
   */
  interface WeighingsPhotosFieldRefs {
    readonly id: FieldRef<"WeighingsPhotos", 'Int'>
    readonly arrivalItemId: FieldRef<"WeighingsPhotos", 'Int'>
    readonly photo: FieldRef<"WeighingsPhotos", 'String'>
    readonly createdAt: FieldRef<"WeighingsPhotos", 'DateTime'>
    readonly createdBy: FieldRef<"WeighingsPhotos", 'String'>
    readonly updatedAt: FieldRef<"WeighingsPhotos", 'DateTime'>
    readonly updatedBy: FieldRef<"WeighingsPhotos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WeighingsPhotos findUnique
   */
  export type WeighingsPhotosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
    /**
     * Filter, which WeighingsPhotos to fetch.
     */
    where: WeighingsPhotosWhereUniqueInput
  }

  /**
   * WeighingsPhotos findUniqueOrThrow
   */
  export type WeighingsPhotosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
    /**
     * Filter, which WeighingsPhotos to fetch.
     */
    where: WeighingsPhotosWhereUniqueInput
  }

  /**
   * WeighingsPhotos findFirst
   */
  export type WeighingsPhotosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
    /**
     * Filter, which WeighingsPhotos to fetch.
     */
    where?: WeighingsPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeighingsPhotos to fetch.
     */
    orderBy?: WeighingsPhotosOrderByWithRelationInput | WeighingsPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeighingsPhotos.
     */
    cursor?: WeighingsPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeighingsPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeighingsPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeighingsPhotos.
     */
    distinct?: WeighingsPhotosScalarFieldEnum | WeighingsPhotosScalarFieldEnum[]
  }

  /**
   * WeighingsPhotos findFirstOrThrow
   */
  export type WeighingsPhotosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
    /**
     * Filter, which WeighingsPhotos to fetch.
     */
    where?: WeighingsPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeighingsPhotos to fetch.
     */
    orderBy?: WeighingsPhotosOrderByWithRelationInput | WeighingsPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeighingsPhotos.
     */
    cursor?: WeighingsPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeighingsPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeighingsPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeighingsPhotos.
     */
    distinct?: WeighingsPhotosScalarFieldEnum | WeighingsPhotosScalarFieldEnum[]
  }

  /**
   * WeighingsPhotos findMany
   */
  export type WeighingsPhotosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
    /**
     * Filter, which WeighingsPhotos to fetch.
     */
    where?: WeighingsPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeighingsPhotos to fetch.
     */
    orderBy?: WeighingsPhotosOrderByWithRelationInput | WeighingsPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeighingsPhotos.
     */
    cursor?: WeighingsPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeighingsPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeighingsPhotos.
     */
    skip?: number
    distinct?: WeighingsPhotosScalarFieldEnum | WeighingsPhotosScalarFieldEnum[]
  }

  /**
   * WeighingsPhotos create
   */
  export type WeighingsPhotosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
    /**
     * The data needed to create a WeighingsPhotos.
     */
    data: XOR<WeighingsPhotosCreateInput, WeighingsPhotosUncheckedCreateInput>
  }

  /**
   * WeighingsPhotos createMany
   */
  export type WeighingsPhotosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeighingsPhotos.
     */
    data: WeighingsPhotosCreateManyInput | WeighingsPhotosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeighingsPhotos update
   */
  export type WeighingsPhotosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
    /**
     * The data needed to update a WeighingsPhotos.
     */
    data: XOR<WeighingsPhotosUpdateInput, WeighingsPhotosUncheckedUpdateInput>
    /**
     * Choose, which WeighingsPhotos to update.
     */
    where: WeighingsPhotosWhereUniqueInput
  }

  /**
   * WeighingsPhotos updateMany
   */
  export type WeighingsPhotosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeighingsPhotos.
     */
    data: XOR<WeighingsPhotosUpdateManyMutationInput, WeighingsPhotosUncheckedUpdateManyInput>
    /**
     * Filter which WeighingsPhotos to update
     */
    where?: WeighingsPhotosWhereInput
    /**
     * Limit how many WeighingsPhotos to update.
     */
    limit?: number
  }

  /**
   * WeighingsPhotos upsert
   */
  export type WeighingsPhotosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
    /**
     * The filter to search for the WeighingsPhotos to update in case it exists.
     */
    where: WeighingsPhotosWhereUniqueInput
    /**
     * In case the WeighingsPhotos found by the `where` argument doesn't exist, create a new WeighingsPhotos with this data.
     */
    create: XOR<WeighingsPhotosCreateInput, WeighingsPhotosUncheckedCreateInput>
    /**
     * In case the WeighingsPhotos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeighingsPhotosUpdateInput, WeighingsPhotosUncheckedUpdateInput>
  }

  /**
   * WeighingsPhotos delete
   */
  export type WeighingsPhotosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
    /**
     * Filter which WeighingsPhotos to delete.
     */
    where: WeighingsPhotosWhereUniqueInput
  }

  /**
   * WeighingsPhotos deleteMany
   */
  export type WeighingsPhotosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeighingsPhotos to delete
     */
    where?: WeighingsPhotosWhereInput
    /**
     * Limit how many WeighingsPhotos to delete.
     */
    limit?: number
  }

  /**
   * WeighingsPhotos without action
   */
  export type WeighingsPhotosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeighingsPhotos
     */
    select?: WeighingsPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeighingsPhotos
     */
    omit?: WeighingsPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeighingsPhotosInclude<ExtArgs> | null
  }


  /**
   * Model QcHistories
   */

  export type AggregateQcHistories = {
    _count: QcHistoriesCountAggregateOutputType | null
    _avg: QcHistoriesAvgAggregateOutputType | null
    _sum: QcHistoriesSumAggregateOutputType | null
    _min: QcHistoriesMinAggregateOutputType | null
    _max: QcHistoriesMaxAggregateOutputType | null
  }

  export type QcHistoriesAvgAggregateOutputType = {
    id: number | null
    statusId: number | null
    arrivalId: number | null
    arrivalItemId: number | null
    qcSample: number | null
    qcKotoran: number | null
    totalBerat: number | null
    pengeringan: number | null
  }

  export type QcHistoriesSumAggregateOutputType = {
    id: number | null
    statusId: number | null
    arrivalId: number | null
    arrivalItemId: number | null
    qcSample: number | null
    qcKotoran: number | null
    totalBerat: number | null
    pengeringan: number | null
  }

  export type QcHistoriesMinAggregateOutputType = {
    id: number | null
    userId: string | null
    statusId: number | null
    arrivalId: number | null
    arrivalItemId: number | null
    qcSample: number | null
    qcKotoran: number | null
    totalBerat: number | null
    pengeringan: number | null
    note: string | null
    qcNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QcHistoriesMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    statusId: number | null
    arrivalId: number | null
    arrivalItemId: number | null
    qcSample: number | null
    qcKotoran: number | null
    totalBerat: number | null
    pengeringan: number | null
    note: string | null
    qcNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QcHistoriesCountAggregateOutputType = {
    id: number
    userId: number
    statusId: number
    arrivalId: number
    arrivalItemId: number
    qcSample: number
    qcKotoran: number
    totalBerat: number
    pengeringan: number
    note: number
    qcNote: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QcHistoriesAvgAggregateInputType = {
    id?: true
    statusId?: true
    arrivalId?: true
    arrivalItemId?: true
    qcSample?: true
    qcKotoran?: true
    totalBerat?: true
    pengeringan?: true
  }

  export type QcHistoriesSumAggregateInputType = {
    id?: true
    statusId?: true
    arrivalId?: true
    arrivalItemId?: true
    qcSample?: true
    qcKotoran?: true
    totalBerat?: true
    pengeringan?: true
  }

  export type QcHistoriesMinAggregateInputType = {
    id?: true
    userId?: true
    statusId?: true
    arrivalId?: true
    arrivalItemId?: true
    qcSample?: true
    qcKotoran?: true
    totalBerat?: true
    pengeringan?: true
    note?: true
    qcNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QcHistoriesMaxAggregateInputType = {
    id?: true
    userId?: true
    statusId?: true
    arrivalId?: true
    arrivalItemId?: true
    qcSample?: true
    qcKotoran?: true
    totalBerat?: true
    pengeringan?: true
    note?: true
    qcNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QcHistoriesCountAggregateInputType = {
    id?: true
    userId?: true
    statusId?: true
    arrivalId?: true
    arrivalItemId?: true
    qcSample?: true
    qcKotoran?: true
    totalBerat?: true
    pengeringan?: true
    note?: true
    qcNote?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QcHistoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QcHistories to aggregate.
     */
    where?: QcHistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcHistories to fetch.
     */
    orderBy?: QcHistoriesOrderByWithRelationInput | QcHistoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QcHistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QcHistories
    **/
    _count?: true | QcHistoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QcHistoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QcHistoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QcHistoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QcHistoriesMaxAggregateInputType
  }

  export type GetQcHistoriesAggregateType<T extends QcHistoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateQcHistories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQcHistories[P]>
      : GetScalarType<T[P], AggregateQcHistories[P]>
  }




  export type QcHistoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcHistoriesWhereInput
    orderBy?: QcHistoriesOrderByWithAggregationInput | QcHistoriesOrderByWithAggregationInput[]
    by: QcHistoriesScalarFieldEnum[] | QcHistoriesScalarFieldEnum
    having?: QcHistoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QcHistoriesCountAggregateInputType | true
    _avg?: QcHistoriesAvgAggregateInputType
    _sum?: QcHistoriesSumAggregateInputType
    _min?: QcHistoriesMinAggregateInputType
    _max?: QcHistoriesMaxAggregateInputType
  }

  export type QcHistoriesGroupByOutputType = {
    id: number
    userId: string
    statusId: number
    arrivalId: number | null
    arrivalItemId: number | null
    qcSample: number | null
    qcKotoran: number | null
    totalBerat: number | null
    pengeringan: number | null
    note: string | null
    qcNote: string | null
    createdAt: Date
    updatedAt: Date
    _count: QcHistoriesCountAggregateOutputType | null
    _avg: QcHistoriesAvgAggregateOutputType | null
    _sum: QcHistoriesSumAggregateOutputType | null
    _min: QcHistoriesMinAggregateOutputType | null
    _max: QcHistoriesMaxAggregateOutputType | null
  }

  type GetQcHistoriesGroupByPayload<T extends QcHistoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QcHistoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QcHistoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QcHistoriesGroupByOutputType[P]>
            : GetScalarType<T[P], QcHistoriesGroupByOutputType[P]>
        }
      >
    >


  export type QcHistoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    statusId?: boolean
    arrivalId?: boolean
    arrivalItemId?: boolean
    qcSample?: boolean
    qcKotoran?: boolean
    totalBerat?: boolean
    pengeringan?: boolean
    note?: boolean
    qcNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    status?: boolean | QcStatusDefaultArgs<ExtArgs>
    arrival?: boolean | QcHistories$arrivalArgs<ExtArgs>
    arrivalItem?: boolean | QcHistories$arrivalItemArgs<ExtArgs>
    QcResults?: boolean | QcHistories$QcResultsArgs<ExtArgs>
    _count?: boolean | QcHistoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qcHistories"]>



  export type QcHistoriesSelectScalar = {
    id?: boolean
    userId?: boolean
    statusId?: boolean
    arrivalId?: boolean
    arrivalItemId?: boolean
    qcSample?: boolean
    qcKotoran?: boolean
    totalBerat?: boolean
    pengeringan?: boolean
    note?: boolean
    qcNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QcHistoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "statusId" | "arrivalId" | "arrivalItemId" | "qcSample" | "qcKotoran" | "totalBerat" | "pengeringan" | "note" | "qcNote" | "createdAt" | "updatedAt", ExtArgs["result"]["qcHistories"]>
  export type QcHistoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    status?: boolean | QcStatusDefaultArgs<ExtArgs>
    arrival?: boolean | QcHistories$arrivalArgs<ExtArgs>
    arrivalItem?: boolean | QcHistories$arrivalItemArgs<ExtArgs>
    QcResults?: boolean | QcHistories$QcResultsArgs<ExtArgs>
    _count?: boolean | QcHistoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QcHistoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QcHistories"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      status: Prisma.$QcStatusPayload<ExtArgs>
      arrival: Prisma.$ArrivalsPayload<ExtArgs> | null
      arrivalItem: Prisma.$ArrivalItemsPayload<ExtArgs> | null
      QcResults: Prisma.$QcResultsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      statusId: number
      arrivalId: number | null
      arrivalItemId: number | null
      qcSample: number | null
      qcKotoran: number | null
      totalBerat: number | null
      pengeringan: number | null
      note: string | null
      qcNote: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qcHistories"]>
    composites: {}
  }

  type QcHistoriesGetPayload<S extends boolean | null | undefined | QcHistoriesDefaultArgs> = $Result.GetResult<Prisma.$QcHistoriesPayload, S>

  type QcHistoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QcHistoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QcHistoriesCountAggregateInputType | true
    }

  export interface QcHistoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QcHistories'], meta: { name: 'QcHistories' } }
    /**
     * Find zero or one QcHistories that matches the filter.
     * @param {QcHistoriesFindUniqueArgs} args - Arguments to find a QcHistories
     * @example
     * // Get one QcHistories
     * const qcHistories = await prisma.qcHistories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QcHistoriesFindUniqueArgs>(args: SelectSubset<T, QcHistoriesFindUniqueArgs<ExtArgs>>): Prisma__QcHistoriesClient<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QcHistories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QcHistoriesFindUniqueOrThrowArgs} args - Arguments to find a QcHistories
     * @example
     * // Get one QcHistories
     * const qcHistories = await prisma.qcHistories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QcHistoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, QcHistoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QcHistoriesClient<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcHistoriesFindFirstArgs} args - Arguments to find a QcHistories
     * @example
     * // Get one QcHistories
     * const qcHistories = await prisma.qcHistories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QcHistoriesFindFirstArgs>(args?: SelectSubset<T, QcHistoriesFindFirstArgs<ExtArgs>>): Prisma__QcHistoriesClient<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcHistories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcHistoriesFindFirstOrThrowArgs} args - Arguments to find a QcHistories
     * @example
     * // Get one QcHistories
     * const qcHistories = await prisma.qcHistories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QcHistoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, QcHistoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__QcHistoriesClient<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QcHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcHistoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QcHistories
     * const qcHistories = await prisma.qcHistories.findMany()
     * 
     * // Get first 10 QcHistories
     * const qcHistories = await prisma.qcHistories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qcHistoriesWithIdOnly = await prisma.qcHistories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QcHistoriesFindManyArgs>(args?: SelectSubset<T, QcHistoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QcHistories.
     * @param {QcHistoriesCreateArgs} args - Arguments to create a QcHistories.
     * @example
     * // Create one QcHistories
     * const QcHistories = await prisma.qcHistories.create({
     *   data: {
     *     // ... data to create a QcHistories
     *   }
     * })
     * 
     */
    create<T extends QcHistoriesCreateArgs>(args: SelectSubset<T, QcHistoriesCreateArgs<ExtArgs>>): Prisma__QcHistoriesClient<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QcHistories.
     * @param {QcHistoriesCreateManyArgs} args - Arguments to create many QcHistories.
     * @example
     * // Create many QcHistories
     * const qcHistories = await prisma.qcHistories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QcHistoriesCreateManyArgs>(args?: SelectSubset<T, QcHistoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QcHistories.
     * @param {QcHistoriesDeleteArgs} args - Arguments to delete one QcHistories.
     * @example
     * // Delete one QcHistories
     * const QcHistories = await prisma.qcHistories.delete({
     *   where: {
     *     // ... filter to delete one QcHistories
     *   }
     * })
     * 
     */
    delete<T extends QcHistoriesDeleteArgs>(args: SelectSubset<T, QcHistoriesDeleteArgs<ExtArgs>>): Prisma__QcHistoriesClient<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QcHistories.
     * @param {QcHistoriesUpdateArgs} args - Arguments to update one QcHistories.
     * @example
     * // Update one QcHistories
     * const qcHistories = await prisma.qcHistories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QcHistoriesUpdateArgs>(args: SelectSubset<T, QcHistoriesUpdateArgs<ExtArgs>>): Prisma__QcHistoriesClient<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QcHistories.
     * @param {QcHistoriesDeleteManyArgs} args - Arguments to filter QcHistories to delete.
     * @example
     * // Delete a few QcHistories
     * const { count } = await prisma.qcHistories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QcHistoriesDeleteManyArgs>(args?: SelectSubset<T, QcHistoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QcHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcHistoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QcHistories
     * const qcHistories = await prisma.qcHistories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QcHistoriesUpdateManyArgs>(args: SelectSubset<T, QcHistoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QcHistories.
     * @param {QcHistoriesUpsertArgs} args - Arguments to update or create a QcHistories.
     * @example
     * // Update or create a QcHistories
     * const qcHistories = await prisma.qcHistories.upsert({
     *   create: {
     *     // ... data to create a QcHistories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QcHistories we want to update
     *   }
     * })
     */
    upsert<T extends QcHistoriesUpsertArgs>(args: SelectSubset<T, QcHistoriesUpsertArgs<ExtArgs>>): Prisma__QcHistoriesClient<$Result.GetResult<Prisma.$QcHistoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QcHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcHistoriesCountArgs} args - Arguments to filter QcHistories to count.
     * @example
     * // Count the number of QcHistories
     * const count = await prisma.qcHistories.count({
     *   where: {
     *     // ... the filter for the QcHistories we want to count
     *   }
     * })
    **/
    count<T extends QcHistoriesCountArgs>(
      args?: Subset<T, QcHistoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QcHistoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QcHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcHistoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QcHistoriesAggregateArgs>(args: Subset<T, QcHistoriesAggregateArgs>): Prisma.PrismaPromise<GetQcHistoriesAggregateType<T>>

    /**
     * Group by QcHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcHistoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QcHistoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QcHistoriesGroupByArgs['orderBy'] }
        : { orderBy?: QcHistoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QcHistoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQcHistoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QcHistories model
   */
  readonly fields: QcHistoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QcHistories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QcHistoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    status<T extends QcStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QcStatusDefaultArgs<ExtArgs>>): Prisma__QcStatusClient<$Result.GetResult<Prisma.$QcStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    arrival<T extends QcHistories$arrivalArgs<ExtArgs> = {}>(args?: Subset<T, QcHistories$arrivalArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    arrivalItem<T extends QcHistories$arrivalItemArgs<ExtArgs> = {}>(args?: Subset<T, QcHistories$arrivalItemArgs<ExtArgs>>): Prisma__ArrivalItemsClient<$Result.GetResult<Prisma.$ArrivalItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    QcResults<T extends QcHistories$QcResultsArgs<ExtArgs> = {}>(args?: Subset<T, QcHistories$QcResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcResultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QcHistories model
   */
  interface QcHistoriesFieldRefs {
    readonly id: FieldRef<"QcHistories", 'Int'>
    readonly userId: FieldRef<"QcHistories", 'String'>
    readonly statusId: FieldRef<"QcHistories", 'Int'>
    readonly arrivalId: FieldRef<"QcHistories", 'Int'>
    readonly arrivalItemId: FieldRef<"QcHistories", 'Int'>
    readonly qcSample: FieldRef<"QcHistories", 'Float'>
    readonly qcKotoran: FieldRef<"QcHistories", 'Float'>
    readonly totalBerat: FieldRef<"QcHistories", 'Float'>
    readonly pengeringan: FieldRef<"QcHistories", 'Float'>
    readonly note: FieldRef<"QcHistories", 'String'>
    readonly qcNote: FieldRef<"QcHistories", 'String'>
    readonly createdAt: FieldRef<"QcHistories", 'DateTime'>
    readonly updatedAt: FieldRef<"QcHistories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QcHistories findUnique
   */
  export type QcHistoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    /**
     * Filter, which QcHistories to fetch.
     */
    where: QcHistoriesWhereUniqueInput
  }

  /**
   * QcHistories findUniqueOrThrow
   */
  export type QcHistoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    /**
     * Filter, which QcHistories to fetch.
     */
    where: QcHistoriesWhereUniqueInput
  }

  /**
   * QcHistories findFirst
   */
  export type QcHistoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    /**
     * Filter, which QcHistories to fetch.
     */
    where?: QcHistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcHistories to fetch.
     */
    orderBy?: QcHistoriesOrderByWithRelationInput | QcHistoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QcHistories.
     */
    cursor?: QcHistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QcHistories.
     */
    distinct?: QcHistoriesScalarFieldEnum | QcHistoriesScalarFieldEnum[]
  }

  /**
   * QcHistories findFirstOrThrow
   */
  export type QcHistoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    /**
     * Filter, which QcHistories to fetch.
     */
    where?: QcHistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcHistories to fetch.
     */
    orderBy?: QcHistoriesOrderByWithRelationInput | QcHistoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QcHistories.
     */
    cursor?: QcHistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QcHistories.
     */
    distinct?: QcHistoriesScalarFieldEnum | QcHistoriesScalarFieldEnum[]
  }

  /**
   * QcHistories findMany
   */
  export type QcHistoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    /**
     * Filter, which QcHistories to fetch.
     */
    where?: QcHistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcHistories to fetch.
     */
    orderBy?: QcHistoriesOrderByWithRelationInput | QcHistoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QcHistories.
     */
    cursor?: QcHistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcHistories.
     */
    skip?: number
    distinct?: QcHistoriesScalarFieldEnum | QcHistoriesScalarFieldEnum[]
  }

  /**
   * QcHistories create
   */
  export type QcHistoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a QcHistories.
     */
    data: XOR<QcHistoriesCreateInput, QcHistoriesUncheckedCreateInput>
  }

  /**
   * QcHistories createMany
   */
  export type QcHistoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QcHistories.
     */
    data: QcHistoriesCreateManyInput | QcHistoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QcHistories update
   */
  export type QcHistoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a QcHistories.
     */
    data: XOR<QcHistoriesUpdateInput, QcHistoriesUncheckedUpdateInput>
    /**
     * Choose, which QcHistories to update.
     */
    where: QcHistoriesWhereUniqueInput
  }

  /**
   * QcHistories updateMany
   */
  export type QcHistoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QcHistories.
     */
    data: XOR<QcHistoriesUpdateManyMutationInput, QcHistoriesUncheckedUpdateManyInput>
    /**
     * Filter which QcHistories to update
     */
    where?: QcHistoriesWhereInput
    /**
     * Limit how many QcHistories to update.
     */
    limit?: number
  }

  /**
   * QcHistories upsert
   */
  export type QcHistoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the QcHistories to update in case it exists.
     */
    where: QcHistoriesWhereUniqueInput
    /**
     * In case the QcHistories found by the `where` argument doesn't exist, create a new QcHistories with this data.
     */
    create: XOR<QcHistoriesCreateInput, QcHistoriesUncheckedCreateInput>
    /**
     * In case the QcHistories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QcHistoriesUpdateInput, QcHistoriesUncheckedUpdateInput>
  }

  /**
   * QcHistories delete
   */
  export type QcHistoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
    /**
     * Filter which QcHistories to delete.
     */
    where: QcHistoriesWhereUniqueInput
  }

  /**
   * QcHistories deleteMany
   */
  export type QcHistoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QcHistories to delete
     */
    where?: QcHistoriesWhereInput
    /**
     * Limit how many QcHistories to delete.
     */
    limit?: number
  }

  /**
   * QcHistories.arrival
   */
  export type QcHistories$arrivalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Arrivals
     */
    select?: ArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Arrivals
     */
    omit?: ArrivalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalsInclude<ExtArgs> | null
    where?: ArrivalsWhereInput
  }

  /**
   * QcHistories.arrivalItem
   */
  export type QcHistories$arrivalItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalItems
     */
    select?: ArrivalItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalItems
     */
    omit?: ArrivalItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalItemsInclude<ExtArgs> | null
    where?: ArrivalItemsWhereInput
  }

  /**
   * QcHistories.QcResults
   */
  export type QcHistories$QcResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResults
     */
    select?: QcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResults
     */
    omit?: QcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultsInclude<ExtArgs> | null
    where?: QcResultsWhereInput
    orderBy?: QcResultsOrderByWithRelationInput | QcResultsOrderByWithRelationInput[]
    cursor?: QcResultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcResultsScalarFieldEnum | QcResultsScalarFieldEnum[]
  }

  /**
   * QcHistories without action
   */
  export type QcHistoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcHistories
     */
    select?: QcHistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcHistories
     */
    omit?: QcHistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcHistoriesInclude<ExtArgs> | null
  }


  /**
   * Model ArrivalStatuses
   */

  export type AggregateArrivalStatuses = {
    _count: ArrivalStatusesCountAggregateOutputType | null
    _avg: ArrivalStatusesAvgAggregateOutputType | null
    _sum: ArrivalStatusesSumAggregateOutputType | null
    _min: ArrivalStatusesMinAggregateOutputType | null
    _max: ArrivalStatusesMaxAggregateOutputType | null
  }

  export type ArrivalStatusesAvgAggregateOutputType = {
    id: number | null
    arrivalId: number | null
  }

  export type ArrivalStatusesSumAggregateOutputType = {
    id: number | null
    arrivalId: number | null
  }

  export type ArrivalStatusesMinAggregateOutputType = {
    id: number | null
    arrivalId: number | null
    status: string | null
    statusQc: string | null
    statusWeighing: string | null
    statusApproval: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ArrivalStatusesMaxAggregateOutputType = {
    id: number | null
    arrivalId: number | null
    status: string | null
    statusQc: string | null
    statusWeighing: string | null
    statusApproval: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ArrivalStatusesCountAggregateOutputType = {
    id: number
    arrivalId: number
    status: number
    statusQc: number
    statusWeighing: number
    statusApproval: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ArrivalStatusesAvgAggregateInputType = {
    id?: true
    arrivalId?: true
  }

  export type ArrivalStatusesSumAggregateInputType = {
    id?: true
    arrivalId?: true
  }

  export type ArrivalStatusesMinAggregateInputType = {
    id?: true
    arrivalId?: true
    status?: true
    statusQc?: true
    statusWeighing?: true
    statusApproval?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ArrivalStatusesMaxAggregateInputType = {
    id?: true
    arrivalId?: true
    status?: true
    statusQc?: true
    statusWeighing?: true
    statusApproval?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ArrivalStatusesCountAggregateInputType = {
    id?: true
    arrivalId?: true
    status?: true
    statusQc?: true
    statusWeighing?: true
    statusApproval?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ArrivalStatusesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArrivalStatuses to aggregate.
     */
    where?: ArrivalStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArrivalStatuses to fetch.
     */
    orderBy?: ArrivalStatusesOrderByWithRelationInput | ArrivalStatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArrivalStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArrivalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArrivalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArrivalStatuses
    **/
    _count?: true | ArrivalStatusesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArrivalStatusesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArrivalStatusesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArrivalStatusesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArrivalStatusesMaxAggregateInputType
  }

  export type GetArrivalStatusesAggregateType<T extends ArrivalStatusesAggregateArgs> = {
        [P in keyof T & keyof AggregateArrivalStatuses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArrivalStatuses[P]>
      : GetScalarType<T[P], AggregateArrivalStatuses[P]>
  }




  export type ArrivalStatusesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArrivalStatusesWhereInput
    orderBy?: ArrivalStatusesOrderByWithAggregationInput | ArrivalStatusesOrderByWithAggregationInput[]
    by: ArrivalStatusesScalarFieldEnum[] | ArrivalStatusesScalarFieldEnum
    having?: ArrivalStatusesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArrivalStatusesCountAggregateInputType | true
    _avg?: ArrivalStatusesAvgAggregateInputType
    _sum?: ArrivalStatusesSumAggregateInputType
    _min?: ArrivalStatusesMinAggregateInputType
    _max?: ArrivalStatusesMaxAggregateInputType
  }

  export type ArrivalStatusesGroupByOutputType = {
    id: number
    arrivalId: number
    status: string
    statusQc: string | null
    statusWeighing: string | null
    statusApproval: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: ArrivalStatusesCountAggregateOutputType | null
    _avg: ArrivalStatusesAvgAggregateOutputType | null
    _sum: ArrivalStatusesSumAggregateOutputType | null
    _min: ArrivalStatusesMinAggregateOutputType | null
    _max: ArrivalStatusesMaxAggregateOutputType | null
  }

  type GetArrivalStatusesGroupByPayload<T extends ArrivalStatusesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArrivalStatusesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArrivalStatusesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArrivalStatusesGroupByOutputType[P]>
            : GetScalarType<T[P], ArrivalStatusesGroupByOutputType[P]>
        }
      >
    >


  export type ArrivalStatusesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arrivalId?: boolean
    status?: boolean
    statusQc?: boolean
    statusWeighing?: boolean
    statusApproval?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    arrival?: boolean | ArrivalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["arrivalStatuses"]>



  export type ArrivalStatusesSelectScalar = {
    id?: boolean
    arrivalId?: boolean
    status?: boolean
    statusQc?: boolean
    statusWeighing?: boolean
    statusApproval?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ArrivalStatusesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "arrivalId" | "status" | "statusQc" | "statusWeighing" | "statusApproval" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["arrivalStatuses"]>
  export type ArrivalStatusesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arrival?: boolean | ArrivalsDefaultArgs<ExtArgs>
  }

  export type $ArrivalStatusesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArrivalStatuses"
    objects: {
      arrival: Prisma.$ArrivalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      arrivalId: number
      status: string
      statusQc: string | null
      statusWeighing: string | null
      statusApproval: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["arrivalStatuses"]>
    composites: {}
  }

  type ArrivalStatusesGetPayload<S extends boolean | null | undefined | ArrivalStatusesDefaultArgs> = $Result.GetResult<Prisma.$ArrivalStatusesPayload, S>

  type ArrivalStatusesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArrivalStatusesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArrivalStatusesCountAggregateInputType | true
    }

  export interface ArrivalStatusesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArrivalStatuses'], meta: { name: 'ArrivalStatuses' } }
    /**
     * Find zero or one ArrivalStatuses that matches the filter.
     * @param {ArrivalStatusesFindUniqueArgs} args - Arguments to find a ArrivalStatuses
     * @example
     * // Get one ArrivalStatuses
     * const arrivalStatuses = await prisma.arrivalStatuses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArrivalStatusesFindUniqueArgs>(args: SelectSubset<T, ArrivalStatusesFindUniqueArgs<ExtArgs>>): Prisma__ArrivalStatusesClient<$Result.GetResult<Prisma.$ArrivalStatusesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArrivalStatuses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArrivalStatusesFindUniqueOrThrowArgs} args - Arguments to find a ArrivalStatuses
     * @example
     * // Get one ArrivalStatuses
     * const arrivalStatuses = await prisma.arrivalStatuses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArrivalStatusesFindUniqueOrThrowArgs>(args: SelectSubset<T, ArrivalStatusesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArrivalStatusesClient<$Result.GetResult<Prisma.$ArrivalStatusesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArrivalStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalStatusesFindFirstArgs} args - Arguments to find a ArrivalStatuses
     * @example
     * // Get one ArrivalStatuses
     * const arrivalStatuses = await prisma.arrivalStatuses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArrivalStatusesFindFirstArgs>(args?: SelectSubset<T, ArrivalStatusesFindFirstArgs<ExtArgs>>): Prisma__ArrivalStatusesClient<$Result.GetResult<Prisma.$ArrivalStatusesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArrivalStatuses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalStatusesFindFirstOrThrowArgs} args - Arguments to find a ArrivalStatuses
     * @example
     * // Get one ArrivalStatuses
     * const arrivalStatuses = await prisma.arrivalStatuses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArrivalStatusesFindFirstOrThrowArgs>(args?: SelectSubset<T, ArrivalStatusesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArrivalStatusesClient<$Result.GetResult<Prisma.$ArrivalStatusesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArrivalStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalStatusesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArrivalStatuses
     * const arrivalStatuses = await prisma.arrivalStatuses.findMany()
     * 
     * // Get first 10 ArrivalStatuses
     * const arrivalStatuses = await prisma.arrivalStatuses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const arrivalStatusesWithIdOnly = await prisma.arrivalStatuses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArrivalStatusesFindManyArgs>(args?: SelectSubset<T, ArrivalStatusesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArrivalStatusesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArrivalStatuses.
     * @param {ArrivalStatusesCreateArgs} args - Arguments to create a ArrivalStatuses.
     * @example
     * // Create one ArrivalStatuses
     * const ArrivalStatuses = await prisma.arrivalStatuses.create({
     *   data: {
     *     // ... data to create a ArrivalStatuses
     *   }
     * })
     * 
     */
    create<T extends ArrivalStatusesCreateArgs>(args: SelectSubset<T, ArrivalStatusesCreateArgs<ExtArgs>>): Prisma__ArrivalStatusesClient<$Result.GetResult<Prisma.$ArrivalStatusesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArrivalStatuses.
     * @param {ArrivalStatusesCreateManyArgs} args - Arguments to create many ArrivalStatuses.
     * @example
     * // Create many ArrivalStatuses
     * const arrivalStatuses = await prisma.arrivalStatuses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArrivalStatusesCreateManyArgs>(args?: SelectSubset<T, ArrivalStatusesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArrivalStatuses.
     * @param {ArrivalStatusesDeleteArgs} args - Arguments to delete one ArrivalStatuses.
     * @example
     * // Delete one ArrivalStatuses
     * const ArrivalStatuses = await prisma.arrivalStatuses.delete({
     *   where: {
     *     // ... filter to delete one ArrivalStatuses
     *   }
     * })
     * 
     */
    delete<T extends ArrivalStatusesDeleteArgs>(args: SelectSubset<T, ArrivalStatusesDeleteArgs<ExtArgs>>): Prisma__ArrivalStatusesClient<$Result.GetResult<Prisma.$ArrivalStatusesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArrivalStatuses.
     * @param {ArrivalStatusesUpdateArgs} args - Arguments to update one ArrivalStatuses.
     * @example
     * // Update one ArrivalStatuses
     * const arrivalStatuses = await prisma.arrivalStatuses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArrivalStatusesUpdateArgs>(args: SelectSubset<T, ArrivalStatusesUpdateArgs<ExtArgs>>): Prisma__ArrivalStatusesClient<$Result.GetResult<Prisma.$ArrivalStatusesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArrivalStatuses.
     * @param {ArrivalStatusesDeleteManyArgs} args - Arguments to filter ArrivalStatuses to delete.
     * @example
     * // Delete a few ArrivalStatuses
     * const { count } = await prisma.arrivalStatuses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArrivalStatusesDeleteManyArgs>(args?: SelectSubset<T, ArrivalStatusesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArrivalStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalStatusesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArrivalStatuses
     * const arrivalStatuses = await prisma.arrivalStatuses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArrivalStatusesUpdateManyArgs>(args: SelectSubset<T, ArrivalStatusesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArrivalStatuses.
     * @param {ArrivalStatusesUpsertArgs} args - Arguments to update or create a ArrivalStatuses.
     * @example
     * // Update or create a ArrivalStatuses
     * const arrivalStatuses = await prisma.arrivalStatuses.upsert({
     *   create: {
     *     // ... data to create a ArrivalStatuses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArrivalStatuses we want to update
     *   }
     * })
     */
    upsert<T extends ArrivalStatusesUpsertArgs>(args: SelectSubset<T, ArrivalStatusesUpsertArgs<ExtArgs>>): Prisma__ArrivalStatusesClient<$Result.GetResult<Prisma.$ArrivalStatusesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArrivalStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalStatusesCountArgs} args - Arguments to filter ArrivalStatuses to count.
     * @example
     * // Count the number of ArrivalStatuses
     * const count = await prisma.arrivalStatuses.count({
     *   where: {
     *     // ... the filter for the ArrivalStatuses we want to count
     *   }
     * })
    **/
    count<T extends ArrivalStatusesCountArgs>(
      args?: Subset<T, ArrivalStatusesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArrivalStatusesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArrivalStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalStatusesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArrivalStatusesAggregateArgs>(args: Subset<T, ArrivalStatusesAggregateArgs>): Prisma.PrismaPromise<GetArrivalStatusesAggregateType<T>>

    /**
     * Group by ArrivalStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArrivalStatusesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArrivalStatusesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArrivalStatusesGroupByArgs['orderBy'] }
        : { orderBy?: ArrivalStatusesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArrivalStatusesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArrivalStatusesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArrivalStatuses model
   */
  readonly fields: ArrivalStatusesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArrivalStatuses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArrivalStatusesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    arrival<T extends ArrivalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArrivalsDefaultArgs<ExtArgs>>): Prisma__ArrivalsClient<$Result.GetResult<Prisma.$ArrivalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArrivalStatuses model
   */
  interface ArrivalStatusesFieldRefs {
    readonly id: FieldRef<"ArrivalStatuses", 'Int'>
    readonly arrivalId: FieldRef<"ArrivalStatuses", 'Int'>
    readonly status: FieldRef<"ArrivalStatuses", 'String'>
    readonly statusQc: FieldRef<"ArrivalStatuses", 'String'>
    readonly statusWeighing: FieldRef<"ArrivalStatuses", 'String'>
    readonly statusApproval: FieldRef<"ArrivalStatuses", 'String'>
    readonly createdAt: FieldRef<"ArrivalStatuses", 'DateTime'>
    readonly createdBy: FieldRef<"ArrivalStatuses", 'String'>
    readonly updatedAt: FieldRef<"ArrivalStatuses", 'DateTime'>
    readonly updatedBy: FieldRef<"ArrivalStatuses", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ArrivalStatuses findUnique
   */
  export type ArrivalStatusesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
    /**
     * Filter, which ArrivalStatuses to fetch.
     */
    where: ArrivalStatusesWhereUniqueInput
  }

  /**
   * ArrivalStatuses findUniqueOrThrow
   */
  export type ArrivalStatusesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
    /**
     * Filter, which ArrivalStatuses to fetch.
     */
    where: ArrivalStatusesWhereUniqueInput
  }

  /**
   * ArrivalStatuses findFirst
   */
  export type ArrivalStatusesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
    /**
     * Filter, which ArrivalStatuses to fetch.
     */
    where?: ArrivalStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArrivalStatuses to fetch.
     */
    orderBy?: ArrivalStatusesOrderByWithRelationInput | ArrivalStatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArrivalStatuses.
     */
    cursor?: ArrivalStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArrivalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArrivalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArrivalStatuses.
     */
    distinct?: ArrivalStatusesScalarFieldEnum | ArrivalStatusesScalarFieldEnum[]
  }

  /**
   * ArrivalStatuses findFirstOrThrow
   */
  export type ArrivalStatusesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
    /**
     * Filter, which ArrivalStatuses to fetch.
     */
    where?: ArrivalStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArrivalStatuses to fetch.
     */
    orderBy?: ArrivalStatusesOrderByWithRelationInput | ArrivalStatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArrivalStatuses.
     */
    cursor?: ArrivalStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArrivalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArrivalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArrivalStatuses.
     */
    distinct?: ArrivalStatusesScalarFieldEnum | ArrivalStatusesScalarFieldEnum[]
  }

  /**
   * ArrivalStatuses findMany
   */
  export type ArrivalStatusesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
    /**
     * Filter, which ArrivalStatuses to fetch.
     */
    where?: ArrivalStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArrivalStatuses to fetch.
     */
    orderBy?: ArrivalStatusesOrderByWithRelationInput | ArrivalStatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArrivalStatuses.
     */
    cursor?: ArrivalStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArrivalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArrivalStatuses.
     */
    skip?: number
    distinct?: ArrivalStatusesScalarFieldEnum | ArrivalStatusesScalarFieldEnum[]
  }

  /**
   * ArrivalStatuses create
   */
  export type ArrivalStatusesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
    /**
     * The data needed to create a ArrivalStatuses.
     */
    data: XOR<ArrivalStatusesCreateInput, ArrivalStatusesUncheckedCreateInput>
  }

  /**
   * ArrivalStatuses createMany
   */
  export type ArrivalStatusesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArrivalStatuses.
     */
    data: ArrivalStatusesCreateManyInput | ArrivalStatusesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArrivalStatuses update
   */
  export type ArrivalStatusesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
    /**
     * The data needed to update a ArrivalStatuses.
     */
    data: XOR<ArrivalStatusesUpdateInput, ArrivalStatusesUncheckedUpdateInput>
    /**
     * Choose, which ArrivalStatuses to update.
     */
    where: ArrivalStatusesWhereUniqueInput
  }

  /**
   * ArrivalStatuses updateMany
   */
  export type ArrivalStatusesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArrivalStatuses.
     */
    data: XOR<ArrivalStatusesUpdateManyMutationInput, ArrivalStatusesUncheckedUpdateManyInput>
    /**
     * Filter which ArrivalStatuses to update
     */
    where?: ArrivalStatusesWhereInput
    /**
     * Limit how many ArrivalStatuses to update.
     */
    limit?: number
  }

  /**
   * ArrivalStatuses upsert
   */
  export type ArrivalStatusesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
    /**
     * The filter to search for the ArrivalStatuses to update in case it exists.
     */
    where: ArrivalStatusesWhereUniqueInput
    /**
     * In case the ArrivalStatuses found by the `where` argument doesn't exist, create a new ArrivalStatuses with this data.
     */
    create: XOR<ArrivalStatusesCreateInput, ArrivalStatusesUncheckedCreateInput>
    /**
     * In case the ArrivalStatuses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArrivalStatusesUpdateInput, ArrivalStatusesUncheckedUpdateInput>
  }

  /**
   * ArrivalStatuses delete
   */
  export type ArrivalStatusesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
    /**
     * Filter which ArrivalStatuses to delete.
     */
    where: ArrivalStatusesWhereUniqueInput
  }

  /**
   * ArrivalStatuses deleteMany
   */
  export type ArrivalStatusesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArrivalStatuses to delete
     */
    where?: ArrivalStatusesWhereInput
    /**
     * Limit how many ArrivalStatuses to delete.
     */
    limit?: number
  }

  /**
   * ArrivalStatuses without action
   */
  export type ArrivalStatusesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArrivalStatuses
     */
    select?: ArrivalStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArrivalStatuses
     */
    omit?: ArrivalStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArrivalStatusesInclude<ExtArgs> | null
  }


  /**
   * Model ParameterSettings
   */

  export type AggregateParameterSettings = {
    _count: ParameterSettingsCountAggregateOutputType | null
    _avg: ParameterSettingsAvgAggregateOutputType | null
    _sum: ParameterSettingsSumAggregateOutputType | null
    _min: ParameterSettingsMinAggregateOutputType | null
    _max: ParameterSettingsMaxAggregateOutputType | null
  }

  export type ParameterSettingsAvgAggregateOutputType = {
    id: number | null
    parameterId: number | null
  }

  export type ParameterSettingsSumAggregateOutputType = {
    id: number | null
    parameterId: number | null
  }

  export type ParameterSettingsMinAggregateOutputType = {
    id: number | null
    parameterId: number | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ParameterSettingsMaxAggregateOutputType = {
    id: number | null
    parameterId: number | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ParameterSettingsCountAggregateOutputType = {
    id: number
    parameterId: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type ParameterSettingsAvgAggregateInputType = {
    id?: true
    parameterId?: true
  }

  export type ParameterSettingsSumAggregateInputType = {
    id?: true
    parameterId?: true
  }

  export type ParameterSettingsMinAggregateInputType = {
    id?: true
    parameterId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ParameterSettingsMaxAggregateInputType = {
    id?: true
    parameterId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ParameterSettingsCountAggregateInputType = {
    id?: true
    parameterId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type ParameterSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParameterSettings to aggregate.
     */
    where?: ParameterSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParameterSettings to fetch.
     */
    orderBy?: ParameterSettingsOrderByWithRelationInput | ParameterSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParameterSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParameterSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParameterSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParameterSettings
    **/
    _count?: true | ParameterSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParameterSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParameterSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParameterSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParameterSettingsMaxAggregateInputType
  }

  export type GetParameterSettingsAggregateType<T extends ParameterSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateParameterSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParameterSettings[P]>
      : GetScalarType<T[P], AggregateParameterSettings[P]>
  }




  export type ParameterSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParameterSettingsWhereInput
    orderBy?: ParameterSettingsOrderByWithAggregationInput | ParameterSettingsOrderByWithAggregationInput[]
    by: ParameterSettingsScalarFieldEnum[] | ParameterSettingsScalarFieldEnum
    having?: ParameterSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParameterSettingsCountAggregateInputType | true
    _avg?: ParameterSettingsAvgAggregateInputType
    _sum?: ParameterSettingsSumAggregateInputType
    _min?: ParameterSettingsMinAggregateInputType
    _max?: ParameterSettingsMaxAggregateInputType
  }

  export type ParameterSettingsGroupByOutputType = {
    id: number
    parameterId: number
    key: string
    value: string
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: ParameterSettingsCountAggregateOutputType | null
    _avg: ParameterSettingsAvgAggregateOutputType | null
    _sum: ParameterSettingsSumAggregateOutputType | null
    _min: ParameterSettingsMinAggregateOutputType | null
    _max: ParameterSettingsMaxAggregateOutputType | null
  }

  type GetParameterSettingsGroupByPayload<T extends ParameterSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParameterSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParameterSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParameterSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], ParameterSettingsGroupByOutputType[P]>
        }
      >
    >


  export type ParameterSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parameterId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    parameter?: boolean | ParametersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parameterSettings"]>



  export type ParameterSettingsSelectScalar = {
    id?: boolean
    parameterId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type ParameterSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parameterId" | "key" | "value" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["parameterSettings"]>
  export type ParameterSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameter?: boolean | ParametersDefaultArgs<ExtArgs>
  }

  export type $ParameterSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParameterSettings"
    objects: {
      parameter: Prisma.$ParametersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parameterId: number
      key: string
      value: string
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["parameterSettings"]>
    composites: {}
  }

  type ParameterSettingsGetPayload<S extends boolean | null | undefined | ParameterSettingsDefaultArgs> = $Result.GetResult<Prisma.$ParameterSettingsPayload, S>

  type ParameterSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParameterSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParameterSettingsCountAggregateInputType | true
    }

  export interface ParameterSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParameterSettings'], meta: { name: 'ParameterSettings' } }
    /**
     * Find zero or one ParameterSettings that matches the filter.
     * @param {ParameterSettingsFindUniqueArgs} args - Arguments to find a ParameterSettings
     * @example
     * // Get one ParameterSettings
     * const parameterSettings = await prisma.parameterSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParameterSettingsFindUniqueArgs>(args: SelectSubset<T, ParameterSettingsFindUniqueArgs<ExtArgs>>): Prisma__ParameterSettingsClient<$Result.GetResult<Prisma.$ParameterSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParameterSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParameterSettingsFindUniqueOrThrowArgs} args - Arguments to find a ParameterSettings
     * @example
     * // Get one ParameterSettings
     * const parameterSettings = await prisma.parameterSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParameterSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ParameterSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParameterSettingsClient<$Result.GetResult<Prisma.$ParameterSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParameterSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterSettingsFindFirstArgs} args - Arguments to find a ParameterSettings
     * @example
     * // Get one ParameterSettings
     * const parameterSettings = await prisma.parameterSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParameterSettingsFindFirstArgs>(args?: SelectSubset<T, ParameterSettingsFindFirstArgs<ExtArgs>>): Prisma__ParameterSettingsClient<$Result.GetResult<Prisma.$ParameterSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParameterSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterSettingsFindFirstOrThrowArgs} args - Arguments to find a ParameterSettings
     * @example
     * // Get one ParameterSettings
     * const parameterSettings = await prisma.parameterSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParameterSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ParameterSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParameterSettingsClient<$Result.GetResult<Prisma.$ParameterSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParameterSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParameterSettings
     * const parameterSettings = await prisma.parameterSettings.findMany()
     * 
     * // Get first 10 ParameterSettings
     * const parameterSettings = await prisma.parameterSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parameterSettingsWithIdOnly = await prisma.parameterSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParameterSettingsFindManyArgs>(args?: SelectSubset<T, ParameterSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParameterSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParameterSettings.
     * @param {ParameterSettingsCreateArgs} args - Arguments to create a ParameterSettings.
     * @example
     * // Create one ParameterSettings
     * const ParameterSettings = await prisma.parameterSettings.create({
     *   data: {
     *     // ... data to create a ParameterSettings
     *   }
     * })
     * 
     */
    create<T extends ParameterSettingsCreateArgs>(args: SelectSubset<T, ParameterSettingsCreateArgs<ExtArgs>>): Prisma__ParameterSettingsClient<$Result.GetResult<Prisma.$ParameterSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParameterSettings.
     * @param {ParameterSettingsCreateManyArgs} args - Arguments to create many ParameterSettings.
     * @example
     * // Create many ParameterSettings
     * const parameterSettings = await prisma.parameterSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParameterSettingsCreateManyArgs>(args?: SelectSubset<T, ParameterSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ParameterSettings.
     * @param {ParameterSettingsDeleteArgs} args - Arguments to delete one ParameterSettings.
     * @example
     * // Delete one ParameterSettings
     * const ParameterSettings = await prisma.parameterSettings.delete({
     *   where: {
     *     // ... filter to delete one ParameterSettings
     *   }
     * })
     * 
     */
    delete<T extends ParameterSettingsDeleteArgs>(args: SelectSubset<T, ParameterSettingsDeleteArgs<ExtArgs>>): Prisma__ParameterSettingsClient<$Result.GetResult<Prisma.$ParameterSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParameterSettings.
     * @param {ParameterSettingsUpdateArgs} args - Arguments to update one ParameterSettings.
     * @example
     * // Update one ParameterSettings
     * const parameterSettings = await prisma.parameterSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParameterSettingsUpdateArgs>(args: SelectSubset<T, ParameterSettingsUpdateArgs<ExtArgs>>): Prisma__ParameterSettingsClient<$Result.GetResult<Prisma.$ParameterSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParameterSettings.
     * @param {ParameterSettingsDeleteManyArgs} args - Arguments to filter ParameterSettings to delete.
     * @example
     * // Delete a few ParameterSettings
     * const { count } = await prisma.parameterSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParameterSettingsDeleteManyArgs>(args?: SelectSubset<T, ParameterSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParameterSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParameterSettings
     * const parameterSettings = await prisma.parameterSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParameterSettingsUpdateManyArgs>(args: SelectSubset<T, ParameterSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParameterSettings.
     * @param {ParameterSettingsUpsertArgs} args - Arguments to update or create a ParameterSettings.
     * @example
     * // Update or create a ParameterSettings
     * const parameterSettings = await prisma.parameterSettings.upsert({
     *   create: {
     *     // ... data to create a ParameterSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParameterSettings we want to update
     *   }
     * })
     */
    upsert<T extends ParameterSettingsUpsertArgs>(args: SelectSubset<T, ParameterSettingsUpsertArgs<ExtArgs>>): Prisma__ParameterSettingsClient<$Result.GetResult<Prisma.$ParameterSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParameterSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterSettingsCountArgs} args - Arguments to filter ParameterSettings to count.
     * @example
     * // Count the number of ParameterSettings
     * const count = await prisma.parameterSettings.count({
     *   where: {
     *     // ... the filter for the ParameterSettings we want to count
     *   }
     * })
    **/
    count<T extends ParameterSettingsCountArgs>(
      args?: Subset<T, ParameterSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParameterSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParameterSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParameterSettingsAggregateArgs>(args: Subset<T, ParameterSettingsAggregateArgs>): Prisma.PrismaPromise<GetParameterSettingsAggregateType<T>>

    /**
     * Group by ParameterSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParameterSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParameterSettingsGroupByArgs['orderBy'] }
        : { orderBy?: ParameterSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParameterSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParameterSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParameterSettings model
   */
  readonly fields: ParameterSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParameterSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParameterSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parameter<T extends ParametersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParametersDefaultArgs<ExtArgs>>): Prisma__ParametersClient<$Result.GetResult<Prisma.$ParametersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParameterSettings model
   */
  interface ParameterSettingsFieldRefs {
    readonly id: FieldRef<"ParameterSettings", 'Int'>
    readonly parameterId: FieldRef<"ParameterSettings", 'Int'>
    readonly key: FieldRef<"ParameterSettings", 'String'>
    readonly value: FieldRef<"ParameterSettings", 'String'>
    readonly createdAt: FieldRef<"ParameterSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"ParameterSettings", 'DateTime'>
    readonly createdBy: FieldRef<"ParameterSettings", 'String'>
    readonly updatedBy: FieldRef<"ParameterSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ParameterSettings findUnique
   */
  export type ParameterSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ParameterSettings to fetch.
     */
    where: ParameterSettingsWhereUniqueInput
  }

  /**
   * ParameterSettings findUniqueOrThrow
   */
  export type ParameterSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ParameterSettings to fetch.
     */
    where: ParameterSettingsWhereUniqueInput
  }

  /**
   * ParameterSettings findFirst
   */
  export type ParameterSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ParameterSettings to fetch.
     */
    where?: ParameterSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParameterSettings to fetch.
     */
    orderBy?: ParameterSettingsOrderByWithRelationInput | ParameterSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParameterSettings.
     */
    cursor?: ParameterSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParameterSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParameterSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParameterSettings.
     */
    distinct?: ParameterSettingsScalarFieldEnum | ParameterSettingsScalarFieldEnum[]
  }

  /**
   * ParameterSettings findFirstOrThrow
   */
  export type ParameterSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ParameterSettings to fetch.
     */
    where?: ParameterSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParameterSettings to fetch.
     */
    orderBy?: ParameterSettingsOrderByWithRelationInput | ParameterSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParameterSettings.
     */
    cursor?: ParameterSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParameterSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParameterSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParameterSettings.
     */
    distinct?: ParameterSettingsScalarFieldEnum | ParameterSettingsScalarFieldEnum[]
  }

  /**
   * ParameterSettings findMany
   */
  export type ParameterSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ParameterSettings to fetch.
     */
    where?: ParameterSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParameterSettings to fetch.
     */
    orderBy?: ParameterSettingsOrderByWithRelationInput | ParameterSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParameterSettings.
     */
    cursor?: ParameterSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParameterSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParameterSettings.
     */
    skip?: number
    distinct?: ParameterSettingsScalarFieldEnum | ParameterSettingsScalarFieldEnum[]
  }

  /**
   * ParameterSettings create
   */
  export type ParameterSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a ParameterSettings.
     */
    data: XOR<ParameterSettingsCreateInput, ParameterSettingsUncheckedCreateInput>
  }

  /**
   * ParameterSettings createMany
   */
  export type ParameterSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParameterSettings.
     */
    data: ParameterSettingsCreateManyInput | ParameterSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParameterSettings update
   */
  export type ParameterSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a ParameterSettings.
     */
    data: XOR<ParameterSettingsUpdateInput, ParameterSettingsUncheckedUpdateInput>
    /**
     * Choose, which ParameterSettings to update.
     */
    where: ParameterSettingsWhereUniqueInput
  }

  /**
   * ParameterSettings updateMany
   */
  export type ParameterSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParameterSettings.
     */
    data: XOR<ParameterSettingsUpdateManyMutationInput, ParameterSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ParameterSettings to update
     */
    where?: ParameterSettingsWhereInput
    /**
     * Limit how many ParameterSettings to update.
     */
    limit?: number
  }

  /**
   * ParameterSettings upsert
   */
  export type ParameterSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the ParameterSettings to update in case it exists.
     */
    where: ParameterSettingsWhereUniqueInput
    /**
     * In case the ParameterSettings found by the `where` argument doesn't exist, create a new ParameterSettings with this data.
     */
    create: XOR<ParameterSettingsCreateInput, ParameterSettingsUncheckedCreateInput>
    /**
     * In case the ParameterSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParameterSettingsUpdateInput, ParameterSettingsUncheckedUpdateInput>
  }

  /**
   * ParameterSettings delete
   */
  export type ParameterSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
    /**
     * Filter which ParameterSettings to delete.
     */
    where: ParameterSettingsWhereUniqueInput
  }

  /**
   * ParameterSettings deleteMany
   */
  export type ParameterSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParameterSettings to delete
     */
    where?: ParameterSettingsWhereInput
    /**
     * Limit how many ParameterSettings to delete.
     */
    limit?: number
  }

  /**
   * ParameterSettings without action
   */
  export type ParameterSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParameterSettings
     */
    select?: ParameterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParameterSettings
     */
    omit?: ParameterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParameterSettingsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    username: 'username',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SuppliersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SuppliersScalarFieldEnum = (typeof SuppliersScalarFieldEnum)[keyof typeof SuppliersScalarFieldEnum]


  export const MaterialsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type MaterialsScalarFieldEnum = (typeof MaterialsScalarFieldEnum)[keyof typeof MaterialsScalarFieldEnum]


  export const ConditionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ConditionsScalarFieldEnum = (typeof ConditionsScalarFieldEnum)[keyof typeof ConditionsScalarFieldEnum]


  export const ParametersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    unit: 'unit',
    type: 'type',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ParametersScalarFieldEnum = (typeof ParametersScalarFieldEnum)[keyof typeof ParametersScalarFieldEnum]


  export const ArrivalsScalarFieldEnum: {
    id: 'id',
    idKedatangan: 'idKedatangan',
    supplierId: 'supplierId',
    arrivalDate: 'arrivalDate',
    arrivalTime: 'arrivalTime',
    nopol: 'nopol',
    suratJalan: 'suratJalan',
    city: 'city',
    note: 'note',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ArrivalsScalarFieldEnum = (typeof ArrivalsScalarFieldEnum)[keyof typeof ArrivalsScalarFieldEnum]


  export const ArrivalItemsScalarFieldEnum: {
    id: 'id',
    arrivalId: 'arrivalId',
    materialId: 'materialId',
    conditionId: 'conditionId',
    parameterId: 'parameterId',
    conditionCategory: 'conditionCategory',
    quantity: 'quantity',
    note: 'note',
    itemName: 'itemName',
    qcNote: 'qcNote',
    qcStatusId: 'qcStatusId',
    qcAnalysis: 'qcAnalysis',
    qcSample: 'qcSample',
    qcKotoran: 'qcKotoran',
    totalBerat: 'totalBerat',
    pengeringan: 'pengeringan',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    statusQc: 'statusQc'
  };

  export type ArrivalItemsScalarFieldEnum = (typeof ArrivalItemsScalarFieldEnum)[keyof typeof ArrivalItemsScalarFieldEnum]


  export const WeighingsScalarFieldEnum: {
    id: 'id',
    arrivalItemId: 'arrivalItemId',
    weight: 'weight',
    note: 'note',
    weighingDate: 'weighingDate',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type WeighingsScalarFieldEnum = (typeof WeighingsScalarFieldEnum)[keyof typeof WeighingsScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    table: 'table',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const QcResultsScalarFieldEnum: {
    id: 'id',
    arrivalItemId: 'arrivalItemId',
    parameterId: 'parameterId',
    historyId: 'historyId',
    resultKey: 'resultKey',
    value: 'value',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type QcResultsScalarFieldEnum = (typeof QcResultsScalarFieldEnum)[keyof typeof QcResultsScalarFieldEnum]


  export const QcStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type QcStatusScalarFieldEnum = (typeof QcStatusScalarFieldEnum)[keyof typeof QcStatusScalarFieldEnum]


  export const QcPhotosScalarFieldEnum: {
    id: 'id',
    arrivalItemId: 'arrivalItemId',
    photo: 'photo',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type QcPhotosScalarFieldEnum = (typeof QcPhotosScalarFieldEnum)[keyof typeof QcPhotosScalarFieldEnum]


  export const SecurityPhotosScalarFieldEnum: {
    id: 'id',
    arrivalId: 'arrivalId',
    photo: 'photo',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SecurityPhotosScalarFieldEnum = (typeof SecurityPhotosScalarFieldEnum)[keyof typeof SecurityPhotosScalarFieldEnum]


  export const WeighingsPhotosScalarFieldEnum: {
    id: 'id',
    arrivalItemId: 'arrivalItemId',
    photo: 'photo',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type WeighingsPhotosScalarFieldEnum = (typeof WeighingsPhotosScalarFieldEnum)[keyof typeof WeighingsPhotosScalarFieldEnum]


  export const QcHistoriesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    statusId: 'statusId',
    arrivalId: 'arrivalId',
    arrivalItemId: 'arrivalItemId',
    qcSample: 'qcSample',
    qcKotoran: 'qcKotoran',
    totalBerat: 'totalBerat',
    pengeringan: 'pengeringan',
    note: 'note',
    qcNote: 'qcNote',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QcHistoriesScalarFieldEnum = (typeof QcHistoriesScalarFieldEnum)[keyof typeof QcHistoriesScalarFieldEnum]


  export const ArrivalStatusesScalarFieldEnum: {
    id: 'id',
    arrivalId: 'arrivalId',
    status: 'status',
    statusQc: 'statusQc',
    statusWeighing: 'statusWeighing',
    statusApproval: 'statusApproval',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ArrivalStatusesScalarFieldEnum = (typeof ArrivalStatusesScalarFieldEnum)[keyof typeof ArrivalStatusesScalarFieldEnum]


  export const ParameterSettingsScalarFieldEnum: {
    id: 'id',
    parameterId: 'parameterId',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ParameterSettingsScalarFieldEnum = (typeof ParameterSettingsScalarFieldEnum)[keyof typeof ParameterSettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UsersOrderByRelevanceFieldEnum: {
    username: 'username',
    email: 'email',
    password: 'password',
    role: 'role',
    id: 'id',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type UsersOrderByRelevanceFieldEnum = (typeof UsersOrderByRelevanceFieldEnum)[keyof typeof UsersOrderByRelevanceFieldEnum]


  export const SuppliersOrderByRelevanceFieldEnum: {
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type SuppliersOrderByRelevanceFieldEnum = (typeof SuppliersOrderByRelevanceFieldEnum)[keyof typeof SuppliersOrderByRelevanceFieldEnum]


  export const MaterialsOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type MaterialsOrderByRelevanceFieldEnum = (typeof MaterialsOrderByRelevanceFieldEnum)[keyof typeof MaterialsOrderByRelevanceFieldEnum]


  export const ConditionsOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ConditionsOrderByRelevanceFieldEnum = (typeof ConditionsOrderByRelevanceFieldEnum)[keyof typeof ConditionsOrderByRelevanceFieldEnum]


  export const ParametersOrderByRelevanceFieldEnum: {
    name: 'name',
    unit: 'unit',
    type: 'type',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ParametersOrderByRelevanceFieldEnum = (typeof ParametersOrderByRelevanceFieldEnum)[keyof typeof ParametersOrderByRelevanceFieldEnum]


  export const ArrivalsOrderByRelevanceFieldEnum: {
    idKedatangan: 'idKedatangan',
    arrivalTime: 'arrivalTime',
    nopol: 'nopol',
    suratJalan: 'suratJalan',
    city: 'city',
    note: 'note',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ArrivalsOrderByRelevanceFieldEnum = (typeof ArrivalsOrderByRelevanceFieldEnum)[keyof typeof ArrivalsOrderByRelevanceFieldEnum]


  export const ArrivalItemsOrderByRelevanceFieldEnum: {
    conditionCategory: 'conditionCategory',
    note: 'note',
    itemName: 'itemName',
    qcNote: 'qcNote',
    qcAnalysis: 'qcAnalysis',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ArrivalItemsOrderByRelevanceFieldEnum = (typeof ArrivalItemsOrderByRelevanceFieldEnum)[keyof typeof ArrivalItemsOrderByRelevanceFieldEnum]


  export const WeighingsOrderByRelevanceFieldEnum: {
    note: 'note',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type WeighingsOrderByRelevanceFieldEnum = (typeof WeighingsOrderByRelevanceFieldEnum)[keyof typeof WeighingsOrderByRelevanceFieldEnum]


  export const NotificationsOrderByRelevanceFieldEnum: {
    table: 'table',
    description: 'description'
  };

  export type NotificationsOrderByRelevanceFieldEnum = (typeof NotificationsOrderByRelevanceFieldEnum)[keyof typeof NotificationsOrderByRelevanceFieldEnum]


  export const QcResultsOrderByRelevanceFieldEnum: {
    resultKey: 'resultKey',
    value: 'value',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type QcResultsOrderByRelevanceFieldEnum = (typeof QcResultsOrderByRelevanceFieldEnum)[keyof typeof QcResultsOrderByRelevanceFieldEnum]


  export const QcStatusOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type QcStatusOrderByRelevanceFieldEnum = (typeof QcStatusOrderByRelevanceFieldEnum)[keyof typeof QcStatusOrderByRelevanceFieldEnum]


  export const QcPhotosOrderByRelevanceFieldEnum: {
    photo: 'photo',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type QcPhotosOrderByRelevanceFieldEnum = (typeof QcPhotosOrderByRelevanceFieldEnum)[keyof typeof QcPhotosOrderByRelevanceFieldEnum]


  export const SecurityPhotosOrderByRelevanceFieldEnum: {
    photo: 'photo',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type SecurityPhotosOrderByRelevanceFieldEnum = (typeof SecurityPhotosOrderByRelevanceFieldEnum)[keyof typeof SecurityPhotosOrderByRelevanceFieldEnum]


  export const WeighingsPhotosOrderByRelevanceFieldEnum: {
    photo: 'photo',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type WeighingsPhotosOrderByRelevanceFieldEnum = (typeof WeighingsPhotosOrderByRelevanceFieldEnum)[keyof typeof WeighingsPhotosOrderByRelevanceFieldEnum]


  export const QcHistoriesOrderByRelevanceFieldEnum: {
    userId: 'userId',
    note: 'note',
    qcNote: 'qcNote'
  };

  export type QcHistoriesOrderByRelevanceFieldEnum = (typeof QcHistoriesOrderByRelevanceFieldEnum)[keyof typeof QcHistoriesOrderByRelevanceFieldEnum]


  export const ArrivalStatusesOrderByRelevanceFieldEnum: {
    status: 'status',
    statusQc: 'statusQc',
    statusWeighing: 'statusWeighing',
    statusApproval: 'statusApproval',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ArrivalStatusesOrderByRelevanceFieldEnum = (typeof ArrivalStatusesOrderByRelevanceFieldEnum)[keyof typeof ArrivalStatusesOrderByRelevanceFieldEnum]


  export const ParameterSettingsOrderByRelevanceFieldEnum: {
    key: 'key',
    value: 'value',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ParameterSettingsOrderByRelevanceFieldEnum = (typeof ParameterSettingsOrderByRelevanceFieldEnum)[keyof typeof ParameterSettingsOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    username?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    role?: StringFilter<"Users"> | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    id?: StringFilter<"Users"> | string
    createdBy?: StringNullableFilter<"Users"> | string | null
    updatedBy?: StringNullableFilter<"Users"> | string | null
    QcHistories?: QcHistoriesListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    QcHistories?: QcHistoriesOrderByRelationAggregateInput
    _relevance?: UsersOrderByRelevanceInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    username?: string
    email?: string
    id?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    password?: StringFilter<"Users"> | string
    role?: StringFilter<"Users"> | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    createdBy?: StringNullableFilter<"Users"> | string | null
    updatedBy?: StringNullableFilter<"Users"> | string | null
    QcHistories?: QcHistoriesListRelationFilter
  }, "id" | "username" | "email">

  export type UsersOrderByWithAggregationInput = {
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    username?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    role?: StringWithAggregatesFilter<"Users"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    id?: StringWithAggregatesFilter<"Users"> | string
    createdBy?: StringNullableWithAggregatesFilter<"Users"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Users"> | string | null
  }

  export type SuppliersWhereInput = {
    AND?: SuppliersWhereInput | SuppliersWhereInput[]
    OR?: SuppliersWhereInput[]
    NOT?: SuppliersWhereInput | SuppliersWhereInput[]
    id?: IntFilter<"Suppliers"> | number
    name?: StringFilter<"Suppliers"> | string
    address?: StringNullableFilter<"Suppliers"> | string | null
    phone?: StringNullableFilter<"Suppliers"> | string | null
    email?: StringNullableFilter<"Suppliers"> | string | null
    createdAt?: DateTimeFilter<"Suppliers"> | Date | string
    createdBy?: StringNullableFilter<"Suppliers"> | string | null
    updatedAt?: DateTimeFilter<"Suppliers"> | Date | string
    updatedBy?: StringNullableFilter<"Suppliers"> | string | null
    Arrivals?: ArrivalsListRelationFilter
  }

  export type SuppliersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    Arrivals?: ArrivalsOrderByRelationAggregateInput
    _relevance?: SuppliersOrderByRelevanceInput
  }

  export type SuppliersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SuppliersWhereInput | SuppliersWhereInput[]
    OR?: SuppliersWhereInput[]
    NOT?: SuppliersWhereInput | SuppliersWhereInput[]
    name?: StringFilter<"Suppliers"> | string
    address?: StringNullableFilter<"Suppliers"> | string | null
    phone?: StringNullableFilter<"Suppliers"> | string | null
    email?: StringNullableFilter<"Suppliers"> | string | null
    createdAt?: DateTimeFilter<"Suppliers"> | Date | string
    createdBy?: StringNullableFilter<"Suppliers"> | string | null
    updatedAt?: DateTimeFilter<"Suppliers"> | Date | string
    updatedBy?: StringNullableFilter<"Suppliers"> | string | null
    Arrivals?: ArrivalsListRelationFilter
  }, "id">

  export type SuppliersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SuppliersCountOrderByAggregateInput
    _avg?: SuppliersAvgOrderByAggregateInput
    _max?: SuppliersMaxOrderByAggregateInput
    _min?: SuppliersMinOrderByAggregateInput
    _sum?: SuppliersSumOrderByAggregateInput
  }

  export type SuppliersScalarWhereWithAggregatesInput = {
    AND?: SuppliersScalarWhereWithAggregatesInput | SuppliersScalarWhereWithAggregatesInput[]
    OR?: SuppliersScalarWhereWithAggregatesInput[]
    NOT?: SuppliersScalarWhereWithAggregatesInput | SuppliersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Suppliers"> | number
    name?: StringWithAggregatesFilter<"Suppliers"> | string
    address?: StringNullableWithAggregatesFilter<"Suppliers"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Suppliers"> | string | null
    email?: StringNullableWithAggregatesFilter<"Suppliers"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Suppliers"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Suppliers"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Suppliers"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Suppliers"> | string | null
  }

  export type MaterialsWhereInput = {
    AND?: MaterialsWhereInput | MaterialsWhereInput[]
    OR?: MaterialsWhereInput[]
    NOT?: MaterialsWhereInput | MaterialsWhereInput[]
    id?: IntFilter<"Materials"> | number
    name?: StringFilter<"Materials"> | string
    description?: StringNullableFilter<"Materials"> | string | null
    createdAt?: DateTimeFilter<"Materials"> | Date | string
    createdBy?: StringNullableFilter<"Materials"> | string | null
    updatedAt?: DateTimeFilter<"Materials"> | Date | string
    updatedBy?: StringNullableFilter<"Materials"> | string | null
    ArrivalItems?: ArrivalItemsListRelationFilter
  }

  export type MaterialsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    ArrivalItems?: ArrivalItemsOrderByRelationAggregateInput
    _relevance?: MaterialsOrderByRelevanceInput
  }

  export type MaterialsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialsWhereInput | MaterialsWhereInput[]
    OR?: MaterialsWhereInput[]
    NOT?: MaterialsWhereInput | MaterialsWhereInput[]
    name?: StringFilter<"Materials"> | string
    description?: StringNullableFilter<"Materials"> | string | null
    createdAt?: DateTimeFilter<"Materials"> | Date | string
    createdBy?: StringNullableFilter<"Materials"> | string | null
    updatedAt?: DateTimeFilter<"Materials"> | Date | string
    updatedBy?: StringNullableFilter<"Materials"> | string | null
    ArrivalItems?: ArrivalItemsListRelationFilter
  }, "id">

  export type MaterialsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: MaterialsCountOrderByAggregateInput
    _avg?: MaterialsAvgOrderByAggregateInput
    _max?: MaterialsMaxOrderByAggregateInput
    _min?: MaterialsMinOrderByAggregateInput
    _sum?: MaterialsSumOrderByAggregateInput
  }

  export type MaterialsScalarWhereWithAggregatesInput = {
    AND?: MaterialsScalarWhereWithAggregatesInput | MaterialsScalarWhereWithAggregatesInput[]
    OR?: MaterialsScalarWhereWithAggregatesInput[]
    NOT?: MaterialsScalarWhereWithAggregatesInput | MaterialsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Materials"> | number
    name?: StringWithAggregatesFilter<"Materials"> | string
    description?: StringNullableWithAggregatesFilter<"Materials"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Materials"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Materials"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Materials"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Materials"> | string | null
  }

  export type ConditionsWhereInput = {
    AND?: ConditionsWhereInput | ConditionsWhereInput[]
    OR?: ConditionsWhereInput[]
    NOT?: ConditionsWhereInput | ConditionsWhereInput[]
    id?: IntFilter<"Conditions"> | number
    name?: StringFilter<"Conditions"> | string
    description?: StringNullableFilter<"Conditions"> | string | null
    createdAt?: DateTimeFilter<"Conditions"> | Date | string
    createdBy?: StringNullableFilter<"Conditions"> | string | null
    updatedAt?: DateTimeFilter<"Conditions"> | Date | string
    updatedBy?: StringNullableFilter<"Conditions"> | string | null
    ArrivalItems?: ArrivalItemsListRelationFilter
  }

  export type ConditionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    ArrivalItems?: ArrivalItemsOrderByRelationAggregateInput
    _relevance?: ConditionsOrderByRelevanceInput
  }

  export type ConditionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConditionsWhereInput | ConditionsWhereInput[]
    OR?: ConditionsWhereInput[]
    NOT?: ConditionsWhereInput | ConditionsWhereInput[]
    name?: StringFilter<"Conditions"> | string
    description?: StringNullableFilter<"Conditions"> | string | null
    createdAt?: DateTimeFilter<"Conditions"> | Date | string
    createdBy?: StringNullableFilter<"Conditions"> | string | null
    updatedAt?: DateTimeFilter<"Conditions"> | Date | string
    updatedBy?: StringNullableFilter<"Conditions"> | string | null
    ArrivalItems?: ArrivalItemsListRelationFilter
  }, "id">

  export type ConditionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ConditionsCountOrderByAggregateInput
    _avg?: ConditionsAvgOrderByAggregateInput
    _max?: ConditionsMaxOrderByAggregateInput
    _min?: ConditionsMinOrderByAggregateInput
    _sum?: ConditionsSumOrderByAggregateInput
  }

  export type ConditionsScalarWhereWithAggregatesInput = {
    AND?: ConditionsScalarWhereWithAggregatesInput | ConditionsScalarWhereWithAggregatesInput[]
    OR?: ConditionsScalarWhereWithAggregatesInput[]
    NOT?: ConditionsScalarWhereWithAggregatesInput | ConditionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conditions"> | number
    name?: StringWithAggregatesFilter<"Conditions"> | string
    description?: StringNullableWithAggregatesFilter<"Conditions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conditions"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Conditions"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Conditions"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Conditions"> | string | null
  }

  export type ParametersWhereInput = {
    AND?: ParametersWhereInput | ParametersWhereInput[]
    OR?: ParametersWhereInput[]
    NOT?: ParametersWhereInput | ParametersWhereInput[]
    id?: IntFilter<"Parameters"> | number
    name?: StringFilter<"Parameters"> | string
    unit?: StringNullableFilter<"Parameters"> | string | null
    type?: StringNullableFilter<"Parameters"> | string | null
    createdAt?: DateTimeFilter<"Parameters"> | Date | string
    createdBy?: StringNullableFilter<"Parameters"> | string | null
    updatedAt?: DateTimeFilter<"Parameters"> | Date | string
    updatedBy?: StringNullableFilter<"Parameters"> | string | null
    ArrivalItems?: ArrivalItemsListRelationFilter
    QcResults?: QcResultsListRelationFilter
    settings?: ParameterSettingsListRelationFilter
  }

  export type ParametersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    ArrivalItems?: ArrivalItemsOrderByRelationAggregateInput
    QcResults?: QcResultsOrderByRelationAggregateInput
    settings?: ParameterSettingsOrderByRelationAggregateInput
    _relevance?: ParametersOrderByRelevanceInput
  }

  export type ParametersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParametersWhereInput | ParametersWhereInput[]
    OR?: ParametersWhereInput[]
    NOT?: ParametersWhereInput | ParametersWhereInput[]
    name?: StringFilter<"Parameters"> | string
    unit?: StringNullableFilter<"Parameters"> | string | null
    type?: StringNullableFilter<"Parameters"> | string | null
    createdAt?: DateTimeFilter<"Parameters"> | Date | string
    createdBy?: StringNullableFilter<"Parameters"> | string | null
    updatedAt?: DateTimeFilter<"Parameters"> | Date | string
    updatedBy?: StringNullableFilter<"Parameters"> | string | null
    ArrivalItems?: ArrivalItemsListRelationFilter
    QcResults?: QcResultsListRelationFilter
    settings?: ParameterSettingsListRelationFilter
  }, "id">

  export type ParametersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ParametersCountOrderByAggregateInput
    _avg?: ParametersAvgOrderByAggregateInput
    _max?: ParametersMaxOrderByAggregateInput
    _min?: ParametersMinOrderByAggregateInput
    _sum?: ParametersSumOrderByAggregateInput
  }

  export type ParametersScalarWhereWithAggregatesInput = {
    AND?: ParametersScalarWhereWithAggregatesInput | ParametersScalarWhereWithAggregatesInput[]
    OR?: ParametersScalarWhereWithAggregatesInput[]
    NOT?: ParametersScalarWhereWithAggregatesInput | ParametersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Parameters"> | number
    name?: StringWithAggregatesFilter<"Parameters"> | string
    unit?: StringNullableWithAggregatesFilter<"Parameters"> | string | null
    type?: StringNullableWithAggregatesFilter<"Parameters"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Parameters"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Parameters"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Parameters"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Parameters"> | string | null
  }

  export type ArrivalsWhereInput = {
    AND?: ArrivalsWhereInput | ArrivalsWhereInput[]
    OR?: ArrivalsWhereInput[]
    NOT?: ArrivalsWhereInput | ArrivalsWhereInput[]
    id?: IntFilter<"Arrivals"> | number
    idKedatangan?: StringFilter<"Arrivals"> | string
    supplierId?: IntFilter<"Arrivals"> | number
    arrivalDate?: DateTimeFilter<"Arrivals"> | Date | string
    arrivalTime?: StringNullableFilter<"Arrivals"> | string | null
    nopol?: StringNullableFilter<"Arrivals"> | string | null
    suratJalan?: StringNullableFilter<"Arrivals"> | string | null
    city?: StringNullableFilter<"Arrivals"> | string | null
    note?: StringNullableFilter<"Arrivals"> | string | null
    createdAt?: DateTimeFilter<"Arrivals"> | Date | string
    createdBy?: StringNullableFilter<"Arrivals"> | string | null
    updatedAt?: DateTimeFilter<"Arrivals"> | Date | string
    updatedBy?: StringNullableFilter<"Arrivals"> | string | null
    supplier?: XOR<SuppliersScalarRelationFilter, SuppliersWhereInput>
    ArrivalItems?: ArrivalItemsListRelationFilter
    QcHistories?: QcHistoriesListRelationFilter
    SecurityPhotos?: SecurityPhotosListRelationFilter
    ArrivalStatuses?: XOR<ArrivalStatusesNullableScalarRelationFilter, ArrivalStatusesWhereInput> | null
  }

  export type ArrivalsOrderByWithRelationInput = {
    id?: SortOrder
    idKedatangan?: SortOrder
    supplierId?: SortOrder
    arrivalDate?: SortOrder
    arrivalTime?: SortOrderInput | SortOrder
    nopol?: SortOrderInput | SortOrder
    suratJalan?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    supplier?: SuppliersOrderByWithRelationInput
    ArrivalItems?: ArrivalItemsOrderByRelationAggregateInput
    QcHistories?: QcHistoriesOrderByRelationAggregateInput
    SecurityPhotos?: SecurityPhotosOrderByRelationAggregateInput
    ArrivalStatuses?: ArrivalStatusesOrderByWithRelationInput
    _relevance?: ArrivalsOrderByRelevanceInput
  }

  export type ArrivalsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ArrivalsWhereInput | ArrivalsWhereInput[]
    OR?: ArrivalsWhereInput[]
    NOT?: ArrivalsWhereInput | ArrivalsWhereInput[]
    idKedatangan?: StringFilter<"Arrivals"> | string
    supplierId?: IntFilter<"Arrivals"> | number
    arrivalDate?: DateTimeFilter<"Arrivals"> | Date | string
    arrivalTime?: StringNullableFilter<"Arrivals"> | string | null
    nopol?: StringNullableFilter<"Arrivals"> | string | null
    suratJalan?: StringNullableFilter<"Arrivals"> | string | null
    city?: StringNullableFilter<"Arrivals"> | string | null
    note?: StringNullableFilter<"Arrivals"> | string | null
    createdAt?: DateTimeFilter<"Arrivals"> | Date | string
    createdBy?: StringNullableFilter<"Arrivals"> | string | null
    updatedAt?: DateTimeFilter<"Arrivals"> | Date | string
    updatedBy?: StringNullableFilter<"Arrivals"> | string | null
    supplier?: XOR<SuppliersScalarRelationFilter, SuppliersWhereInput>
    ArrivalItems?: ArrivalItemsListRelationFilter
    QcHistories?: QcHistoriesListRelationFilter
    SecurityPhotos?: SecurityPhotosListRelationFilter
    ArrivalStatuses?: XOR<ArrivalStatusesNullableScalarRelationFilter, ArrivalStatusesWhereInput> | null
  }, "id">

  export type ArrivalsOrderByWithAggregationInput = {
    id?: SortOrder
    idKedatangan?: SortOrder
    supplierId?: SortOrder
    arrivalDate?: SortOrder
    arrivalTime?: SortOrderInput | SortOrder
    nopol?: SortOrderInput | SortOrder
    suratJalan?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ArrivalsCountOrderByAggregateInput
    _avg?: ArrivalsAvgOrderByAggregateInput
    _max?: ArrivalsMaxOrderByAggregateInput
    _min?: ArrivalsMinOrderByAggregateInput
    _sum?: ArrivalsSumOrderByAggregateInput
  }

  export type ArrivalsScalarWhereWithAggregatesInput = {
    AND?: ArrivalsScalarWhereWithAggregatesInput | ArrivalsScalarWhereWithAggregatesInput[]
    OR?: ArrivalsScalarWhereWithAggregatesInput[]
    NOT?: ArrivalsScalarWhereWithAggregatesInput | ArrivalsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Arrivals"> | number
    idKedatangan?: StringWithAggregatesFilter<"Arrivals"> | string
    supplierId?: IntWithAggregatesFilter<"Arrivals"> | number
    arrivalDate?: DateTimeWithAggregatesFilter<"Arrivals"> | Date | string
    arrivalTime?: StringNullableWithAggregatesFilter<"Arrivals"> | string | null
    nopol?: StringNullableWithAggregatesFilter<"Arrivals"> | string | null
    suratJalan?: StringNullableWithAggregatesFilter<"Arrivals"> | string | null
    city?: StringNullableWithAggregatesFilter<"Arrivals"> | string | null
    note?: StringNullableWithAggregatesFilter<"Arrivals"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Arrivals"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Arrivals"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Arrivals"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Arrivals"> | string | null
  }

  export type ArrivalItemsWhereInput = {
    AND?: ArrivalItemsWhereInput | ArrivalItemsWhereInput[]
    OR?: ArrivalItemsWhereInput[]
    NOT?: ArrivalItemsWhereInput | ArrivalItemsWhereInput[]
    id?: IntFilter<"ArrivalItems"> | number
    arrivalId?: IntFilter<"ArrivalItems"> | number
    materialId?: IntFilter<"ArrivalItems"> | number
    conditionId?: IntFilter<"ArrivalItems"> | number
    parameterId?: IntNullableFilter<"ArrivalItems"> | number | null
    conditionCategory?: StringNullableFilter<"ArrivalItems"> | string | null
    quantity?: FloatFilter<"ArrivalItems"> | number
    note?: StringNullableFilter<"ArrivalItems"> | string | null
    itemName?: StringNullableFilter<"ArrivalItems"> | string | null
    qcNote?: StringNullableFilter<"ArrivalItems"> | string | null
    qcStatusId?: IntNullableFilter<"ArrivalItems"> | number | null
    qcAnalysis?: StringNullableFilter<"ArrivalItems"> | string | null
    qcSample?: FloatNullableFilter<"ArrivalItems"> | number | null
    qcKotoran?: FloatNullableFilter<"ArrivalItems"> | number | null
    totalBerat?: FloatNullableFilter<"ArrivalItems"> | number | null
    pengeringan?: FloatNullableFilter<"ArrivalItems"> | number | null
    createdAt?: DateTimeFilter<"ArrivalItems"> | Date | string
    createdBy?: StringNullableFilter<"ArrivalItems"> | string | null
    updatedAt?: DateTimeFilter<"ArrivalItems"> | Date | string
    updatedBy?: StringNullableFilter<"ArrivalItems"> | string | null
    statusQc?: BoolFilter<"ArrivalItems"> | boolean
    arrival?: XOR<ArrivalsScalarRelationFilter, ArrivalsWhereInput>
    material?: XOR<MaterialsScalarRelationFilter, MaterialsWhereInput>
    condition?: XOR<ConditionsScalarRelationFilter, ConditionsWhereInput>
    parameter?: XOR<ParametersNullableScalarRelationFilter, ParametersWhereInput> | null
    qcStatus?: XOR<QcStatusNullableScalarRelationFilter, QcStatusWhereInput> | null
    QcResults?: QcResultsListRelationFilter
    QcPhotos?: QcPhotosListRelationFilter
    Weighings?: WeighingsListRelationFilter
    WeighingsPhotos?: WeighingsPhotosListRelationFilter
    QcHistories?: QcHistoriesListRelationFilter
  }

  export type ArrivalItemsOrderByWithRelationInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    materialId?: SortOrder
    conditionId?: SortOrder
    parameterId?: SortOrderInput | SortOrder
    conditionCategory?: SortOrderInput | SortOrder
    quantity?: SortOrder
    note?: SortOrderInput | SortOrder
    itemName?: SortOrderInput | SortOrder
    qcNote?: SortOrderInput | SortOrder
    qcStatusId?: SortOrderInput | SortOrder
    qcAnalysis?: SortOrderInput | SortOrder
    qcSample?: SortOrderInput | SortOrder
    qcKotoran?: SortOrderInput | SortOrder
    totalBerat?: SortOrderInput | SortOrder
    pengeringan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    statusQc?: SortOrder
    arrival?: ArrivalsOrderByWithRelationInput
    material?: MaterialsOrderByWithRelationInput
    condition?: ConditionsOrderByWithRelationInput
    parameter?: ParametersOrderByWithRelationInput
    qcStatus?: QcStatusOrderByWithRelationInput
    QcResults?: QcResultsOrderByRelationAggregateInput
    QcPhotos?: QcPhotosOrderByRelationAggregateInput
    Weighings?: WeighingsOrderByRelationAggregateInput
    WeighingsPhotos?: WeighingsPhotosOrderByRelationAggregateInput
    QcHistories?: QcHistoriesOrderByRelationAggregateInput
    _relevance?: ArrivalItemsOrderByRelevanceInput
  }

  export type ArrivalItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ArrivalItemsWhereInput | ArrivalItemsWhereInput[]
    OR?: ArrivalItemsWhereInput[]
    NOT?: ArrivalItemsWhereInput | ArrivalItemsWhereInput[]
    arrivalId?: IntFilter<"ArrivalItems"> | number
    materialId?: IntFilter<"ArrivalItems"> | number
    conditionId?: IntFilter<"ArrivalItems"> | number
    parameterId?: IntNullableFilter<"ArrivalItems"> | number | null
    conditionCategory?: StringNullableFilter<"ArrivalItems"> | string | null
    quantity?: FloatFilter<"ArrivalItems"> | number
    note?: StringNullableFilter<"ArrivalItems"> | string | null
    itemName?: StringNullableFilter<"ArrivalItems"> | string | null
    qcNote?: StringNullableFilter<"ArrivalItems"> | string | null
    qcStatusId?: IntNullableFilter<"ArrivalItems"> | number | null
    qcAnalysis?: StringNullableFilter<"ArrivalItems"> | string | null
    qcSample?: FloatNullableFilter<"ArrivalItems"> | number | null
    qcKotoran?: FloatNullableFilter<"ArrivalItems"> | number | null
    totalBerat?: FloatNullableFilter<"ArrivalItems"> | number | null
    pengeringan?: FloatNullableFilter<"ArrivalItems"> | number | null
    createdAt?: DateTimeFilter<"ArrivalItems"> | Date | string
    createdBy?: StringNullableFilter<"ArrivalItems"> | string | null
    updatedAt?: DateTimeFilter<"ArrivalItems"> | Date | string
    updatedBy?: StringNullableFilter<"ArrivalItems"> | string | null
    statusQc?: BoolFilter<"ArrivalItems"> | boolean
    arrival?: XOR<ArrivalsScalarRelationFilter, ArrivalsWhereInput>
    material?: XOR<MaterialsScalarRelationFilter, MaterialsWhereInput>
    condition?: XOR<ConditionsScalarRelationFilter, ConditionsWhereInput>
    parameter?: XOR<ParametersNullableScalarRelationFilter, ParametersWhereInput> | null
    qcStatus?: XOR<QcStatusNullableScalarRelationFilter, QcStatusWhereInput> | null
    QcResults?: QcResultsListRelationFilter
    QcPhotos?: QcPhotosListRelationFilter
    Weighings?: WeighingsListRelationFilter
    WeighingsPhotos?: WeighingsPhotosListRelationFilter
    QcHistories?: QcHistoriesListRelationFilter
  }, "id">

  export type ArrivalItemsOrderByWithAggregationInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    materialId?: SortOrder
    conditionId?: SortOrder
    parameterId?: SortOrderInput | SortOrder
    conditionCategory?: SortOrderInput | SortOrder
    quantity?: SortOrder
    note?: SortOrderInput | SortOrder
    itemName?: SortOrderInput | SortOrder
    qcNote?: SortOrderInput | SortOrder
    qcStatusId?: SortOrderInput | SortOrder
    qcAnalysis?: SortOrderInput | SortOrder
    qcSample?: SortOrderInput | SortOrder
    qcKotoran?: SortOrderInput | SortOrder
    totalBerat?: SortOrderInput | SortOrder
    pengeringan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    statusQc?: SortOrder
    _count?: ArrivalItemsCountOrderByAggregateInput
    _avg?: ArrivalItemsAvgOrderByAggregateInput
    _max?: ArrivalItemsMaxOrderByAggregateInput
    _min?: ArrivalItemsMinOrderByAggregateInput
    _sum?: ArrivalItemsSumOrderByAggregateInput
  }

  export type ArrivalItemsScalarWhereWithAggregatesInput = {
    AND?: ArrivalItemsScalarWhereWithAggregatesInput | ArrivalItemsScalarWhereWithAggregatesInput[]
    OR?: ArrivalItemsScalarWhereWithAggregatesInput[]
    NOT?: ArrivalItemsScalarWhereWithAggregatesInput | ArrivalItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ArrivalItems"> | number
    arrivalId?: IntWithAggregatesFilter<"ArrivalItems"> | number
    materialId?: IntWithAggregatesFilter<"ArrivalItems"> | number
    conditionId?: IntWithAggregatesFilter<"ArrivalItems"> | number
    parameterId?: IntNullableWithAggregatesFilter<"ArrivalItems"> | number | null
    conditionCategory?: StringNullableWithAggregatesFilter<"ArrivalItems"> | string | null
    quantity?: FloatWithAggregatesFilter<"ArrivalItems"> | number
    note?: StringNullableWithAggregatesFilter<"ArrivalItems"> | string | null
    itemName?: StringNullableWithAggregatesFilter<"ArrivalItems"> | string | null
    qcNote?: StringNullableWithAggregatesFilter<"ArrivalItems"> | string | null
    qcStatusId?: IntNullableWithAggregatesFilter<"ArrivalItems"> | number | null
    qcAnalysis?: StringNullableWithAggregatesFilter<"ArrivalItems"> | string | null
    qcSample?: FloatNullableWithAggregatesFilter<"ArrivalItems"> | number | null
    qcKotoran?: FloatNullableWithAggregatesFilter<"ArrivalItems"> | number | null
    totalBerat?: FloatNullableWithAggregatesFilter<"ArrivalItems"> | number | null
    pengeringan?: FloatNullableWithAggregatesFilter<"ArrivalItems"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ArrivalItems"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"ArrivalItems"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"ArrivalItems"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"ArrivalItems"> | string | null
    statusQc?: BoolWithAggregatesFilter<"ArrivalItems"> | boolean
  }

  export type WeighingsWhereInput = {
    AND?: WeighingsWhereInput | WeighingsWhereInput[]
    OR?: WeighingsWhereInput[]
    NOT?: WeighingsWhereInput | WeighingsWhereInput[]
    id?: IntFilter<"Weighings"> | number
    arrivalItemId?: IntFilter<"Weighings"> | number
    weight?: FloatFilter<"Weighings"> | number
    note?: StringNullableFilter<"Weighings"> | string | null
    weighingDate?: DateTimeFilter<"Weighings"> | Date | string
    createdAt?: DateTimeFilter<"Weighings"> | Date | string
    createdBy?: StringNullableFilter<"Weighings"> | string | null
    updatedAt?: DateTimeFilter<"Weighings"> | Date | string
    updatedBy?: StringNullableFilter<"Weighings"> | string | null
    arrivalItem?: XOR<ArrivalItemsScalarRelationFilter, ArrivalItemsWhereInput>
  }

  export type WeighingsOrderByWithRelationInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    weight?: SortOrder
    note?: SortOrderInput | SortOrder
    weighingDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    arrivalItem?: ArrivalItemsOrderByWithRelationInput
    _relevance?: WeighingsOrderByRelevanceInput
  }

  export type WeighingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WeighingsWhereInput | WeighingsWhereInput[]
    OR?: WeighingsWhereInput[]
    NOT?: WeighingsWhereInput | WeighingsWhereInput[]
    arrivalItemId?: IntFilter<"Weighings"> | number
    weight?: FloatFilter<"Weighings"> | number
    note?: StringNullableFilter<"Weighings"> | string | null
    weighingDate?: DateTimeFilter<"Weighings"> | Date | string
    createdAt?: DateTimeFilter<"Weighings"> | Date | string
    createdBy?: StringNullableFilter<"Weighings"> | string | null
    updatedAt?: DateTimeFilter<"Weighings"> | Date | string
    updatedBy?: StringNullableFilter<"Weighings"> | string | null
    arrivalItem?: XOR<ArrivalItemsScalarRelationFilter, ArrivalItemsWhereInput>
  }, "id">

  export type WeighingsOrderByWithAggregationInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    weight?: SortOrder
    note?: SortOrderInput | SortOrder
    weighingDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: WeighingsCountOrderByAggregateInput
    _avg?: WeighingsAvgOrderByAggregateInput
    _max?: WeighingsMaxOrderByAggregateInput
    _min?: WeighingsMinOrderByAggregateInput
    _sum?: WeighingsSumOrderByAggregateInput
  }

  export type WeighingsScalarWhereWithAggregatesInput = {
    AND?: WeighingsScalarWhereWithAggregatesInput | WeighingsScalarWhereWithAggregatesInput[]
    OR?: WeighingsScalarWhereWithAggregatesInput[]
    NOT?: WeighingsScalarWhereWithAggregatesInput | WeighingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Weighings"> | number
    arrivalItemId?: IntWithAggregatesFilter<"Weighings"> | number
    weight?: FloatWithAggregatesFilter<"Weighings"> | number
    note?: StringNullableWithAggregatesFilter<"Weighings"> | string | null
    weighingDate?: DateTimeWithAggregatesFilter<"Weighings"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Weighings"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Weighings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Weighings"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Weighings"> | string | null
  }

  export type NotificationsWhereInput = {
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    id?: IntFilter<"Notifications"> | number
    table?: StringFilter<"Notifications"> | string
    description?: StringNullableFilter<"Notifications"> | string | null
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    table?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: NotificationsOrderByRelevanceInput
  }

  export type NotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    table?: StringFilter<"Notifications"> | string
    description?: StringNullableFilter<"Notifications"> | string | null
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
  }, "id">

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    table?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _avg?: NotificationsAvgOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
    _sum?: NotificationsSumOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    OR?: NotificationsScalarWhereWithAggregatesInput[]
    NOT?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notifications"> | number
    table?: StringWithAggregatesFilter<"Notifications"> | string
    description?: StringNullableWithAggregatesFilter<"Notifications"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notifications"> | Date | string
  }

  export type QcResultsWhereInput = {
    AND?: QcResultsWhereInput | QcResultsWhereInput[]
    OR?: QcResultsWhereInput[]
    NOT?: QcResultsWhereInput | QcResultsWhereInput[]
    id?: IntFilter<"QcResults"> | number
    arrivalItemId?: IntFilter<"QcResults"> | number
    parameterId?: IntFilter<"QcResults"> | number
    historyId?: IntNullableFilter<"QcResults"> | number | null
    resultKey?: StringFilter<"QcResults"> | string
    value?: StringFilter<"QcResults"> | string
    createdAt?: DateTimeFilter<"QcResults"> | Date | string
    createdBy?: StringNullableFilter<"QcResults"> | string | null
    updatedAt?: DateTimeFilter<"QcResults"> | Date | string
    updatedBy?: StringNullableFilter<"QcResults"> | string | null
    arrivalItem?: XOR<ArrivalItemsScalarRelationFilter, ArrivalItemsWhereInput>
    parameter?: XOR<ParametersNullableScalarRelationFilter, ParametersWhereInput> | null
    history?: XOR<QcHistoriesNullableScalarRelationFilter, QcHistoriesWhereInput> | null
  }

  export type QcResultsOrderByWithRelationInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    parameterId?: SortOrder
    historyId?: SortOrderInput | SortOrder
    resultKey?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    arrivalItem?: ArrivalItemsOrderByWithRelationInput
    parameter?: ParametersOrderByWithRelationInput
    history?: QcHistoriesOrderByWithRelationInput
    _relevance?: QcResultsOrderByRelevanceInput
  }

  export type QcResultsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QcResultsWhereInput | QcResultsWhereInput[]
    OR?: QcResultsWhereInput[]
    NOT?: QcResultsWhereInput | QcResultsWhereInput[]
    arrivalItemId?: IntFilter<"QcResults"> | number
    parameterId?: IntFilter<"QcResults"> | number
    historyId?: IntNullableFilter<"QcResults"> | number | null
    resultKey?: StringFilter<"QcResults"> | string
    value?: StringFilter<"QcResults"> | string
    createdAt?: DateTimeFilter<"QcResults"> | Date | string
    createdBy?: StringNullableFilter<"QcResults"> | string | null
    updatedAt?: DateTimeFilter<"QcResults"> | Date | string
    updatedBy?: StringNullableFilter<"QcResults"> | string | null
    arrivalItem?: XOR<ArrivalItemsScalarRelationFilter, ArrivalItemsWhereInput>
    parameter?: XOR<ParametersNullableScalarRelationFilter, ParametersWhereInput> | null
    history?: XOR<QcHistoriesNullableScalarRelationFilter, QcHistoriesWhereInput> | null
  }, "id">

  export type QcResultsOrderByWithAggregationInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    parameterId?: SortOrder
    historyId?: SortOrderInput | SortOrder
    resultKey?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: QcResultsCountOrderByAggregateInput
    _avg?: QcResultsAvgOrderByAggregateInput
    _max?: QcResultsMaxOrderByAggregateInput
    _min?: QcResultsMinOrderByAggregateInput
    _sum?: QcResultsSumOrderByAggregateInput
  }

  export type QcResultsScalarWhereWithAggregatesInput = {
    AND?: QcResultsScalarWhereWithAggregatesInput | QcResultsScalarWhereWithAggregatesInput[]
    OR?: QcResultsScalarWhereWithAggregatesInput[]
    NOT?: QcResultsScalarWhereWithAggregatesInput | QcResultsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QcResults"> | number
    arrivalItemId?: IntWithAggregatesFilter<"QcResults"> | number
    parameterId?: IntWithAggregatesFilter<"QcResults"> | number
    historyId?: IntNullableWithAggregatesFilter<"QcResults"> | number | null
    resultKey?: StringWithAggregatesFilter<"QcResults"> | string
    value?: StringWithAggregatesFilter<"QcResults"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QcResults"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"QcResults"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"QcResults"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"QcResults"> | string | null
  }

  export type QcStatusWhereInput = {
    AND?: QcStatusWhereInput | QcStatusWhereInput[]
    OR?: QcStatusWhereInput[]
    NOT?: QcStatusWhereInput | QcStatusWhereInput[]
    id?: IntFilter<"QcStatus"> | number
    name?: StringFilter<"QcStatus"> | string
    description?: StringNullableFilter<"QcStatus"> | string | null
    ArrivalItems?: ArrivalItemsListRelationFilter
    QcHistories?: QcHistoriesListRelationFilter
  }

  export type QcStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ArrivalItems?: ArrivalItemsOrderByRelationAggregateInput
    QcHistories?: QcHistoriesOrderByRelationAggregateInput
    _relevance?: QcStatusOrderByRelevanceInput
  }

  export type QcStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QcStatusWhereInput | QcStatusWhereInput[]
    OR?: QcStatusWhereInput[]
    NOT?: QcStatusWhereInput | QcStatusWhereInput[]
    name?: StringFilter<"QcStatus"> | string
    description?: StringNullableFilter<"QcStatus"> | string | null
    ArrivalItems?: ArrivalItemsListRelationFilter
    QcHistories?: QcHistoriesListRelationFilter
  }, "id">

  export type QcStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: QcStatusCountOrderByAggregateInput
    _avg?: QcStatusAvgOrderByAggregateInput
    _max?: QcStatusMaxOrderByAggregateInput
    _min?: QcStatusMinOrderByAggregateInput
    _sum?: QcStatusSumOrderByAggregateInput
  }

  export type QcStatusScalarWhereWithAggregatesInput = {
    AND?: QcStatusScalarWhereWithAggregatesInput | QcStatusScalarWhereWithAggregatesInput[]
    OR?: QcStatusScalarWhereWithAggregatesInput[]
    NOT?: QcStatusScalarWhereWithAggregatesInput | QcStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QcStatus"> | number
    name?: StringWithAggregatesFilter<"QcStatus"> | string
    description?: StringNullableWithAggregatesFilter<"QcStatus"> | string | null
  }

  export type QcPhotosWhereInput = {
    AND?: QcPhotosWhereInput | QcPhotosWhereInput[]
    OR?: QcPhotosWhereInput[]
    NOT?: QcPhotosWhereInput | QcPhotosWhereInput[]
    id?: IntFilter<"QcPhotos"> | number
    arrivalItemId?: IntFilter<"QcPhotos"> | number
    photo?: StringFilter<"QcPhotos"> | string
    createdAt?: DateTimeFilter<"QcPhotos"> | Date | string
    createdBy?: StringNullableFilter<"QcPhotos"> | string | null
    updatedAt?: DateTimeFilter<"QcPhotos"> | Date | string
    updatedBy?: StringNullableFilter<"QcPhotos"> | string | null
    arrivalItem?: XOR<ArrivalItemsScalarRelationFilter, ArrivalItemsWhereInput>
  }

  export type QcPhotosOrderByWithRelationInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    arrivalItem?: ArrivalItemsOrderByWithRelationInput
    _relevance?: QcPhotosOrderByRelevanceInput
  }

  export type QcPhotosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QcPhotosWhereInput | QcPhotosWhereInput[]
    OR?: QcPhotosWhereInput[]
    NOT?: QcPhotosWhereInput | QcPhotosWhereInput[]
    arrivalItemId?: IntFilter<"QcPhotos"> | number
    photo?: StringFilter<"QcPhotos"> | string
    createdAt?: DateTimeFilter<"QcPhotos"> | Date | string
    createdBy?: StringNullableFilter<"QcPhotos"> | string | null
    updatedAt?: DateTimeFilter<"QcPhotos"> | Date | string
    updatedBy?: StringNullableFilter<"QcPhotos"> | string | null
    arrivalItem?: XOR<ArrivalItemsScalarRelationFilter, ArrivalItemsWhereInput>
  }, "id">

  export type QcPhotosOrderByWithAggregationInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: QcPhotosCountOrderByAggregateInput
    _avg?: QcPhotosAvgOrderByAggregateInput
    _max?: QcPhotosMaxOrderByAggregateInput
    _min?: QcPhotosMinOrderByAggregateInput
    _sum?: QcPhotosSumOrderByAggregateInput
  }

  export type QcPhotosScalarWhereWithAggregatesInput = {
    AND?: QcPhotosScalarWhereWithAggregatesInput | QcPhotosScalarWhereWithAggregatesInput[]
    OR?: QcPhotosScalarWhereWithAggregatesInput[]
    NOT?: QcPhotosScalarWhereWithAggregatesInput | QcPhotosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QcPhotos"> | number
    arrivalItemId?: IntWithAggregatesFilter<"QcPhotos"> | number
    photo?: StringWithAggregatesFilter<"QcPhotos"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QcPhotos"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"QcPhotos"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"QcPhotos"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"QcPhotos"> | string | null
  }

  export type SecurityPhotosWhereInput = {
    AND?: SecurityPhotosWhereInput | SecurityPhotosWhereInput[]
    OR?: SecurityPhotosWhereInput[]
    NOT?: SecurityPhotosWhereInput | SecurityPhotosWhereInput[]
    id?: IntFilter<"SecurityPhotos"> | number
    arrivalId?: IntFilter<"SecurityPhotos"> | number
    photo?: StringFilter<"SecurityPhotos"> | string
    createdAt?: DateTimeFilter<"SecurityPhotos"> | Date | string
    createdBy?: StringNullableFilter<"SecurityPhotos"> | string | null
    updatedAt?: DateTimeFilter<"SecurityPhotos"> | Date | string
    updatedBy?: StringNullableFilter<"SecurityPhotos"> | string | null
    arrival?: XOR<ArrivalsScalarRelationFilter, ArrivalsWhereInput>
  }

  export type SecurityPhotosOrderByWithRelationInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    arrival?: ArrivalsOrderByWithRelationInput
    _relevance?: SecurityPhotosOrderByRelevanceInput
  }

  export type SecurityPhotosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SecurityPhotosWhereInput | SecurityPhotosWhereInput[]
    OR?: SecurityPhotosWhereInput[]
    NOT?: SecurityPhotosWhereInput | SecurityPhotosWhereInput[]
    arrivalId?: IntFilter<"SecurityPhotos"> | number
    photo?: StringFilter<"SecurityPhotos"> | string
    createdAt?: DateTimeFilter<"SecurityPhotos"> | Date | string
    createdBy?: StringNullableFilter<"SecurityPhotos"> | string | null
    updatedAt?: DateTimeFilter<"SecurityPhotos"> | Date | string
    updatedBy?: StringNullableFilter<"SecurityPhotos"> | string | null
    arrival?: XOR<ArrivalsScalarRelationFilter, ArrivalsWhereInput>
  }, "id">

  export type SecurityPhotosOrderByWithAggregationInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SecurityPhotosCountOrderByAggregateInput
    _avg?: SecurityPhotosAvgOrderByAggregateInput
    _max?: SecurityPhotosMaxOrderByAggregateInput
    _min?: SecurityPhotosMinOrderByAggregateInput
    _sum?: SecurityPhotosSumOrderByAggregateInput
  }

  export type SecurityPhotosScalarWhereWithAggregatesInput = {
    AND?: SecurityPhotosScalarWhereWithAggregatesInput | SecurityPhotosScalarWhereWithAggregatesInput[]
    OR?: SecurityPhotosScalarWhereWithAggregatesInput[]
    NOT?: SecurityPhotosScalarWhereWithAggregatesInput | SecurityPhotosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SecurityPhotos"> | number
    arrivalId?: IntWithAggregatesFilter<"SecurityPhotos"> | number
    photo?: StringWithAggregatesFilter<"SecurityPhotos"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SecurityPhotos"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"SecurityPhotos"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SecurityPhotos"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"SecurityPhotos"> | string | null
  }

  export type WeighingsPhotosWhereInput = {
    AND?: WeighingsPhotosWhereInput | WeighingsPhotosWhereInput[]
    OR?: WeighingsPhotosWhereInput[]
    NOT?: WeighingsPhotosWhereInput | WeighingsPhotosWhereInput[]
    id?: IntFilter<"WeighingsPhotos"> | number
    arrivalItemId?: IntFilter<"WeighingsPhotos"> | number
    photo?: StringFilter<"WeighingsPhotos"> | string
    createdAt?: DateTimeFilter<"WeighingsPhotos"> | Date | string
    createdBy?: StringNullableFilter<"WeighingsPhotos"> | string | null
    updatedAt?: DateTimeFilter<"WeighingsPhotos"> | Date | string
    updatedBy?: StringNullableFilter<"WeighingsPhotos"> | string | null
    arrivalItem?: XOR<ArrivalItemsScalarRelationFilter, ArrivalItemsWhereInput>
  }

  export type WeighingsPhotosOrderByWithRelationInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    arrivalItem?: ArrivalItemsOrderByWithRelationInput
    _relevance?: WeighingsPhotosOrderByRelevanceInput
  }

  export type WeighingsPhotosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WeighingsPhotosWhereInput | WeighingsPhotosWhereInput[]
    OR?: WeighingsPhotosWhereInput[]
    NOT?: WeighingsPhotosWhereInput | WeighingsPhotosWhereInput[]
    arrivalItemId?: IntFilter<"WeighingsPhotos"> | number
    photo?: StringFilter<"WeighingsPhotos"> | string
    createdAt?: DateTimeFilter<"WeighingsPhotos"> | Date | string
    createdBy?: StringNullableFilter<"WeighingsPhotos"> | string | null
    updatedAt?: DateTimeFilter<"WeighingsPhotos"> | Date | string
    updatedBy?: StringNullableFilter<"WeighingsPhotos"> | string | null
    arrivalItem?: XOR<ArrivalItemsScalarRelationFilter, ArrivalItemsWhereInput>
  }, "id">

  export type WeighingsPhotosOrderByWithAggregationInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: WeighingsPhotosCountOrderByAggregateInput
    _avg?: WeighingsPhotosAvgOrderByAggregateInput
    _max?: WeighingsPhotosMaxOrderByAggregateInput
    _min?: WeighingsPhotosMinOrderByAggregateInput
    _sum?: WeighingsPhotosSumOrderByAggregateInput
  }

  export type WeighingsPhotosScalarWhereWithAggregatesInput = {
    AND?: WeighingsPhotosScalarWhereWithAggregatesInput | WeighingsPhotosScalarWhereWithAggregatesInput[]
    OR?: WeighingsPhotosScalarWhereWithAggregatesInput[]
    NOT?: WeighingsPhotosScalarWhereWithAggregatesInput | WeighingsPhotosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WeighingsPhotos"> | number
    arrivalItemId?: IntWithAggregatesFilter<"WeighingsPhotos"> | number
    photo?: StringWithAggregatesFilter<"WeighingsPhotos"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WeighingsPhotos"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"WeighingsPhotos"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"WeighingsPhotos"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"WeighingsPhotos"> | string | null
  }

  export type QcHistoriesWhereInput = {
    AND?: QcHistoriesWhereInput | QcHistoriesWhereInput[]
    OR?: QcHistoriesWhereInput[]
    NOT?: QcHistoriesWhereInput | QcHistoriesWhereInput[]
    id?: IntFilter<"QcHistories"> | number
    userId?: StringFilter<"QcHistories"> | string
    statusId?: IntFilter<"QcHistories"> | number
    arrivalId?: IntNullableFilter<"QcHistories"> | number | null
    arrivalItemId?: IntNullableFilter<"QcHistories"> | number | null
    qcSample?: FloatNullableFilter<"QcHistories"> | number | null
    qcKotoran?: FloatNullableFilter<"QcHistories"> | number | null
    totalBerat?: FloatNullableFilter<"QcHistories"> | number | null
    pengeringan?: FloatNullableFilter<"QcHistories"> | number | null
    note?: StringNullableFilter<"QcHistories"> | string | null
    qcNote?: StringNullableFilter<"QcHistories"> | string | null
    createdAt?: DateTimeFilter<"QcHistories"> | Date | string
    updatedAt?: DateTimeFilter<"QcHistories"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    status?: XOR<QcStatusScalarRelationFilter, QcStatusWhereInput>
    arrival?: XOR<ArrivalsNullableScalarRelationFilter, ArrivalsWhereInput> | null
    arrivalItem?: XOR<ArrivalItemsNullableScalarRelationFilter, ArrivalItemsWhereInput> | null
    QcResults?: QcResultsListRelationFilter
  }

  export type QcHistoriesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    statusId?: SortOrder
    arrivalId?: SortOrderInput | SortOrder
    arrivalItemId?: SortOrderInput | SortOrder
    qcSample?: SortOrderInput | SortOrder
    qcKotoran?: SortOrderInput | SortOrder
    totalBerat?: SortOrderInput | SortOrder
    pengeringan?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    qcNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    status?: QcStatusOrderByWithRelationInput
    arrival?: ArrivalsOrderByWithRelationInput
    arrivalItem?: ArrivalItemsOrderByWithRelationInput
    QcResults?: QcResultsOrderByRelationAggregateInput
    _relevance?: QcHistoriesOrderByRelevanceInput
  }

  export type QcHistoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QcHistoriesWhereInput | QcHistoriesWhereInput[]
    OR?: QcHistoriesWhereInput[]
    NOT?: QcHistoriesWhereInput | QcHistoriesWhereInput[]
    userId?: StringFilter<"QcHistories"> | string
    statusId?: IntFilter<"QcHistories"> | number
    arrivalId?: IntNullableFilter<"QcHistories"> | number | null
    arrivalItemId?: IntNullableFilter<"QcHistories"> | number | null
    qcSample?: FloatNullableFilter<"QcHistories"> | number | null
    qcKotoran?: FloatNullableFilter<"QcHistories"> | number | null
    totalBerat?: FloatNullableFilter<"QcHistories"> | number | null
    pengeringan?: FloatNullableFilter<"QcHistories"> | number | null
    note?: StringNullableFilter<"QcHistories"> | string | null
    qcNote?: StringNullableFilter<"QcHistories"> | string | null
    createdAt?: DateTimeFilter<"QcHistories"> | Date | string
    updatedAt?: DateTimeFilter<"QcHistories"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    status?: XOR<QcStatusScalarRelationFilter, QcStatusWhereInput>
    arrival?: XOR<ArrivalsNullableScalarRelationFilter, ArrivalsWhereInput> | null
    arrivalItem?: XOR<ArrivalItemsNullableScalarRelationFilter, ArrivalItemsWhereInput> | null
    QcResults?: QcResultsListRelationFilter
  }, "id">

  export type QcHistoriesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    statusId?: SortOrder
    arrivalId?: SortOrderInput | SortOrder
    arrivalItemId?: SortOrderInput | SortOrder
    qcSample?: SortOrderInput | SortOrder
    qcKotoran?: SortOrderInput | SortOrder
    totalBerat?: SortOrderInput | SortOrder
    pengeringan?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    qcNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QcHistoriesCountOrderByAggregateInput
    _avg?: QcHistoriesAvgOrderByAggregateInput
    _max?: QcHistoriesMaxOrderByAggregateInput
    _min?: QcHistoriesMinOrderByAggregateInput
    _sum?: QcHistoriesSumOrderByAggregateInput
  }

  export type QcHistoriesScalarWhereWithAggregatesInput = {
    AND?: QcHistoriesScalarWhereWithAggregatesInput | QcHistoriesScalarWhereWithAggregatesInput[]
    OR?: QcHistoriesScalarWhereWithAggregatesInput[]
    NOT?: QcHistoriesScalarWhereWithAggregatesInput | QcHistoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QcHistories"> | number
    userId?: StringWithAggregatesFilter<"QcHistories"> | string
    statusId?: IntWithAggregatesFilter<"QcHistories"> | number
    arrivalId?: IntNullableWithAggregatesFilter<"QcHistories"> | number | null
    arrivalItemId?: IntNullableWithAggregatesFilter<"QcHistories"> | number | null
    qcSample?: FloatNullableWithAggregatesFilter<"QcHistories"> | number | null
    qcKotoran?: FloatNullableWithAggregatesFilter<"QcHistories"> | number | null
    totalBerat?: FloatNullableWithAggregatesFilter<"QcHistories"> | number | null
    pengeringan?: FloatNullableWithAggregatesFilter<"QcHistories"> | number | null
    note?: StringNullableWithAggregatesFilter<"QcHistories"> | string | null
    qcNote?: StringNullableWithAggregatesFilter<"QcHistories"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QcHistories"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QcHistories"> | Date | string
  }

  export type ArrivalStatusesWhereInput = {
    AND?: ArrivalStatusesWhereInput | ArrivalStatusesWhereInput[]
    OR?: ArrivalStatusesWhereInput[]
    NOT?: ArrivalStatusesWhereInput | ArrivalStatusesWhereInput[]
    id?: IntFilter<"ArrivalStatuses"> | number
    arrivalId?: IntFilter<"ArrivalStatuses"> | number
    status?: StringFilter<"ArrivalStatuses"> | string
    statusQc?: StringNullableFilter<"ArrivalStatuses"> | string | null
    statusWeighing?: StringNullableFilter<"ArrivalStatuses"> | string | null
    statusApproval?: StringNullableFilter<"ArrivalStatuses"> | string | null
    createdAt?: DateTimeFilter<"ArrivalStatuses"> | Date | string
    createdBy?: StringNullableFilter<"ArrivalStatuses"> | string | null
    updatedAt?: DateTimeFilter<"ArrivalStatuses"> | Date | string
    updatedBy?: StringNullableFilter<"ArrivalStatuses"> | string | null
    arrival?: XOR<ArrivalsScalarRelationFilter, ArrivalsWhereInput>
  }

  export type ArrivalStatusesOrderByWithRelationInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    status?: SortOrder
    statusQc?: SortOrderInput | SortOrder
    statusWeighing?: SortOrderInput | SortOrder
    statusApproval?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    arrival?: ArrivalsOrderByWithRelationInput
    _relevance?: ArrivalStatusesOrderByRelevanceInput
  }

  export type ArrivalStatusesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    arrivalId?: number
    AND?: ArrivalStatusesWhereInput | ArrivalStatusesWhereInput[]
    OR?: ArrivalStatusesWhereInput[]
    NOT?: ArrivalStatusesWhereInput | ArrivalStatusesWhereInput[]
    status?: StringFilter<"ArrivalStatuses"> | string
    statusQc?: StringNullableFilter<"ArrivalStatuses"> | string | null
    statusWeighing?: StringNullableFilter<"ArrivalStatuses"> | string | null
    statusApproval?: StringNullableFilter<"ArrivalStatuses"> | string | null
    createdAt?: DateTimeFilter<"ArrivalStatuses"> | Date | string
    createdBy?: StringNullableFilter<"ArrivalStatuses"> | string | null
    updatedAt?: DateTimeFilter<"ArrivalStatuses"> | Date | string
    updatedBy?: StringNullableFilter<"ArrivalStatuses"> | string | null
    arrival?: XOR<ArrivalsScalarRelationFilter, ArrivalsWhereInput>
  }, "id" | "arrivalId">

  export type ArrivalStatusesOrderByWithAggregationInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    status?: SortOrder
    statusQc?: SortOrderInput | SortOrder
    statusWeighing?: SortOrderInput | SortOrder
    statusApproval?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ArrivalStatusesCountOrderByAggregateInput
    _avg?: ArrivalStatusesAvgOrderByAggregateInput
    _max?: ArrivalStatusesMaxOrderByAggregateInput
    _min?: ArrivalStatusesMinOrderByAggregateInput
    _sum?: ArrivalStatusesSumOrderByAggregateInput
  }

  export type ArrivalStatusesScalarWhereWithAggregatesInput = {
    AND?: ArrivalStatusesScalarWhereWithAggregatesInput | ArrivalStatusesScalarWhereWithAggregatesInput[]
    OR?: ArrivalStatusesScalarWhereWithAggregatesInput[]
    NOT?: ArrivalStatusesScalarWhereWithAggregatesInput | ArrivalStatusesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ArrivalStatuses"> | number
    arrivalId?: IntWithAggregatesFilter<"ArrivalStatuses"> | number
    status?: StringWithAggregatesFilter<"ArrivalStatuses"> | string
    statusQc?: StringNullableWithAggregatesFilter<"ArrivalStatuses"> | string | null
    statusWeighing?: StringNullableWithAggregatesFilter<"ArrivalStatuses"> | string | null
    statusApproval?: StringNullableWithAggregatesFilter<"ArrivalStatuses"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ArrivalStatuses"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"ArrivalStatuses"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"ArrivalStatuses"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"ArrivalStatuses"> | string | null
  }

  export type ParameterSettingsWhereInput = {
    AND?: ParameterSettingsWhereInput | ParameterSettingsWhereInput[]
    OR?: ParameterSettingsWhereInput[]
    NOT?: ParameterSettingsWhereInput | ParameterSettingsWhereInput[]
    id?: IntFilter<"ParameterSettings"> | number
    parameterId?: IntFilter<"ParameterSettings"> | number
    key?: StringFilter<"ParameterSettings"> | string
    value?: StringFilter<"ParameterSettings"> | string
    createdAt?: DateTimeFilter<"ParameterSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ParameterSettings"> | Date | string
    createdBy?: StringNullableFilter<"ParameterSettings"> | string | null
    updatedBy?: StringNullableFilter<"ParameterSettings"> | string | null
    parameter?: XOR<ParametersScalarRelationFilter, ParametersWhereInput>
  }

  export type ParameterSettingsOrderByWithRelationInput = {
    id?: SortOrder
    parameterId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    parameter?: ParametersOrderByWithRelationInput
    _relevance?: ParameterSettingsOrderByRelevanceInput
  }

  export type ParameterSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    parameterId_key?: ParameterSettingsParameterIdKeyCompoundUniqueInput
    AND?: ParameterSettingsWhereInput | ParameterSettingsWhereInput[]
    OR?: ParameterSettingsWhereInput[]
    NOT?: ParameterSettingsWhereInput | ParameterSettingsWhereInput[]
    parameterId?: IntFilter<"ParameterSettings"> | number
    key?: StringFilter<"ParameterSettings"> | string
    value?: StringFilter<"ParameterSettings"> | string
    createdAt?: DateTimeFilter<"ParameterSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ParameterSettings"> | Date | string
    createdBy?: StringNullableFilter<"ParameterSettings"> | string | null
    updatedBy?: StringNullableFilter<"ParameterSettings"> | string | null
    parameter?: XOR<ParametersScalarRelationFilter, ParametersWhereInput>
  }, "id" | "parameterId_key">

  export type ParameterSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    parameterId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ParameterSettingsCountOrderByAggregateInput
    _avg?: ParameterSettingsAvgOrderByAggregateInput
    _max?: ParameterSettingsMaxOrderByAggregateInput
    _min?: ParameterSettingsMinOrderByAggregateInput
    _sum?: ParameterSettingsSumOrderByAggregateInput
  }

  export type ParameterSettingsScalarWhereWithAggregatesInput = {
    AND?: ParameterSettingsScalarWhereWithAggregatesInput | ParameterSettingsScalarWhereWithAggregatesInput[]
    OR?: ParameterSettingsScalarWhereWithAggregatesInput[]
    NOT?: ParameterSettingsScalarWhereWithAggregatesInput | ParameterSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParameterSettings"> | number
    parameterId?: IntWithAggregatesFilter<"ParameterSettings"> | number
    key?: StringWithAggregatesFilter<"ParameterSettings"> | string
    value?: StringWithAggregatesFilter<"ParameterSettings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ParameterSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ParameterSettings"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"ParameterSettings"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"ParameterSettings"> | string | null
  }

  export type UsersCreateInput = {
    username: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    createdBy?: string | null
    updatedBy?: string | null
    QcHistories?: QcHistoriesCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateInput = {
    username: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    createdBy?: string | null
    updatedBy?: string | null
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    QcHistories?: QcHistoriesUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersCreateManyInput = {
    username: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type UsersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuppliersCreateInput = {
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    Arrivals?: ArrivalsCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    Arrivals?: ArrivalsUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    Arrivals?: ArrivalsUpdateManyWithoutSupplierNestedInput
  }

  export type SuppliersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    Arrivals?: ArrivalsUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SuppliersCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SuppliersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuppliersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialsCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutMaterialInput
  }

  export type MaterialsUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialsCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type MaterialsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionsCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutConditionInput
  }

  export type ConditionsUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutConditionInput
  }

  export type ConditionsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUpdateManyWithoutConditionNestedInput
  }

  export type ConditionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutConditionNestedInput
  }

  export type ConditionsCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ConditionsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParametersCreateInput = {
    name: string
    unit?: string | null
    type?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutParameterInput
    QcResults?: QcResultsCreateNestedManyWithoutParameterInput
    settings?: ParameterSettingsCreateNestedManyWithoutParameterInput
  }

  export type ParametersUncheckedCreateInput = {
    id?: number
    name: string
    unit?: string | null
    type?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutParameterInput
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutParameterInput
    settings?: ParameterSettingsUncheckedCreateNestedManyWithoutParameterInput
  }

  export type ParametersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUpdateManyWithoutParameterNestedInput
    QcResults?: QcResultsUpdateManyWithoutParameterNestedInput
    settings?: ParameterSettingsUpdateManyWithoutParameterNestedInput
  }

  export type ParametersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutParameterNestedInput
    QcResults?: QcResultsUncheckedUpdateManyWithoutParameterNestedInput
    settings?: ParameterSettingsUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type ParametersCreateManyInput = {
    id?: number
    name: string
    unit?: string | null
    type?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ParametersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParametersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArrivalsCreateInput = {
    idKedatangan: string
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    supplier: SuppliersCreateNestedOneWithoutArrivalsInput
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutArrivalInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalInput
    SecurityPhotos?: SecurityPhotosCreateNestedManyWithoutArrivalInput
    ArrivalStatuses?: ArrivalStatusesCreateNestedOneWithoutArrivalInput
  }

  export type ArrivalsUncheckedCreateInput = {
    id?: number
    idKedatangan: string
    supplierId: number
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutArrivalInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalInput
    SecurityPhotos?: SecurityPhotosUncheckedCreateNestedManyWithoutArrivalInput
    ArrivalStatuses?: ArrivalStatusesUncheckedCreateNestedOneWithoutArrivalInput
  }

  export type ArrivalsUpdateInput = {
    idKedatangan?: StringFieldUpdateOperationsInput | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: SuppliersUpdateOneRequiredWithoutArrivalsNestedInput
    ArrivalItems?: ArrivalItemsUpdateManyWithoutArrivalNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalNestedInput
    SecurityPhotos?: SecurityPhotosUpdateManyWithoutArrivalNestedInput
    ArrivalStatuses?: ArrivalStatusesUpdateOneWithoutArrivalNestedInput
  }

  export type ArrivalsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idKedatangan?: StringFieldUpdateOperationsInput | string
    supplierId?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutArrivalNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalNestedInput
    SecurityPhotos?: SecurityPhotosUncheckedUpdateManyWithoutArrivalNestedInput
    ArrivalStatuses?: ArrivalStatusesUncheckedUpdateOneWithoutArrivalNestedInput
  }

  export type ArrivalsCreateManyInput = {
    id?: number
    idKedatangan: string
    supplierId: number
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ArrivalsUpdateManyMutationInput = {
    idKedatangan?: StringFieldUpdateOperationsInput | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArrivalsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idKedatangan?: StringFieldUpdateOperationsInput | string
    supplierId?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArrivalItemsCreateInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    arrival: ArrivalsCreateNestedOneWithoutArrivalItemsInput
    material: MaterialsCreateNestedOneWithoutArrivalItemsInput
    condition: ConditionsCreateNestedOneWithoutArrivalItemsInput
    parameter?: ParametersCreateNestedOneWithoutArrivalItemsInput
    qcStatus?: QcStatusCreateNestedOneWithoutArrivalItemsInput
    QcResults?: QcResultsCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUpdateInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput
    material?: MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput
    condition?: ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput
    parameter?: ParametersUpdateOneWithoutArrivalItemsNestedInput
    qcStatus?: QcStatusUpdateOneWithoutArrivalItemsNestedInput
    QcResults?: QcResultsUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcResults?: QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsCreateManyInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
  }

  export type ArrivalItemsUpdateManyMutationInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArrivalItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WeighingsCreateInput = {
    weight: number
    note?: string | null
    weighingDate?: Date | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    arrivalItem: ArrivalItemsCreateNestedOneWithoutWeighingsInput
  }

  export type WeighingsUncheckedCreateInput = {
    id?: number
    arrivalItemId: number
    weight: number
    note?: string | null
    weighingDate?: Date | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type WeighingsUpdateInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    weighingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalItem?: ArrivalItemsUpdateOneRequiredWithoutWeighingsNestedInput
  }

  export type WeighingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    weighingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsCreateManyInput = {
    id?: number
    arrivalItemId: number
    weight: number
    note?: string | null
    weighingDate?: Date | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type WeighingsUpdateManyMutationInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    weighingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    weighingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationsCreateInput = {
    table: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsUncheckedCreateInput = {
    id?: number
    table: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsUpdateInput = {
    table?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    table?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateManyInput = {
    id?: number
    table: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsUpdateManyMutationInput = {
    table?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    table?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QcResultsCreateInput = {
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    arrivalItem: ArrivalItemsCreateNestedOneWithoutQcResultsInput
    parameter?: ParametersCreateNestedOneWithoutQcResultsInput
    history?: QcHistoriesCreateNestedOneWithoutQcResultsInput
  }

  export type QcResultsUncheckedCreateInput = {
    id?: number
    arrivalItemId: number
    parameterId: number
    historyId?: number | null
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcResultsUpdateInput = {
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalItem?: ArrivalItemsUpdateOneRequiredWithoutQcResultsNestedInput
    parameter?: ParametersUpdateOneWithoutQcResultsNestedInput
    history?: QcHistoriesUpdateOneWithoutQcResultsNestedInput
  }

  export type QcResultsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    parameterId?: IntFieldUpdateOperationsInput | number
    historyId?: NullableIntFieldUpdateOperationsInput | number | null
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcResultsCreateManyInput = {
    id?: number
    arrivalItemId: number
    parameterId: number
    historyId?: number | null
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcResultsUpdateManyMutationInput = {
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcResultsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    parameterId?: IntFieldUpdateOperationsInput | number
    historyId?: NullableIntFieldUpdateOperationsInput | number | null
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcStatusCreateInput = {
    name: string
    description?: string | null
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutQcStatusInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutStatusInput
  }

  export type QcStatusUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutQcStatusInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutStatusInput
  }

  export type QcStatusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUpdateManyWithoutQcStatusNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutStatusNestedInput
  }

  export type QcStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutQcStatusNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type QcStatusCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type QcStatusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcPhotosCreateInput = {
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    arrivalItem: ArrivalItemsCreateNestedOneWithoutQcPhotosInput
  }

  export type QcPhotosUncheckedCreateInput = {
    id?: number
    arrivalItemId: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcPhotosUpdateInput = {
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalItem?: ArrivalItemsUpdateOneRequiredWithoutQcPhotosNestedInput
  }

  export type QcPhotosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcPhotosCreateManyInput = {
    id?: number
    arrivalItemId: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcPhotosUpdateManyMutationInput = {
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcPhotosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityPhotosCreateInput = {
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    arrival: ArrivalsCreateNestedOneWithoutSecurityPhotosInput
  }

  export type SecurityPhotosUncheckedCreateInput = {
    id?: number
    arrivalId: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SecurityPhotosUpdateInput = {
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    arrival?: ArrivalsUpdateOneRequiredWithoutSecurityPhotosNestedInput
  }

  export type SecurityPhotosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityPhotosCreateManyInput = {
    id?: number
    arrivalId: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SecurityPhotosUpdateManyMutationInput = {
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityPhotosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsPhotosCreateInput = {
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    arrivalItem: ArrivalItemsCreateNestedOneWithoutWeighingsPhotosInput
  }

  export type WeighingsPhotosUncheckedCreateInput = {
    id?: number
    arrivalItemId: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type WeighingsPhotosUpdateInput = {
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalItem?: ArrivalItemsUpdateOneRequiredWithoutWeighingsPhotosNestedInput
  }

  export type WeighingsPhotosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsPhotosCreateManyInput = {
    id?: number
    arrivalItemId: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type WeighingsPhotosUpdateManyMutationInput = {
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsPhotosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcHistoriesCreateInput = {
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutQcHistoriesInput
    status: QcStatusCreateNestedOneWithoutQcHistoriesInput
    arrival?: ArrivalsCreateNestedOneWithoutQcHistoriesInput
    arrivalItem?: ArrivalItemsCreateNestedOneWithoutQcHistoriesInput
    QcResults?: QcResultsCreateNestedManyWithoutHistoryInput
  }

  export type QcHistoriesUncheckedCreateInput = {
    id?: number
    userId: string
    statusId: number
    arrivalId?: number | null
    arrivalItemId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type QcHistoriesUpdateInput = {
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutQcHistoriesNestedInput
    status?: QcStatusUpdateOneRequiredWithoutQcHistoriesNestedInput
    arrival?: ArrivalsUpdateOneWithoutQcHistoriesNestedInput
    arrivalItem?: ArrivalItemsUpdateOneWithoutQcHistoriesNestedInput
    QcResults?: QcResultsUpdateManyWithoutHistoryNestedInput
  }

  export type QcHistoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
    arrivalId?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalItemId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QcResults?: QcResultsUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type QcHistoriesCreateManyInput = {
    id?: number
    userId: string
    statusId: number
    arrivalId?: number | null
    arrivalItemId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QcHistoriesUpdateManyMutationInput = {
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QcHistoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
    arrivalId?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalItemId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArrivalStatusesCreateInput = {
    status?: string
    statusQc?: string | null
    statusWeighing?: string | null
    statusApproval?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    arrival: ArrivalsCreateNestedOneWithoutArrivalStatusesInput
  }

  export type ArrivalStatusesUncheckedCreateInput = {
    id?: number
    arrivalId: number
    status?: string
    statusQc?: string | null
    statusWeighing?: string | null
    statusApproval?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ArrivalStatusesUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    statusQc?: NullableStringFieldUpdateOperationsInput | string | null
    statusWeighing?: NullableStringFieldUpdateOperationsInput | string | null
    statusApproval?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalStatusesNestedInput
  }

  export type ArrivalStatusesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statusQc?: NullableStringFieldUpdateOperationsInput | string | null
    statusWeighing?: NullableStringFieldUpdateOperationsInput | string | null
    statusApproval?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArrivalStatusesCreateManyInput = {
    id?: number
    arrivalId: number
    status?: string
    statusQc?: string | null
    statusWeighing?: string | null
    statusApproval?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ArrivalStatusesUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    statusQc?: NullableStringFieldUpdateOperationsInput | string | null
    statusWeighing?: NullableStringFieldUpdateOperationsInput | string | null
    statusApproval?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArrivalStatusesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statusQc?: NullableStringFieldUpdateOperationsInput | string | null
    statusWeighing?: NullableStringFieldUpdateOperationsInput | string | null
    statusApproval?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParameterSettingsCreateInput = {
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    parameter: ParametersCreateNestedOneWithoutSettingsInput
  }

  export type ParameterSettingsUncheckedCreateInput = {
    id?: number
    parameterId: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type ParameterSettingsUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    parameter?: ParametersUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type ParameterSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parameterId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParameterSettingsCreateManyInput = {
    id?: number
    parameterId: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type ParameterSettingsUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParameterSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parameterId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type QcHistoriesListRelationFilter = {
    every?: QcHistoriesWhereInput
    some?: QcHistoriesWhereInput
    none?: QcHistoriesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type QcHistoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersOrderByRelevanceInput = {
    fields: UsersOrderByRelevanceFieldEnum | UsersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UsersCountOrderByAggregateInput = {
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ArrivalsListRelationFilter = {
    every?: ArrivalsWhereInput
    some?: ArrivalsWhereInput
    none?: ArrivalsWhereInput
  }

  export type ArrivalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuppliersOrderByRelevanceInput = {
    fields: SuppliersOrderByRelevanceFieldEnum | SuppliersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SuppliersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SuppliersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SuppliersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SuppliersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SuppliersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ArrivalItemsListRelationFilter = {
    every?: ArrivalItemsWhereInput
    some?: ArrivalItemsWhereInput
    none?: ArrivalItemsWhereInput
  }

  export type ArrivalItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialsOrderByRelevanceInput = {
    fields: MaterialsOrderByRelevanceFieldEnum | MaterialsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MaterialsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type MaterialsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaterialsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type MaterialsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type MaterialsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConditionsOrderByRelevanceInput = {
    fields: ConditionsOrderByRelevanceFieldEnum | ConditionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConditionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ConditionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConditionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ConditionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ConditionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QcResultsListRelationFilter = {
    every?: QcResultsWhereInput
    some?: QcResultsWhereInput
    none?: QcResultsWhereInput
  }

  export type ParameterSettingsListRelationFilter = {
    every?: ParameterSettingsWhereInput
    some?: ParameterSettingsWhereInput
    none?: ParameterSettingsWhereInput
  }

  export type QcResultsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParameterSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParametersOrderByRelevanceInput = {
    fields: ParametersOrderByRelevanceFieldEnum | ParametersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ParametersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ParametersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ParametersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ParametersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ParametersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SuppliersScalarRelationFilter = {
    is?: SuppliersWhereInput
    isNot?: SuppliersWhereInput
  }

  export type SecurityPhotosListRelationFilter = {
    every?: SecurityPhotosWhereInput
    some?: SecurityPhotosWhereInput
    none?: SecurityPhotosWhereInput
  }

  export type ArrivalStatusesNullableScalarRelationFilter = {
    is?: ArrivalStatusesWhereInput | null
    isNot?: ArrivalStatusesWhereInput | null
  }

  export type SecurityPhotosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArrivalsOrderByRelevanceInput = {
    fields: ArrivalsOrderByRelevanceFieldEnum | ArrivalsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ArrivalsCountOrderByAggregateInput = {
    id?: SortOrder
    idKedatangan?: SortOrder
    supplierId?: SortOrder
    arrivalDate?: SortOrder
    arrivalTime?: SortOrder
    nopol?: SortOrder
    suratJalan?: SortOrder
    city?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ArrivalsAvgOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
  }

  export type ArrivalsMaxOrderByAggregateInput = {
    id?: SortOrder
    idKedatangan?: SortOrder
    supplierId?: SortOrder
    arrivalDate?: SortOrder
    arrivalTime?: SortOrder
    nopol?: SortOrder
    suratJalan?: SortOrder
    city?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ArrivalsMinOrderByAggregateInput = {
    id?: SortOrder
    idKedatangan?: SortOrder
    supplierId?: SortOrder
    arrivalDate?: SortOrder
    arrivalTime?: SortOrder
    nopol?: SortOrder
    suratJalan?: SortOrder
    city?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ArrivalsSumOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ArrivalsScalarRelationFilter = {
    is?: ArrivalsWhereInput
    isNot?: ArrivalsWhereInput
  }

  export type MaterialsScalarRelationFilter = {
    is?: MaterialsWhereInput
    isNot?: MaterialsWhereInput
  }

  export type ConditionsScalarRelationFilter = {
    is?: ConditionsWhereInput
    isNot?: ConditionsWhereInput
  }

  export type ParametersNullableScalarRelationFilter = {
    is?: ParametersWhereInput | null
    isNot?: ParametersWhereInput | null
  }

  export type QcStatusNullableScalarRelationFilter = {
    is?: QcStatusWhereInput | null
    isNot?: QcStatusWhereInput | null
  }

  export type QcPhotosListRelationFilter = {
    every?: QcPhotosWhereInput
    some?: QcPhotosWhereInput
    none?: QcPhotosWhereInput
  }

  export type WeighingsListRelationFilter = {
    every?: WeighingsWhereInput
    some?: WeighingsWhereInput
    none?: WeighingsWhereInput
  }

  export type WeighingsPhotosListRelationFilter = {
    every?: WeighingsPhotosWhereInput
    some?: WeighingsPhotosWhereInput
    none?: WeighingsPhotosWhereInput
  }

  export type QcPhotosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeighingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeighingsPhotosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArrivalItemsOrderByRelevanceInput = {
    fields: ArrivalItemsOrderByRelevanceFieldEnum | ArrivalItemsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ArrivalItemsCountOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    materialId?: SortOrder
    conditionId?: SortOrder
    parameterId?: SortOrder
    conditionCategory?: SortOrder
    quantity?: SortOrder
    note?: SortOrder
    itemName?: SortOrder
    qcNote?: SortOrder
    qcStatusId?: SortOrder
    qcAnalysis?: SortOrder
    qcSample?: SortOrder
    qcKotoran?: SortOrder
    totalBerat?: SortOrder
    pengeringan?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    statusQc?: SortOrder
  }

  export type ArrivalItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    materialId?: SortOrder
    conditionId?: SortOrder
    parameterId?: SortOrder
    quantity?: SortOrder
    qcStatusId?: SortOrder
    qcSample?: SortOrder
    qcKotoran?: SortOrder
    totalBerat?: SortOrder
    pengeringan?: SortOrder
  }

  export type ArrivalItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    materialId?: SortOrder
    conditionId?: SortOrder
    parameterId?: SortOrder
    conditionCategory?: SortOrder
    quantity?: SortOrder
    note?: SortOrder
    itemName?: SortOrder
    qcNote?: SortOrder
    qcStatusId?: SortOrder
    qcAnalysis?: SortOrder
    qcSample?: SortOrder
    qcKotoran?: SortOrder
    totalBerat?: SortOrder
    pengeringan?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    statusQc?: SortOrder
  }

  export type ArrivalItemsMinOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    materialId?: SortOrder
    conditionId?: SortOrder
    parameterId?: SortOrder
    conditionCategory?: SortOrder
    quantity?: SortOrder
    note?: SortOrder
    itemName?: SortOrder
    qcNote?: SortOrder
    qcStatusId?: SortOrder
    qcAnalysis?: SortOrder
    qcSample?: SortOrder
    qcKotoran?: SortOrder
    totalBerat?: SortOrder
    pengeringan?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    statusQc?: SortOrder
  }

  export type ArrivalItemsSumOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    materialId?: SortOrder
    conditionId?: SortOrder
    parameterId?: SortOrder
    quantity?: SortOrder
    qcStatusId?: SortOrder
    qcSample?: SortOrder
    qcKotoran?: SortOrder
    totalBerat?: SortOrder
    pengeringan?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ArrivalItemsScalarRelationFilter = {
    is?: ArrivalItemsWhereInput
    isNot?: ArrivalItemsWhereInput
  }

  export type WeighingsOrderByRelevanceInput = {
    fields: WeighingsOrderByRelevanceFieldEnum | WeighingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WeighingsCountOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    weight?: SortOrder
    note?: SortOrder
    weighingDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type WeighingsAvgOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    weight?: SortOrder
  }

  export type WeighingsMaxOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    weight?: SortOrder
    note?: SortOrder
    weighingDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type WeighingsMinOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    weight?: SortOrder
    note?: SortOrder
    weighingDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type WeighingsSumOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    weight?: SortOrder
  }

  export type NotificationsOrderByRelevanceInput = {
    fields: NotificationsOrderByRelevanceFieldEnum | NotificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QcHistoriesNullableScalarRelationFilter = {
    is?: QcHistoriesWhereInput | null
    isNot?: QcHistoriesWhereInput | null
  }

  export type QcResultsOrderByRelevanceInput = {
    fields: QcResultsOrderByRelevanceFieldEnum | QcResultsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QcResultsCountOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    parameterId?: SortOrder
    historyId?: SortOrder
    resultKey?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type QcResultsAvgOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    parameterId?: SortOrder
    historyId?: SortOrder
  }

  export type QcResultsMaxOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    parameterId?: SortOrder
    historyId?: SortOrder
    resultKey?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type QcResultsMinOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    parameterId?: SortOrder
    historyId?: SortOrder
    resultKey?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type QcResultsSumOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    parameterId?: SortOrder
    historyId?: SortOrder
  }

  export type QcStatusOrderByRelevanceInput = {
    fields: QcStatusOrderByRelevanceFieldEnum | QcStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QcStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type QcStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QcStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type QcStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type QcStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QcPhotosOrderByRelevanceInput = {
    fields: QcPhotosOrderByRelevanceFieldEnum | QcPhotosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QcPhotosCountOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type QcPhotosAvgOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
  }

  export type QcPhotosMaxOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type QcPhotosMinOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type QcPhotosSumOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
  }

  export type SecurityPhotosOrderByRelevanceInput = {
    fields: SecurityPhotosOrderByRelevanceFieldEnum | SecurityPhotosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SecurityPhotosCountOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SecurityPhotosAvgOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
  }

  export type SecurityPhotosMaxOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SecurityPhotosMinOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SecurityPhotosSumOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
  }

  export type WeighingsPhotosOrderByRelevanceInput = {
    fields: WeighingsPhotosOrderByRelevanceFieldEnum | WeighingsPhotosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WeighingsPhotosCountOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type WeighingsPhotosAvgOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
  }

  export type WeighingsPhotosMaxOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type WeighingsPhotosMinOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type WeighingsPhotosSumOrderByAggregateInput = {
    id?: SortOrder
    arrivalItemId?: SortOrder
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type QcStatusScalarRelationFilter = {
    is?: QcStatusWhereInput
    isNot?: QcStatusWhereInput
  }

  export type ArrivalsNullableScalarRelationFilter = {
    is?: ArrivalsWhereInput | null
    isNot?: ArrivalsWhereInput | null
  }

  export type ArrivalItemsNullableScalarRelationFilter = {
    is?: ArrivalItemsWhereInput | null
    isNot?: ArrivalItemsWhereInput | null
  }

  export type QcHistoriesOrderByRelevanceInput = {
    fields: QcHistoriesOrderByRelevanceFieldEnum | QcHistoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QcHistoriesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statusId?: SortOrder
    arrivalId?: SortOrder
    arrivalItemId?: SortOrder
    qcSample?: SortOrder
    qcKotoran?: SortOrder
    totalBerat?: SortOrder
    pengeringan?: SortOrder
    note?: SortOrder
    qcNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QcHistoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    statusId?: SortOrder
    arrivalId?: SortOrder
    arrivalItemId?: SortOrder
    qcSample?: SortOrder
    qcKotoran?: SortOrder
    totalBerat?: SortOrder
    pengeringan?: SortOrder
  }

  export type QcHistoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statusId?: SortOrder
    arrivalId?: SortOrder
    arrivalItemId?: SortOrder
    qcSample?: SortOrder
    qcKotoran?: SortOrder
    totalBerat?: SortOrder
    pengeringan?: SortOrder
    note?: SortOrder
    qcNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QcHistoriesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statusId?: SortOrder
    arrivalId?: SortOrder
    arrivalItemId?: SortOrder
    qcSample?: SortOrder
    qcKotoran?: SortOrder
    totalBerat?: SortOrder
    pengeringan?: SortOrder
    note?: SortOrder
    qcNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QcHistoriesSumOrderByAggregateInput = {
    id?: SortOrder
    statusId?: SortOrder
    arrivalId?: SortOrder
    arrivalItemId?: SortOrder
    qcSample?: SortOrder
    qcKotoran?: SortOrder
    totalBerat?: SortOrder
    pengeringan?: SortOrder
  }

  export type ArrivalStatusesOrderByRelevanceInput = {
    fields: ArrivalStatusesOrderByRelevanceFieldEnum | ArrivalStatusesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ArrivalStatusesCountOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    status?: SortOrder
    statusQc?: SortOrder
    statusWeighing?: SortOrder
    statusApproval?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ArrivalStatusesAvgOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
  }

  export type ArrivalStatusesMaxOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    status?: SortOrder
    statusQc?: SortOrder
    statusWeighing?: SortOrder
    statusApproval?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ArrivalStatusesMinOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
    status?: SortOrder
    statusQc?: SortOrder
    statusWeighing?: SortOrder
    statusApproval?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ArrivalStatusesSumOrderByAggregateInput = {
    id?: SortOrder
    arrivalId?: SortOrder
  }

  export type ParametersScalarRelationFilter = {
    is?: ParametersWhereInput
    isNot?: ParametersWhereInput
  }

  export type ParameterSettingsOrderByRelevanceInput = {
    fields: ParameterSettingsOrderByRelevanceFieldEnum | ParameterSettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ParameterSettingsParameterIdKeyCompoundUniqueInput = {
    parameterId: number
    key: string
  }

  export type ParameterSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ParameterSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
  }

  export type ParameterSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ParameterSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ParameterSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
  }

  export type QcHistoriesCreateNestedManyWithoutUserInput = {
    create?: XOR<QcHistoriesCreateWithoutUserInput, QcHistoriesUncheckedCreateWithoutUserInput> | QcHistoriesCreateWithoutUserInput[] | QcHistoriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutUserInput | QcHistoriesCreateOrConnectWithoutUserInput[]
    createMany?: QcHistoriesCreateManyUserInputEnvelope
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
  }

  export type QcHistoriesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QcHistoriesCreateWithoutUserInput, QcHistoriesUncheckedCreateWithoutUserInput> | QcHistoriesCreateWithoutUserInput[] | QcHistoriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutUserInput | QcHistoriesCreateOrConnectWithoutUserInput[]
    createMany?: QcHistoriesCreateManyUserInputEnvelope
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type QcHistoriesUpdateManyWithoutUserNestedInput = {
    create?: XOR<QcHistoriesCreateWithoutUserInput, QcHistoriesUncheckedCreateWithoutUserInput> | QcHistoriesCreateWithoutUserInput[] | QcHistoriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutUserInput | QcHistoriesCreateOrConnectWithoutUserInput[]
    upsert?: QcHistoriesUpsertWithWhereUniqueWithoutUserInput | QcHistoriesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QcHistoriesCreateManyUserInputEnvelope
    set?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    disconnect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    delete?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    update?: QcHistoriesUpdateWithWhereUniqueWithoutUserInput | QcHistoriesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QcHistoriesUpdateManyWithWhereWithoutUserInput | QcHistoriesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QcHistoriesScalarWhereInput | QcHistoriesScalarWhereInput[]
  }

  export type QcHistoriesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QcHistoriesCreateWithoutUserInput, QcHistoriesUncheckedCreateWithoutUserInput> | QcHistoriesCreateWithoutUserInput[] | QcHistoriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutUserInput | QcHistoriesCreateOrConnectWithoutUserInput[]
    upsert?: QcHistoriesUpsertWithWhereUniqueWithoutUserInput | QcHistoriesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QcHistoriesCreateManyUserInputEnvelope
    set?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    disconnect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    delete?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    update?: QcHistoriesUpdateWithWhereUniqueWithoutUserInput | QcHistoriesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QcHistoriesUpdateManyWithWhereWithoutUserInput | QcHistoriesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QcHistoriesScalarWhereInput | QcHistoriesScalarWhereInput[]
  }

  export type ArrivalsCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ArrivalsCreateWithoutSupplierInput, ArrivalsUncheckedCreateWithoutSupplierInput> | ArrivalsCreateWithoutSupplierInput[] | ArrivalsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ArrivalsCreateOrConnectWithoutSupplierInput | ArrivalsCreateOrConnectWithoutSupplierInput[]
    createMany?: ArrivalsCreateManySupplierInputEnvelope
    connect?: ArrivalsWhereUniqueInput | ArrivalsWhereUniqueInput[]
  }

  export type ArrivalsUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ArrivalsCreateWithoutSupplierInput, ArrivalsUncheckedCreateWithoutSupplierInput> | ArrivalsCreateWithoutSupplierInput[] | ArrivalsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ArrivalsCreateOrConnectWithoutSupplierInput | ArrivalsCreateOrConnectWithoutSupplierInput[]
    createMany?: ArrivalsCreateManySupplierInputEnvelope
    connect?: ArrivalsWhereUniqueInput | ArrivalsWhereUniqueInput[]
  }

  export type ArrivalsUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ArrivalsCreateWithoutSupplierInput, ArrivalsUncheckedCreateWithoutSupplierInput> | ArrivalsCreateWithoutSupplierInput[] | ArrivalsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ArrivalsCreateOrConnectWithoutSupplierInput | ArrivalsCreateOrConnectWithoutSupplierInput[]
    upsert?: ArrivalsUpsertWithWhereUniqueWithoutSupplierInput | ArrivalsUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ArrivalsCreateManySupplierInputEnvelope
    set?: ArrivalsWhereUniqueInput | ArrivalsWhereUniqueInput[]
    disconnect?: ArrivalsWhereUniqueInput | ArrivalsWhereUniqueInput[]
    delete?: ArrivalsWhereUniqueInput | ArrivalsWhereUniqueInput[]
    connect?: ArrivalsWhereUniqueInput | ArrivalsWhereUniqueInput[]
    update?: ArrivalsUpdateWithWhereUniqueWithoutSupplierInput | ArrivalsUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ArrivalsUpdateManyWithWhereWithoutSupplierInput | ArrivalsUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ArrivalsScalarWhereInput | ArrivalsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ArrivalsUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ArrivalsCreateWithoutSupplierInput, ArrivalsUncheckedCreateWithoutSupplierInput> | ArrivalsCreateWithoutSupplierInput[] | ArrivalsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ArrivalsCreateOrConnectWithoutSupplierInput | ArrivalsCreateOrConnectWithoutSupplierInput[]
    upsert?: ArrivalsUpsertWithWhereUniqueWithoutSupplierInput | ArrivalsUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ArrivalsCreateManySupplierInputEnvelope
    set?: ArrivalsWhereUniqueInput | ArrivalsWhereUniqueInput[]
    disconnect?: ArrivalsWhereUniqueInput | ArrivalsWhereUniqueInput[]
    delete?: ArrivalsWhereUniqueInput | ArrivalsWhereUniqueInput[]
    connect?: ArrivalsWhereUniqueInput | ArrivalsWhereUniqueInput[]
    update?: ArrivalsUpdateWithWhereUniqueWithoutSupplierInput | ArrivalsUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ArrivalsUpdateManyWithWhereWithoutSupplierInput | ArrivalsUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ArrivalsScalarWhereInput | ArrivalsScalarWhereInput[]
  }

  export type ArrivalItemsCreateNestedManyWithoutMaterialInput = {
    create?: XOR<ArrivalItemsCreateWithoutMaterialInput, ArrivalItemsUncheckedCreateWithoutMaterialInput> | ArrivalItemsCreateWithoutMaterialInput[] | ArrivalItemsUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutMaterialInput | ArrivalItemsCreateOrConnectWithoutMaterialInput[]
    createMany?: ArrivalItemsCreateManyMaterialInputEnvelope
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
  }

  export type ArrivalItemsUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<ArrivalItemsCreateWithoutMaterialInput, ArrivalItemsUncheckedCreateWithoutMaterialInput> | ArrivalItemsCreateWithoutMaterialInput[] | ArrivalItemsUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutMaterialInput | ArrivalItemsCreateOrConnectWithoutMaterialInput[]
    createMany?: ArrivalItemsCreateManyMaterialInputEnvelope
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
  }

  export type ArrivalItemsUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutMaterialInput, ArrivalItemsUncheckedCreateWithoutMaterialInput> | ArrivalItemsCreateWithoutMaterialInput[] | ArrivalItemsUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutMaterialInput | ArrivalItemsCreateOrConnectWithoutMaterialInput[]
    upsert?: ArrivalItemsUpsertWithWhereUniqueWithoutMaterialInput | ArrivalItemsUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: ArrivalItemsCreateManyMaterialInputEnvelope
    set?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    disconnect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    delete?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    update?: ArrivalItemsUpdateWithWhereUniqueWithoutMaterialInput | ArrivalItemsUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: ArrivalItemsUpdateManyWithWhereWithoutMaterialInput | ArrivalItemsUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
  }

  export type ArrivalItemsUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutMaterialInput, ArrivalItemsUncheckedCreateWithoutMaterialInput> | ArrivalItemsCreateWithoutMaterialInput[] | ArrivalItemsUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutMaterialInput | ArrivalItemsCreateOrConnectWithoutMaterialInput[]
    upsert?: ArrivalItemsUpsertWithWhereUniqueWithoutMaterialInput | ArrivalItemsUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: ArrivalItemsCreateManyMaterialInputEnvelope
    set?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    disconnect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    delete?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    update?: ArrivalItemsUpdateWithWhereUniqueWithoutMaterialInput | ArrivalItemsUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: ArrivalItemsUpdateManyWithWhereWithoutMaterialInput | ArrivalItemsUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
  }

  export type ArrivalItemsCreateNestedManyWithoutConditionInput = {
    create?: XOR<ArrivalItemsCreateWithoutConditionInput, ArrivalItemsUncheckedCreateWithoutConditionInput> | ArrivalItemsCreateWithoutConditionInput[] | ArrivalItemsUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutConditionInput | ArrivalItemsCreateOrConnectWithoutConditionInput[]
    createMany?: ArrivalItemsCreateManyConditionInputEnvelope
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
  }

  export type ArrivalItemsUncheckedCreateNestedManyWithoutConditionInput = {
    create?: XOR<ArrivalItemsCreateWithoutConditionInput, ArrivalItemsUncheckedCreateWithoutConditionInput> | ArrivalItemsCreateWithoutConditionInput[] | ArrivalItemsUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutConditionInput | ArrivalItemsCreateOrConnectWithoutConditionInput[]
    createMany?: ArrivalItemsCreateManyConditionInputEnvelope
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
  }

  export type ArrivalItemsUpdateManyWithoutConditionNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutConditionInput, ArrivalItemsUncheckedCreateWithoutConditionInput> | ArrivalItemsCreateWithoutConditionInput[] | ArrivalItemsUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutConditionInput | ArrivalItemsCreateOrConnectWithoutConditionInput[]
    upsert?: ArrivalItemsUpsertWithWhereUniqueWithoutConditionInput | ArrivalItemsUpsertWithWhereUniqueWithoutConditionInput[]
    createMany?: ArrivalItemsCreateManyConditionInputEnvelope
    set?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    disconnect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    delete?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    update?: ArrivalItemsUpdateWithWhereUniqueWithoutConditionInput | ArrivalItemsUpdateWithWhereUniqueWithoutConditionInput[]
    updateMany?: ArrivalItemsUpdateManyWithWhereWithoutConditionInput | ArrivalItemsUpdateManyWithWhereWithoutConditionInput[]
    deleteMany?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
  }

  export type ArrivalItemsUncheckedUpdateManyWithoutConditionNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutConditionInput, ArrivalItemsUncheckedCreateWithoutConditionInput> | ArrivalItemsCreateWithoutConditionInput[] | ArrivalItemsUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutConditionInput | ArrivalItemsCreateOrConnectWithoutConditionInput[]
    upsert?: ArrivalItemsUpsertWithWhereUniqueWithoutConditionInput | ArrivalItemsUpsertWithWhereUniqueWithoutConditionInput[]
    createMany?: ArrivalItemsCreateManyConditionInputEnvelope
    set?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    disconnect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    delete?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    update?: ArrivalItemsUpdateWithWhereUniqueWithoutConditionInput | ArrivalItemsUpdateWithWhereUniqueWithoutConditionInput[]
    updateMany?: ArrivalItemsUpdateManyWithWhereWithoutConditionInput | ArrivalItemsUpdateManyWithWhereWithoutConditionInput[]
    deleteMany?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
  }

  export type ArrivalItemsCreateNestedManyWithoutParameterInput = {
    create?: XOR<ArrivalItemsCreateWithoutParameterInput, ArrivalItemsUncheckedCreateWithoutParameterInput> | ArrivalItemsCreateWithoutParameterInput[] | ArrivalItemsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutParameterInput | ArrivalItemsCreateOrConnectWithoutParameterInput[]
    createMany?: ArrivalItemsCreateManyParameterInputEnvelope
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
  }

  export type QcResultsCreateNestedManyWithoutParameterInput = {
    create?: XOR<QcResultsCreateWithoutParameterInput, QcResultsUncheckedCreateWithoutParameterInput> | QcResultsCreateWithoutParameterInput[] | QcResultsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutParameterInput | QcResultsCreateOrConnectWithoutParameterInput[]
    createMany?: QcResultsCreateManyParameterInputEnvelope
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
  }

  export type ParameterSettingsCreateNestedManyWithoutParameterInput = {
    create?: XOR<ParameterSettingsCreateWithoutParameterInput, ParameterSettingsUncheckedCreateWithoutParameterInput> | ParameterSettingsCreateWithoutParameterInput[] | ParameterSettingsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ParameterSettingsCreateOrConnectWithoutParameterInput | ParameterSettingsCreateOrConnectWithoutParameterInput[]
    createMany?: ParameterSettingsCreateManyParameterInputEnvelope
    connect?: ParameterSettingsWhereUniqueInput | ParameterSettingsWhereUniqueInput[]
  }

  export type ArrivalItemsUncheckedCreateNestedManyWithoutParameterInput = {
    create?: XOR<ArrivalItemsCreateWithoutParameterInput, ArrivalItemsUncheckedCreateWithoutParameterInput> | ArrivalItemsCreateWithoutParameterInput[] | ArrivalItemsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutParameterInput | ArrivalItemsCreateOrConnectWithoutParameterInput[]
    createMany?: ArrivalItemsCreateManyParameterInputEnvelope
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
  }

  export type QcResultsUncheckedCreateNestedManyWithoutParameterInput = {
    create?: XOR<QcResultsCreateWithoutParameterInput, QcResultsUncheckedCreateWithoutParameterInput> | QcResultsCreateWithoutParameterInput[] | QcResultsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutParameterInput | QcResultsCreateOrConnectWithoutParameterInput[]
    createMany?: QcResultsCreateManyParameterInputEnvelope
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
  }

  export type ParameterSettingsUncheckedCreateNestedManyWithoutParameterInput = {
    create?: XOR<ParameterSettingsCreateWithoutParameterInput, ParameterSettingsUncheckedCreateWithoutParameterInput> | ParameterSettingsCreateWithoutParameterInput[] | ParameterSettingsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ParameterSettingsCreateOrConnectWithoutParameterInput | ParameterSettingsCreateOrConnectWithoutParameterInput[]
    createMany?: ParameterSettingsCreateManyParameterInputEnvelope
    connect?: ParameterSettingsWhereUniqueInput | ParameterSettingsWhereUniqueInput[]
  }

  export type ArrivalItemsUpdateManyWithoutParameterNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutParameterInput, ArrivalItemsUncheckedCreateWithoutParameterInput> | ArrivalItemsCreateWithoutParameterInput[] | ArrivalItemsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutParameterInput | ArrivalItemsCreateOrConnectWithoutParameterInput[]
    upsert?: ArrivalItemsUpsertWithWhereUniqueWithoutParameterInput | ArrivalItemsUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: ArrivalItemsCreateManyParameterInputEnvelope
    set?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    disconnect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    delete?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    update?: ArrivalItemsUpdateWithWhereUniqueWithoutParameterInput | ArrivalItemsUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: ArrivalItemsUpdateManyWithWhereWithoutParameterInput | ArrivalItemsUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
  }

  export type QcResultsUpdateManyWithoutParameterNestedInput = {
    create?: XOR<QcResultsCreateWithoutParameterInput, QcResultsUncheckedCreateWithoutParameterInput> | QcResultsCreateWithoutParameterInput[] | QcResultsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutParameterInput | QcResultsCreateOrConnectWithoutParameterInput[]
    upsert?: QcResultsUpsertWithWhereUniqueWithoutParameterInput | QcResultsUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: QcResultsCreateManyParameterInputEnvelope
    set?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    disconnect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    delete?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    update?: QcResultsUpdateWithWhereUniqueWithoutParameterInput | QcResultsUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: QcResultsUpdateManyWithWhereWithoutParameterInput | QcResultsUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: QcResultsScalarWhereInput | QcResultsScalarWhereInput[]
  }

  export type ParameterSettingsUpdateManyWithoutParameterNestedInput = {
    create?: XOR<ParameterSettingsCreateWithoutParameterInput, ParameterSettingsUncheckedCreateWithoutParameterInput> | ParameterSettingsCreateWithoutParameterInput[] | ParameterSettingsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ParameterSettingsCreateOrConnectWithoutParameterInput | ParameterSettingsCreateOrConnectWithoutParameterInput[]
    upsert?: ParameterSettingsUpsertWithWhereUniqueWithoutParameterInput | ParameterSettingsUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: ParameterSettingsCreateManyParameterInputEnvelope
    set?: ParameterSettingsWhereUniqueInput | ParameterSettingsWhereUniqueInput[]
    disconnect?: ParameterSettingsWhereUniqueInput | ParameterSettingsWhereUniqueInput[]
    delete?: ParameterSettingsWhereUniqueInput | ParameterSettingsWhereUniqueInput[]
    connect?: ParameterSettingsWhereUniqueInput | ParameterSettingsWhereUniqueInput[]
    update?: ParameterSettingsUpdateWithWhereUniqueWithoutParameterInput | ParameterSettingsUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: ParameterSettingsUpdateManyWithWhereWithoutParameterInput | ParameterSettingsUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: ParameterSettingsScalarWhereInput | ParameterSettingsScalarWhereInput[]
  }

  export type ArrivalItemsUncheckedUpdateManyWithoutParameterNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutParameterInput, ArrivalItemsUncheckedCreateWithoutParameterInput> | ArrivalItemsCreateWithoutParameterInput[] | ArrivalItemsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutParameterInput | ArrivalItemsCreateOrConnectWithoutParameterInput[]
    upsert?: ArrivalItemsUpsertWithWhereUniqueWithoutParameterInput | ArrivalItemsUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: ArrivalItemsCreateManyParameterInputEnvelope
    set?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    disconnect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    delete?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    update?: ArrivalItemsUpdateWithWhereUniqueWithoutParameterInput | ArrivalItemsUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: ArrivalItemsUpdateManyWithWhereWithoutParameterInput | ArrivalItemsUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
  }

  export type QcResultsUncheckedUpdateManyWithoutParameterNestedInput = {
    create?: XOR<QcResultsCreateWithoutParameterInput, QcResultsUncheckedCreateWithoutParameterInput> | QcResultsCreateWithoutParameterInput[] | QcResultsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutParameterInput | QcResultsCreateOrConnectWithoutParameterInput[]
    upsert?: QcResultsUpsertWithWhereUniqueWithoutParameterInput | QcResultsUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: QcResultsCreateManyParameterInputEnvelope
    set?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    disconnect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    delete?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    update?: QcResultsUpdateWithWhereUniqueWithoutParameterInput | QcResultsUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: QcResultsUpdateManyWithWhereWithoutParameterInput | QcResultsUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: QcResultsScalarWhereInput | QcResultsScalarWhereInput[]
  }

  export type ParameterSettingsUncheckedUpdateManyWithoutParameterNestedInput = {
    create?: XOR<ParameterSettingsCreateWithoutParameterInput, ParameterSettingsUncheckedCreateWithoutParameterInput> | ParameterSettingsCreateWithoutParameterInput[] | ParameterSettingsUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ParameterSettingsCreateOrConnectWithoutParameterInput | ParameterSettingsCreateOrConnectWithoutParameterInput[]
    upsert?: ParameterSettingsUpsertWithWhereUniqueWithoutParameterInput | ParameterSettingsUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: ParameterSettingsCreateManyParameterInputEnvelope
    set?: ParameterSettingsWhereUniqueInput | ParameterSettingsWhereUniqueInput[]
    disconnect?: ParameterSettingsWhereUniqueInput | ParameterSettingsWhereUniqueInput[]
    delete?: ParameterSettingsWhereUniqueInput | ParameterSettingsWhereUniqueInput[]
    connect?: ParameterSettingsWhereUniqueInput | ParameterSettingsWhereUniqueInput[]
    update?: ParameterSettingsUpdateWithWhereUniqueWithoutParameterInput | ParameterSettingsUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: ParameterSettingsUpdateManyWithWhereWithoutParameterInput | ParameterSettingsUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: ParameterSettingsScalarWhereInput | ParameterSettingsScalarWhereInput[]
  }

  export type SuppliersCreateNestedOneWithoutArrivalsInput = {
    create?: XOR<SuppliersCreateWithoutArrivalsInput, SuppliersUncheckedCreateWithoutArrivalsInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutArrivalsInput
    connect?: SuppliersWhereUniqueInput
  }

  export type ArrivalItemsCreateNestedManyWithoutArrivalInput = {
    create?: XOR<ArrivalItemsCreateWithoutArrivalInput, ArrivalItemsUncheckedCreateWithoutArrivalInput> | ArrivalItemsCreateWithoutArrivalInput[] | ArrivalItemsUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutArrivalInput | ArrivalItemsCreateOrConnectWithoutArrivalInput[]
    createMany?: ArrivalItemsCreateManyArrivalInputEnvelope
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
  }

  export type QcHistoriesCreateNestedManyWithoutArrivalInput = {
    create?: XOR<QcHistoriesCreateWithoutArrivalInput, QcHistoriesUncheckedCreateWithoutArrivalInput> | QcHistoriesCreateWithoutArrivalInput[] | QcHistoriesUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutArrivalInput | QcHistoriesCreateOrConnectWithoutArrivalInput[]
    createMany?: QcHistoriesCreateManyArrivalInputEnvelope
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
  }

  export type SecurityPhotosCreateNestedManyWithoutArrivalInput = {
    create?: XOR<SecurityPhotosCreateWithoutArrivalInput, SecurityPhotosUncheckedCreateWithoutArrivalInput> | SecurityPhotosCreateWithoutArrivalInput[] | SecurityPhotosUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: SecurityPhotosCreateOrConnectWithoutArrivalInput | SecurityPhotosCreateOrConnectWithoutArrivalInput[]
    createMany?: SecurityPhotosCreateManyArrivalInputEnvelope
    connect?: SecurityPhotosWhereUniqueInput | SecurityPhotosWhereUniqueInput[]
  }

  export type ArrivalStatusesCreateNestedOneWithoutArrivalInput = {
    create?: XOR<ArrivalStatusesCreateWithoutArrivalInput, ArrivalStatusesUncheckedCreateWithoutArrivalInput>
    connectOrCreate?: ArrivalStatusesCreateOrConnectWithoutArrivalInput
    connect?: ArrivalStatusesWhereUniqueInput
  }

  export type ArrivalItemsUncheckedCreateNestedManyWithoutArrivalInput = {
    create?: XOR<ArrivalItemsCreateWithoutArrivalInput, ArrivalItemsUncheckedCreateWithoutArrivalInput> | ArrivalItemsCreateWithoutArrivalInput[] | ArrivalItemsUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutArrivalInput | ArrivalItemsCreateOrConnectWithoutArrivalInput[]
    createMany?: ArrivalItemsCreateManyArrivalInputEnvelope
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
  }

  export type QcHistoriesUncheckedCreateNestedManyWithoutArrivalInput = {
    create?: XOR<QcHistoriesCreateWithoutArrivalInput, QcHistoriesUncheckedCreateWithoutArrivalInput> | QcHistoriesCreateWithoutArrivalInput[] | QcHistoriesUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutArrivalInput | QcHistoriesCreateOrConnectWithoutArrivalInput[]
    createMany?: QcHistoriesCreateManyArrivalInputEnvelope
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
  }

  export type SecurityPhotosUncheckedCreateNestedManyWithoutArrivalInput = {
    create?: XOR<SecurityPhotosCreateWithoutArrivalInput, SecurityPhotosUncheckedCreateWithoutArrivalInput> | SecurityPhotosCreateWithoutArrivalInput[] | SecurityPhotosUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: SecurityPhotosCreateOrConnectWithoutArrivalInput | SecurityPhotosCreateOrConnectWithoutArrivalInput[]
    createMany?: SecurityPhotosCreateManyArrivalInputEnvelope
    connect?: SecurityPhotosWhereUniqueInput | SecurityPhotosWhereUniqueInput[]
  }

  export type ArrivalStatusesUncheckedCreateNestedOneWithoutArrivalInput = {
    create?: XOR<ArrivalStatusesCreateWithoutArrivalInput, ArrivalStatusesUncheckedCreateWithoutArrivalInput>
    connectOrCreate?: ArrivalStatusesCreateOrConnectWithoutArrivalInput
    connect?: ArrivalStatusesWhereUniqueInput
  }

  export type SuppliersUpdateOneRequiredWithoutArrivalsNestedInput = {
    create?: XOR<SuppliersCreateWithoutArrivalsInput, SuppliersUncheckedCreateWithoutArrivalsInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutArrivalsInput
    upsert?: SuppliersUpsertWithoutArrivalsInput
    connect?: SuppliersWhereUniqueInput
    update?: XOR<XOR<SuppliersUpdateToOneWithWhereWithoutArrivalsInput, SuppliersUpdateWithoutArrivalsInput>, SuppliersUncheckedUpdateWithoutArrivalsInput>
  }

  export type ArrivalItemsUpdateManyWithoutArrivalNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutArrivalInput, ArrivalItemsUncheckedCreateWithoutArrivalInput> | ArrivalItemsCreateWithoutArrivalInput[] | ArrivalItemsUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutArrivalInput | ArrivalItemsCreateOrConnectWithoutArrivalInput[]
    upsert?: ArrivalItemsUpsertWithWhereUniqueWithoutArrivalInput | ArrivalItemsUpsertWithWhereUniqueWithoutArrivalInput[]
    createMany?: ArrivalItemsCreateManyArrivalInputEnvelope
    set?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    disconnect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    delete?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    update?: ArrivalItemsUpdateWithWhereUniqueWithoutArrivalInput | ArrivalItemsUpdateWithWhereUniqueWithoutArrivalInput[]
    updateMany?: ArrivalItemsUpdateManyWithWhereWithoutArrivalInput | ArrivalItemsUpdateManyWithWhereWithoutArrivalInput[]
    deleteMany?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
  }

  export type QcHistoriesUpdateManyWithoutArrivalNestedInput = {
    create?: XOR<QcHistoriesCreateWithoutArrivalInput, QcHistoriesUncheckedCreateWithoutArrivalInput> | QcHistoriesCreateWithoutArrivalInput[] | QcHistoriesUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutArrivalInput | QcHistoriesCreateOrConnectWithoutArrivalInput[]
    upsert?: QcHistoriesUpsertWithWhereUniqueWithoutArrivalInput | QcHistoriesUpsertWithWhereUniqueWithoutArrivalInput[]
    createMany?: QcHistoriesCreateManyArrivalInputEnvelope
    set?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    disconnect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    delete?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    update?: QcHistoriesUpdateWithWhereUniqueWithoutArrivalInput | QcHistoriesUpdateWithWhereUniqueWithoutArrivalInput[]
    updateMany?: QcHistoriesUpdateManyWithWhereWithoutArrivalInput | QcHistoriesUpdateManyWithWhereWithoutArrivalInput[]
    deleteMany?: QcHistoriesScalarWhereInput | QcHistoriesScalarWhereInput[]
  }

  export type SecurityPhotosUpdateManyWithoutArrivalNestedInput = {
    create?: XOR<SecurityPhotosCreateWithoutArrivalInput, SecurityPhotosUncheckedCreateWithoutArrivalInput> | SecurityPhotosCreateWithoutArrivalInput[] | SecurityPhotosUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: SecurityPhotosCreateOrConnectWithoutArrivalInput | SecurityPhotosCreateOrConnectWithoutArrivalInput[]
    upsert?: SecurityPhotosUpsertWithWhereUniqueWithoutArrivalInput | SecurityPhotosUpsertWithWhereUniqueWithoutArrivalInput[]
    createMany?: SecurityPhotosCreateManyArrivalInputEnvelope
    set?: SecurityPhotosWhereUniqueInput | SecurityPhotosWhereUniqueInput[]
    disconnect?: SecurityPhotosWhereUniqueInput | SecurityPhotosWhereUniqueInput[]
    delete?: SecurityPhotosWhereUniqueInput | SecurityPhotosWhereUniqueInput[]
    connect?: SecurityPhotosWhereUniqueInput | SecurityPhotosWhereUniqueInput[]
    update?: SecurityPhotosUpdateWithWhereUniqueWithoutArrivalInput | SecurityPhotosUpdateWithWhereUniqueWithoutArrivalInput[]
    updateMany?: SecurityPhotosUpdateManyWithWhereWithoutArrivalInput | SecurityPhotosUpdateManyWithWhereWithoutArrivalInput[]
    deleteMany?: SecurityPhotosScalarWhereInput | SecurityPhotosScalarWhereInput[]
  }

  export type ArrivalStatusesUpdateOneWithoutArrivalNestedInput = {
    create?: XOR<ArrivalStatusesCreateWithoutArrivalInput, ArrivalStatusesUncheckedCreateWithoutArrivalInput>
    connectOrCreate?: ArrivalStatusesCreateOrConnectWithoutArrivalInput
    upsert?: ArrivalStatusesUpsertWithoutArrivalInput
    disconnect?: ArrivalStatusesWhereInput | boolean
    delete?: ArrivalStatusesWhereInput | boolean
    connect?: ArrivalStatusesWhereUniqueInput
    update?: XOR<XOR<ArrivalStatusesUpdateToOneWithWhereWithoutArrivalInput, ArrivalStatusesUpdateWithoutArrivalInput>, ArrivalStatusesUncheckedUpdateWithoutArrivalInput>
  }

  export type ArrivalItemsUncheckedUpdateManyWithoutArrivalNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutArrivalInput, ArrivalItemsUncheckedCreateWithoutArrivalInput> | ArrivalItemsCreateWithoutArrivalInput[] | ArrivalItemsUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutArrivalInput | ArrivalItemsCreateOrConnectWithoutArrivalInput[]
    upsert?: ArrivalItemsUpsertWithWhereUniqueWithoutArrivalInput | ArrivalItemsUpsertWithWhereUniqueWithoutArrivalInput[]
    createMany?: ArrivalItemsCreateManyArrivalInputEnvelope
    set?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    disconnect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    delete?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    update?: ArrivalItemsUpdateWithWhereUniqueWithoutArrivalInput | ArrivalItemsUpdateWithWhereUniqueWithoutArrivalInput[]
    updateMany?: ArrivalItemsUpdateManyWithWhereWithoutArrivalInput | ArrivalItemsUpdateManyWithWhereWithoutArrivalInput[]
    deleteMany?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
  }

  export type QcHistoriesUncheckedUpdateManyWithoutArrivalNestedInput = {
    create?: XOR<QcHistoriesCreateWithoutArrivalInput, QcHistoriesUncheckedCreateWithoutArrivalInput> | QcHistoriesCreateWithoutArrivalInput[] | QcHistoriesUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutArrivalInput | QcHistoriesCreateOrConnectWithoutArrivalInput[]
    upsert?: QcHistoriesUpsertWithWhereUniqueWithoutArrivalInput | QcHistoriesUpsertWithWhereUniqueWithoutArrivalInput[]
    createMany?: QcHistoriesCreateManyArrivalInputEnvelope
    set?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    disconnect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    delete?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    update?: QcHistoriesUpdateWithWhereUniqueWithoutArrivalInput | QcHistoriesUpdateWithWhereUniqueWithoutArrivalInput[]
    updateMany?: QcHistoriesUpdateManyWithWhereWithoutArrivalInput | QcHistoriesUpdateManyWithWhereWithoutArrivalInput[]
    deleteMany?: QcHistoriesScalarWhereInput | QcHistoriesScalarWhereInput[]
  }

  export type SecurityPhotosUncheckedUpdateManyWithoutArrivalNestedInput = {
    create?: XOR<SecurityPhotosCreateWithoutArrivalInput, SecurityPhotosUncheckedCreateWithoutArrivalInput> | SecurityPhotosCreateWithoutArrivalInput[] | SecurityPhotosUncheckedCreateWithoutArrivalInput[]
    connectOrCreate?: SecurityPhotosCreateOrConnectWithoutArrivalInput | SecurityPhotosCreateOrConnectWithoutArrivalInput[]
    upsert?: SecurityPhotosUpsertWithWhereUniqueWithoutArrivalInput | SecurityPhotosUpsertWithWhereUniqueWithoutArrivalInput[]
    createMany?: SecurityPhotosCreateManyArrivalInputEnvelope
    set?: SecurityPhotosWhereUniqueInput | SecurityPhotosWhereUniqueInput[]
    disconnect?: SecurityPhotosWhereUniqueInput | SecurityPhotosWhereUniqueInput[]
    delete?: SecurityPhotosWhereUniqueInput | SecurityPhotosWhereUniqueInput[]
    connect?: SecurityPhotosWhereUniqueInput | SecurityPhotosWhereUniqueInput[]
    update?: SecurityPhotosUpdateWithWhereUniqueWithoutArrivalInput | SecurityPhotosUpdateWithWhereUniqueWithoutArrivalInput[]
    updateMany?: SecurityPhotosUpdateManyWithWhereWithoutArrivalInput | SecurityPhotosUpdateManyWithWhereWithoutArrivalInput[]
    deleteMany?: SecurityPhotosScalarWhereInput | SecurityPhotosScalarWhereInput[]
  }

  export type ArrivalStatusesUncheckedUpdateOneWithoutArrivalNestedInput = {
    create?: XOR<ArrivalStatusesCreateWithoutArrivalInput, ArrivalStatusesUncheckedCreateWithoutArrivalInput>
    connectOrCreate?: ArrivalStatusesCreateOrConnectWithoutArrivalInput
    upsert?: ArrivalStatusesUpsertWithoutArrivalInput
    disconnect?: ArrivalStatusesWhereInput | boolean
    delete?: ArrivalStatusesWhereInput | boolean
    connect?: ArrivalStatusesWhereUniqueInput
    update?: XOR<XOR<ArrivalStatusesUpdateToOneWithWhereWithoutArrivalInput, ArrivalStatusesUpdateWithoutArrivalInput>, ArrivalStatusesUncheckedUpdateWithoutArrivalInput>
  }

  export type ArrivalsCreateNestedOneWithoutArrivalItemsInput = {
    create?: XOR<ArrivalsCreateWithoutArrivalItemsInput, ArrivalsUncheckedCreateWithoutArrivalItemsInput>
    connectOrCreate?: ArrivalsCreateOrConnectWithoutArrivalItemsInput
    connect?: ArrivalsWhereUniqueInput
  }

  export type MaterialsCreateNestedOneWithoutArrivalItemsInput = {
    create?: XOR<MaterialsCreateWithoutArrivalItemsInput, MaterialsUncheckedCreateWithoutArrivalItemsInput>
    connectOrCreate?: MaterialsCreateOrConnectWithoutArrivalItemsInput
    connect?: MaterialsWhereUniqueInput
  }

  export type ConditionsCreateNestedOneWithoutArrivalItemsInput = {
    create?: XOR<ConditionsCreateWithoutArrivalItemsInput, ConditionsUncheckedCreateWithoutArrivalItemsInput>
    connectOrCreate?: ConditionsCreateOrConnectWithoutArrivalItemsInput
    connect?: ConditionsWhereUniqueInput
  }

  export type ParametersCreateNestedOneWithoutArrivalItemsInput = {
    create?: XOR<ParametersCreateWithoutArrivalItemsInput, ParametersUncheckedCreateWithoutArrivalItemsInput>
    connectOrCreate?: ParametersCreateOrConnectWithoutArrivalItemsInput
    connect?: ParametersWhereUniqueInput
  }

  export type QcStatusCreateNestedOneWithoutArrivalItemsInput = {
    create?: XOR<QcStatusCreateWithoutArrivalItemsInput, QcStatusUncheckedCreateWithoutArrivalItemsInput>
    connectOrCreate?: QcStatusCreateOrConnectWithoutArrivalItemsInput
    connect?: QcStatusWhereUniqueInput
  }

  export type QcResultsCreateNestedManyWithoutArrivalItemInput = {
    create?: XOR<QcResultsCreateWithoutArrivalItemInput, QcResultsUncheckedCreateWithoutArrivalItemInput> | QcResultsCreateWithoutArrivalItemInput[] | QcResultsUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutArrivalItemInput | QcResultsCreateOrConnectWithoutArrivalItemInput[]
    createMany?: QcResultsCreateManyArrivalItemInputEnvelope
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
  }

  export type QcPhotosCreateNestedManyWithoutArrivalItemInput = {
    create?: XOR<QcPhotosCreateWithoutArrivalItemInput, QcPhotosUncheckedCreateWithoutArrivalItemInput> | QcPhotosCreateWithoutArrivalItemInput[] | QcPhotosUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcPhotosCreateOrConnectWithoutArrivalItemInput | QcPhotosCreateOrConnectWithoutArrivalItemInput[]
    createMany?: QcPhotosCreateManyArrivalItemInputEnvelope
    connect?: QcPhotosWhereUniqueInput | QcPhotosWhereUniqueInput[]
  }

  export type WeighingsCreateNestedManyWithoutArrivalItemInput = {
    create?: XOR<WeighingsCreateWithoutArrivalItemInput, WeighingsUncheckedCreateWithoutArrivalItemInput> | WeighingsCreateWithoutArrivalItemInput[] | WeighingsUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: WeighingsCreateOrConnectWithoutArrivalItemInput | WeighingsCreateOrConnectWithoutArrivalItemInput[]
    createMany?: WeighingsCreateManyArrivalItemInputEnvelope
    connect?: WeighingsWhereUniqueInput | WeighingsWhereUniqueInput[]
  }

  export type WeighingsPhotosCreateNestedManyWithoutArrivalItemInput = {
    create?: XOR<WeighingsPhotosCreateWithoutArrivalItemInput, WeighingsPhotosUncheckedCreateWithoutArrivalItemInput> | WeighingsPhotosCreateWithoutArrivalItemInput[] | WeighingsPhotosUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: WeighingsPhotosCreateOrConnectWithoutArrivalItemInput | WeighingsPhotosCreateOrConnectWithoutArrivalItemInput[]
    createMany?: WeighingsPhotosCreateManyArrivalItemInputEnvelope
    connect?: WeighingsPhotosWhereUniqueInput | WeighingsPhotosWhereUniqueInput[]
  }

  export type QcHistoriesCreateNestedManyWithoutArrivalItemInput = {
    create?: XOR<QcHistoriesCreateWithoutArrivalItemInput, QcHistoriesUncheckedCreateWithoutArrivalItemInput> | QcHistoriesCreateWithoutArrivalItemInput[] | QcHistoriesUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutArrivalItemInput | QcHistoriesCreateOrConnectWithoutArrivalItemInput[]
    createMany?: QcHistoriesCreateManyArrivalItemInputEnvelope
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
  }

  export type QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput = {
    create?: XOR<QcResultsCreateWithoutArrivalItemInput, QcResultsUncheckedCreateWithoutArrivalItemInput> | QcResultsCreateWithoutArrivalItemInput[] | QcResultsUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutArrivalItemInput | QcResultsCreateOrConnectWithoutArrivalItemInput[]
    createMany?: QcResultsCreateManyArrivalItemInputEnvelope
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
  }

  export type QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput = {
    create?: XOR<QcPhotosCreateWithoutArrivalItemInput, QcPhotosUncheckedCreateWithoutArrivalItemInput> | QcPhotosCreateWithoutArrivalItemInput[] | QcPhotosUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcPhotosCreateOrConnectWithoutArrivalItemInput | QcPhotosCreateOrConnectWithoutArrivalItemInput[]
    createMany?: QcPhotosCreateManyArrivalItemInputEnvelope
    connect?: QcPhotosWhereUniqueInput | QcPhotosWhereUniqueInput[]
  }

  export type WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput = {
    create?: XOR<WeighingsCreateWithoutArrivalItemInput, WeighingsUncheckedCreateWithoutArrivalItemInput> | WeighingsCreateWithoutArrivalItemInput[] | WeighingsUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: WeighingsCreateOrConnectWithoutArrivalItemInput | WeighingsCreateOrConnectWithoutArrivalItemInput[]
    createMany?: WeighingsCreateManyArrivalItemInputEnvelope
    connect?: WeighingsWhereUniqueInput | WeighingsWhereUniqueInput[]
  }

  export type WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput = {
    create?: XOR<WeighingsPhotosCreateWithoutArrivalItemInput, WeighingsPhotosUncheckedCreateWithoutArrivalItemInput> | WeighingsPhotosCreateWithoutArrivalItemInput[] | WeighingsPhotosUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: WeighingsPhotosCreateOrConnectWithoutArrivalItemInput | WeighingsPhotosCreateOrConnectWithoutArrivalItemInput[]
    createMany?: WeighingsPhotosCreateManyArrivalItemInputEnvelope
    connect?: WeighingsPhotosWhereUniqueInput | WeighingsPhotosWhereUniqueInput[]
  }

  export type QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput = {
    create?: XOR<QcHistoriesCreateWithoutArrivalItemInput, QcHistoriesUncheckedCreateWithoutArrivalItemInput> | QcHistoriesCreateWithoutArrivalItemInput[] | QcHistoriesUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutArrivalItemInput | QcHistoriesCreateOrConnectWithoutArrivalItemInput[]
    createMany?: QcHistoriesCreateManyArrivalItemInputEnvelope
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput = {
    create?: XOR<ArrivalsCreateWithoutArrivalItemsInput, ArrivalsUncheckedCreateWithoutArrivalItemsInput>
    connectOrCreate?: ArrivalsCreateOrConnectWithoutArrivalItemsInput
    upsert?: ArrivalsUpsertWithoutArrivalItemsInput
    connect?: ArrivalsWhereUniqueInput
    update?: XOR<XOR<ArrivalsUpdateToOneWithWhereWithoutArrivalItemsInput, ArrivalsUpdateWithoutArrivalItemsInput>, ArrivalsUncheckedUpdateWithoutArrivalItemsInput>
  }

  export type MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput = {
    create?: XOR<MaterialsCreateWithoutArrivalItemsInput, MaterialsUncheckedCreateWithoutArrivalItemsInput>
    connectOrCreate?: MaterialsCreateOrConnectWithoutArrivalItemsInput
    upsert?: MaterialsUpsertWithoutArrivalItemsInput
    connect?: MaterialsWhereUniqueInput
    update?: XOR<XOR<MaterialsUpdateToOneWithWhereWithoutArrivalItemsInput, MaterialsUpdateWithoutArrivalItemsInput>, MaterialsUncheckedUpdateWithoutArrivalItemsInput>
  }

  export type ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput = {
    create?: XOR<ConditionsCreateWithoutArrivalItemsInput, ConditionsUncheckedCreateWithoutArrivalItemsInput>
    connectOrCreate?: ConditionsCreateOrConnectWithoutArrivalItemsInput
    upsert?: ConditionsUpsertWithoutArrivalItemsInput
    connect?: ConditionsWhereUniqueInput
    update?: XOR<XOR<ConditionsUpdateToOneWithWhereWithoutArrivalItemsInput, ConditionsUpdateWithoutArrivalItemsInput>, ConditionsUncheckedUpdateWithoutArrivalItemsInput>
  }

  export type ParametersUpdateOneWithoutArrivalItemsNestedInput = {
    create?: XOR<ParametersCreateWithoutArrivalItemsInput, ParametersUncheckedCreateWithoutArrivalItemsInput>
    connectOrCreate?: ParametersCreateOrConnectWithoutArrivalItemsInput
    upsert?: ParametersUpsertWithoutArrivalItemsInput
    disconnect?: ParametersWhereInput | boolean
    delete?: ParametersWhereInput | boolean
    connect?: ParametersWhereUniqueInput
    update?: XOR<XOR<ParametersUpdateToOneWithWhereWithoutArrivalItemsInput, ParametersUpdateWithoutArrivalItemsInput>, ParametersUncheckedUpdateWithoutArrivalItemsInput>
  }

  export type QcStatusUpdateOneWithoutArrivalItemsNestedInput = {
    create?: XOR<QcStatusCreateWithoutArrivalItemsInput, QcStatusUncheckedCreateWithoutArrivalItemsInput>
    connectOrCreate?: QcStatusCreateOrConnectWithoutArrivalItemsInput
    upsert?: QcStatusUpsertWithoutArrivalItemsInput
    disconnect?: QcStatusWhereInput | boolean
    delete?: QcStatusWhereInput | boolean
    connect?: QcStatusWhereUniqueInput
    update?: XOR<XOR<QcStatusUpdateToOneWithWhereWithoutArrivalItemsInput, QcStatusUpdateWithoutArrivalItemsInput>, QcStatusUncheckedUpdateWithoutArrivalItemsInput>
  }

  export type QcResultsUpdateManyWithoutArrivalItemNestedInput = {
    create?: XOR<QcResultsCreateWithoutArrivalItemInput, QcResultsUncheckedCreateWithoutArrivalItemInput> | QcResultsCreateWithoutArrivalItemInput[] | QcResultsUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutArrivalItemInput | QcResultsCreateOrConnectWithoutArrivalItemInput[]
    upsert?: QcResultsUpsertWithWhereUniqueWithoutArrivalItemInput | QcResultsUpsertWithWhereUniqueWithoutArrivalItemInput[]
    createMany?: QcResultsCreateManyArrivalItemInputEnvelope
    set?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    disconnect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    delete?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    update?: QcResultsUpdateWithWhereUniqueWithoutArrivalItemInput | QcResultsUpdateWithWhereUniqueWithoutArrivalItemInput[]
    updateMany?: QcResultsUpdateManyWithWhereWithoutArrivalItemInput | QcResultsUpdateManyWithWhereWithoutArrivalItemInput[]
    deleteMany?: QcResultsScalarWhereInput | QcResultsScalarWhereInput[]
  }

  export type QcPhotosUpdateManyWithoutArrivalItemNestedInput = {
    create?: XOR<QcPhotosCreateWithoutArrivalItemInput, QcPhotosUncheckedCreateWithoutArrivalItemInput> | QcPhotosCreateWithoutArrivalItemInput[] | QcPhotosUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcPhotosCreateOrConnectWithoutArrivalItemInput | QcPhotosCreateOrConnectWithoutArrivalItemInput[]
    upsert?: QcPhotosUpsertWithWhereUniqueWithoutArrivalItemInput | QcPhotosUpsertWithWhereUniqueWithoutArrivalItemInput[]
    createMany?: QcPhotosCreateManyArrivalItemInputEnvelope
    set?: QcPhotosWhereUniqueInput | QcPhotosWhereUniqueInput[]
    disconnect?: QcPhotosWhereUniqueInput | QcPhotosWhereUniqueInput[]
    delete?: QcPhotosWhereUniqueInput | QcPhotosWhereUniqueInput[]
    connect?: QcPhotosWhereUniqueInput | QcPhotosWhereUniqueInput[]
    update?: QcPhotosUpdateWithWhereUniqueWithoutArrivalItemInput | QcPhotosUpdateWithWhereUniqueWithoutArrivalItemInput[]
    updateMany?: QcPhotosUpdateManyWithWhereWithoutArrivalItemInput | QcPhotosUpdateManyWithWhereWithoutArrivalItemInput[]
    deleteMany?: QcPhotosScalarWhereInput | QcPhotosScalarWhereInput[]
  }

  export type WeighingsUpdateManyWithoutArrivalItemNestedInput = {
    create?: XOR<WeighingsCreateWithoutArrivalItemInput, WeighingsUncheckedCreateWithoutArrivalItemInput> | WeighingsCreateWithoutArrivalItemInput[] | WeighingsUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: WeighingsCreateOrConnectWithoutArrivalItemInput | WeighingsCreateOrConnectWithoutArrivalItemInput[]
    upsert?: WeighingsUpsertWithWhereUniqueWithoutArrivalItemInput | WeighingsUpsertWithWhereUniqueWithoutArrivalItemInput[]
    createMany?: WeighingsCreateManyArrivalItemInputEnvelope
    set?: WeighingsWhereUniqueInput | WeighingsWhereUniqueInput[]
    disconnect?: WeighingsWhereUniqueInput | WeighingsWhereUniqueInput[]
    delete?: WeighingsWhereUniqueInput | WeighingsWhereUniqueInput[]
    connect?: WeighingsWhereUniqueInput | WeighingsWhereUniqueInput[]
    update?: WeighingsUpdateWithWhereUniqueWithoutArrivalItemInput | WeighingsUpdateWithWhereUniqueWithoutArrivalItemInput[]
    updateMany?: WeighingsUpdateManyWithWhereWithoutArrivalItemInput | WeighingsUpdateManyWithWhereWithoutArrivalItemInput[]
    deleteMany?: WeighingsScalarWhereInput | WeighingsScalarWhereInput[]
  }

  export type WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput = {
    create?: XOR<WeighingsPhotosCreateWithoutArrivalItemInput, WeighingsPhotosUncheckedCreateWithoutArrivalItemInput> | WeighingsPhotosCreateWithoutArrivalItemInput[] | WeighingsPhotosUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: WeighingsPhotosCreateOrConnectWithoutArrivalItemInput | WeighingsPhotosCreateOrConnectWithoutArrivalItemInput[]
    upsert?: WeighingsPhotosUpsertWithWhereUniqueWithoutArrivalItemInput | WeighingsPhotosUpsertWithWhereUniqueWithoutArrivalItemInput[]
    createMany?: WeighingsPhotosCreateManyArrivalItemInputEnvelope
    set?: WeighingsPhotosWhereUniqueInput | WeighingsPhotosWhereUniqueInput[]
    disconnect?: WeighingsPhotosWhereUniqueInput | WeighingsPhotosWhereUniqueInput[]
    delete?: WeighingsPhotosWhereUniqueInput | WeighingsPhotosWhereUniqueInput[]
    connect?: WeighingsPhotosWhereUniqueInput | WeighingsPhotosWhereUniqueInput[]
    update?: WeighingsPhotosUpdateWithWhereUniqueWithoutArrivalItemInput | WeighingsPhotosUpdateWithWhereUniqueWithoutArrivalItemInput[]
    updateMany?: WeighingsPhotosUpdateManyWithWhereWithoutArrivalItemInput | WeighingsPhotosUpdateManyWithWhereWithoutArrivalItemInput[]
    deleteMany?: WeighingsPhotosScalarWhereInput | WeighingsPhotosScalarWhereInput[]
  }

  export type QcHistoriesUpdateManyWithoutArrivalItemNestedInput = {
    create?: XOR<QcHistoriesCreateWithoutArrivalItemInput, QcHistoriesUncheckedCreateWithoutArrivalItemInput> | QcHistoriesCreateWithoutArrivalItemInput[] | QcHistoriesUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutArrivalItemInput | QcHistoriesCreateOrConnectWithoutArrivalItemInput[]
    upsert?: QcHistoriesUpsertWithWhereUniqueWithoutArrivalItemInput | QcHistoriesUpsertWithWhereUniqueWithoutArrivalItemInput[]
    createMany?: QcHistoriesCreateManyArrivalItemInputEnvelope
    set?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    disconnect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    delete?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    update?: QcHistoriesUpdateWithWhereUniqueWithoutArrivalItemInput | QcHistoriesUpdateWithWhereUniqueWithoutArrivalItemInput[]
    updateMany?: QcHistoriesUpdateManyWithWhereWithoutArrivalItemInput | QcHistoriesUpdateManyWithWhereWithoutArrivalItemInput[]
    deleteMany?: QcHistoriesScalarWhereInput | QcHistoriesScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput = {
    create?: XOR<QcResultsCreateWithoutArrivalItemInput, QcResultsUncheckedCreateWithoutArrivalItemInput> | QcResultsCreateWithoutArrivalItemInput[] | QcResultsUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutArrivalItemInput | QcResultsCreateOrConnectWithoutArrivalItemInput[]
    upsert?: QcResultsUpsertWithWhereUniqueWithoutArrivalItemInput | QcResultsUpsertWithWhereUniqueWithoutArrivalItemInput[]
    createMany?: QcResultsCreateManyArrivalItemInputEnvelope
    set?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    disconnect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    delete?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    update?: QcResultsUpdateWithWhereUniqueWithoutArrivalItemInput | QcResultsUpdateWithWhereUniqueWithoutArrivalItemInput[]
    updateMany?: QcResultsUpdateManyWithWhereWithoutArrivalItemInput | QcResultsUpdateManyWithWhereWithoutArrivalItemInput[]
    deleteMany?: QcResultsScalarWhereInput | QcResultsScalarWhereInput[]
  }

  export type QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput = {
    create?: XOR<QcPhotosCreateWithoutArrivalItemInput, QcPhotosUncheckedCreateWithoutArrivalItemInput> | QcPhotosCreateWithoutArrivalItemInput[] | QcPhotosUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcPhotosCreateOrConnectWithoutArrivalItemInput | QcPhotosCreateOrConnectWithoutArrivalItemInput[]
    upsert?: QcPhotosUpsertWithWhereUniqueWithoutArrivalItemInput | QcPhotosUpsertWithWhereUniqueWithoutArrivalItemInput[]
    createMany?: QcPhotosCreateManyArrivalItemInputEnvelope
    set?: QcPhotosWhereUniqueInput | QcPhotosWhereUniqueInput[]
    disconnect?: QcPhotosWhereUniqueInput | QcPhotosWhereUniqueInput[]
    delete?: QcPhotosWhereUniqueInput | QcPhotosWhereUniqueInput[]
    connect?: QcPhotosWhereUniqueInput | QcPhotosWhereUniqueInput[]
    update?: QcPhotosUpdateWithWhereUniqueWithoutArrivalItemInput | QcPhotosUpdateWithWhereUniqueWithoutArrivalItemInput[]
    updateMany?: QcPhotosUpdateManyWithWhereWithoutArrivalItemInput | QcPhotosUpdateManyWithWhereWithoutArrivalItemInput[]
    deleteMany?: QcPhotosScalarWhereInput | QcPhotosScalarWhereInput[]
  }

  export type WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput = {
    create?: XOR<WeighingsCreateWithoutArrivalItemInput, WeighingsUncheckedCreateWithoutArrivalItemInput> | WeighingsCreateWithoutArrivalItemInput[] | WeighingsUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: WeighingsCreateOrConnectWithoutArrivalItemInput | WeighingsCreateOrConnectWithoutArrivalItemInput[]
    upsert?: WeighingsUpsertWithWhereUniqueWithoutArrivalItemInput | WeighingsUpsertWithWhereUniqueWithoutArrivalItemInput[]
    createMany?: WeighingsCreateManyArrivalItemInputEnvelope
    set?: WeighingsWhereUniqueInput | WeighingsWhereUniqueInput[]
    disconnect?: WeighingsWhereUniqueInput | WeighingsWhereUniqueInput[]
    delete?: WeighingsWhereUniqueInput | WeighingsWhereUniqueInput[]
    connect?: WeighingsWhereUniqueInput | WeighingsWhereUniqueInput[]
    update?: WeighingsUpdateWithWhereUniqueWithoutArrivalItemInput | WeighingsUpdateWithWhereUniqueWithoutArrivalItemInput[]
    updateMany?: WeighingsUpdateManyWithWhereWithoutArrivalItemInput | WeighingsUpdateManyWithWhereWithoutArrivalItemInput[]
    deleteMany?: WeighingsScalarWhereInput | WeighingsScalarWhereInput[]
  }

  export type WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput = {
    create?: XOR<WeighingsPhotosCreateWithoutArrivalItemInput, WeighingsPhotosUncheckedCreateWithoutArrivalItemInput> | WeighingsPhotosCreateWithoutArrivalItemInput[] | WeighingsPhotosUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: WeighingsPhotosCreateOrConnectWithoutArrivalItemInput | WeighingsPhotosCreateOrConnectWithoutArrivalItemInput[]
    upsert?: WeighingsPhotosUpsertWithWhereUniqueWithoutArrivalItemInput | WeighingsPhotosUpsertWithWhereUniqueWithoutArrivalItemInput[]
    createMany?: WeighingsPhotosCreateManyArrivalItemInputEnvelope
    set?: WeighingsPhotosWhereUniqueInput | WeighingsPhotosWhereUniqueInput[]
    disconnect?: WeighingsPhotosWhereUniqueInput | WeighingsPhotosWhereUniqueInput[]
    delete?: WeighingsPhotosWhereUniqueInput | WeighingsPhotosWhereUniqueInput[]
    connect?: WeighingsPhotosWhereUniqueInput | WeighingsPhotosWhereUniqueInput[]
    update?: WeighingsPhotosUpdateWithWhereUniqueWithoutArrivalItemInput | WeighingsPhotosUpdateWithWhereUniqueWithoutArrivalItemInput[]
    updateMany?: WeighingsPhotosUpdateManyWithWhereWithoutArrivalItemInput | WeighingsPhotosUpdateManyWithWhereWithoutArrivalItemInput[]
    deleteMany?: WeighingsPhotosScalarWhereInput | WeighingsPhotosScalarWhereInput[]
  }

  export type QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput = {
    create?: XOR<QcHistoriesCreateWithoutArrivalItemInput, QcHistoriesUncheckedCreateWithoutArrivalItemInput> | QcHistoriesCreateWithoutArrivalItemInput[] | QcHistoriesUncheckedCreateWithoutArrivalItemInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutArrivalItemInput | QcHistoriesCreateOrConnectWithoutArrivalItemInput[]
    upsert?: QcHistoriesUpsertWithWhereUniqueWithoutArrivalItemInput | QcHistoriesUpsertWithWhereUniqueWithoutArrivalItemInput[]
    createMany?: QcHistoriesCreateManyArrivalItemInputEnvelope
    set?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    disconnect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    delete?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    update?: QcHistoriesUpdateWithWhereUniqueWithoutArrivalItemInput | QcHistoriesUpdateWithWhereUniqueWithoutArrivalItemInput[]
    updateMany?: QcHistoriesUpdateManyWithWhereWithoutArrivalItemInput | QcHistoriesUpdateManyWithWhereWithoutArrivalItemInput[]
    deleteMany?: QcHistoriesScalarWhereInput | QcHistoriesScalarWhereInput[]
  }

  export type ArrivalItemsCreateNestedOneWithoutWeighingsInput = {
    create?: XOR<ArrivalItemsCreateWithoutWeighingsInput, ArrivalItemsUncheckedCreateWithoutWeighingsInput>
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutWeighingsInput
    connect?: ArrivalItemsWhereUniqueInput
  }

  export type ArrivalItemsUpdateOneRequiredWithoutWeighingsNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutWeighingsInput, ArrivalItemsUncheckedCreateWithoutWeighingsInput>
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutWeighingsInput
    upsert?: ArrivalItemsUpsertWithoutWeighingsInput
    connect?: ArrivalItemsWhereUniqueInput
    update?: XOR<XOR<ArrivalItemsUpdateToOneWithWhereWithoutWeighingsInput, ArrivalItemsUpdateWithoutWeighingsInput>, ArrivalItemsUncheckedUpdateWithoutWeighingsInput>
  }

  export type ArrivalItemsCreateNestedOneWithoutQcResultsInput = {
    create?: XOR<ArrivalItemsCreateWithoutQcResultsInput, ArrivalItemsUncheckedCreateWithoutQcResultsInput>
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutQcResultsInput
    connect?: ArrivalItemsWhereUniqueInput
  }

  export type ParametersCreateNestedOneWithoutQcResultsInput = {
    create?: XOR<ParametersCreateWithoutQcResultsInput, ParametersUncheckedCreateWithoutQcResultsInput>
    connectOrCreate?: ParametersCreateOrConnectWithoutQcResultsInput
    connect?: ParametersWhereUniqueInput
  }

  export type QcHistoriesCreateNestedOneWithoutQcResultsInput = {
    create?: XOR<QcHistoriesCreateWithoutQcResultsInput, QcHistoriesUncheckedCreateWithoutQcResultsInput>
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutQcResultsInput
    connect?: QcHistoriesWhereUniqueInput
  }

  export type ArrivalItemsUpdateOneRequiredWithoutQcResultsNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutQcResultsInput, ArrivalItemsUncheckedCreateWithoutQcResultsInput>
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutQcResultsInput
    upsert?: ArrivalItemsUpsertWithoutQcResultsInput
    connect?: ArrivalItemsWhereUniqueInput
    update?: XOR<XOR<ArrivalItemsUpdateToOneWithWhereWithoutQcResultsInput, ArrivalItemsUpdateWithoutQcResultsInput>, ArrivalItemsUncheckedUpdateWithoutQcResultsInput>
  }

  export type ParametersUpdateOneWithoutQcResultsNestedInput = {
    create?: XOR<ParametersCreateWithoutQcResultsInput, ParametersUncheckedCreateWithoutQcResultsInput>
    connectOrCreate?: ParametersCreateOrConnectWithoutQcResultsInput
    upsert?: ParametersUpsertWithoutQcResultsInput
    disconnect?: ParametersWhereInput | boolean
    delete?: ParametersWhereInput | boolean
    connect?: ParametersWhereUniqueInput
    update?: XOR<XOR<ParametersUpdateToOneWithWhereWithoutQcResultsInput, ParametersUpdateWithoutQcResultsInput>, ParametersUncheckedUpdateWithoutQcResultsInput>
  }

  export type QcHistoriesUpdateOneWithoutQcResultsNestedInput = {
    create?: XOR<QcHistoriesCreateWithoutQcResultsInput, QcHistoriesUncheckedCreateWithoutQcResultsInput>
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutQcResultsInput
    upsert?: QcHistoriesUpsertWithoutQcResultsInput
    disconnect?: QcHistoriesWhereInput | boolean
    delete?: QcHistoriesWhereInput | boolean
    connect?: QcHistoriesWhereUniqueInput
    update?: XOR<XOR<QcHistoriesUpdateToOneWithWhereWithoutQcResultsInput, QcHistoriesUpdateWithoutQcResultsInput>, QcHistoriesUncheckedUpdateWithoutQcResultsInput>
  }

  export type ArrivalItemsCreateNestedManyWithoutQcStatusInput = {
    create?: XOR<ArrivalItemsCreateWithoutQcStatusInput, ArrivalItemsUncheckedCreateWithoutQcStatusInput> | ArrivalItemsCreateWithoutQcStatusInput[] | ArrivalItemsUncheckedCreateWithoutQcStatusInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutQcStatusInput | ArrivalItemsCreateOrConnectWithoutQcStatusInput[]
    createMany?: ArrivalItemsCreateManyQcStatusInputEnvelope
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
  }

  export type QcHistoriesCreateNestedManyWithoutStatusInput = {
    create?: XOR<QcHistoriesCreateWithoutStatusInput, QcHistoriesUncheckedCreateWithoutStatusInput> | QcHistoriesCreateWithoutStatusInput[] | QcHistoriesUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutStatusInput | QcHistoriesCreateOrConnectWithoutStatusInput[]
    createMany?: QcHistoriesCreateManyStatusInputEnvelope
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
  }

  export type ArrivalItemsUncheckedCreateNestedManyWithoutQcStatusInput = {
    create?: XOR<ArrivalItemsCreateWithoutQcStatusInput, ArrivalItemsUncheckedCreateWithoutQcStatusInput> | ArrivalItemsCreateWithoutQcStatusInput[] | ArrivalItemsUncheckedCreateWithoutQcStatusInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutQcStatusInput | ArrivalItemsCreateOrConnectWithoutQcStatusInput[]
    createMany?: ArrivalItemsCreateManyQcStatusInputEnvelope
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
  }

  export type QcHistoriesUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<QcHistoriesCreateWithoutStatusInput, QcHistoriesUncheckedCreateWithoutStatusInput> | QcHistoriesCreateWithoutStatusInput[] | QcHistoriesUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutStatusInput | QcHistoriesCreateOrConnectWithoutStatusInput[]
    createMany?: QcHistoriesCreateManyStatusInputEnvelope
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
  }

  export type ArrivalItemsUpdateManyWithoutQcStatusNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutQcStatusInput, ArrivalItemsUncheckedCreateWithoutQcStatusInput> | ArrivalItemsCreateWithoutQcStatusInput[] | ArrivalItemsUncheckedCreateWithoutQcStatusInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutQcStatusInput | ArrivalItemsCreateOrConnectWithoutQcStatusInput[]
    upsert?: ArrivalItemsUpsertWithWhereUniqueWithoutQcStatusInput | ArrivalItemsUpsertWithWhereUniqueWithoutQcStatusInput[]
    createMany?: ArrivalItemsCreateManyQcStatusInputEnvelope
    set?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    disconnect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    delete?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    update?: ArrivalItemsUpdateWithWhereUniqueWithoutQcStatusInput | ArrivalItemsUpdateWithWhereUniqueWithoutQcStatusInput[]
    updateMany?: ArrivalItemsUpdateManyWithWhereWithoutQcStatusInput | ArrivalItemsUpdateManyWithWhereWithoutQcStatusInput[]
    deleteMany?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
  }

  export type QcHistoriesUpdateManyWithoutStatusNestedInput = {
    create?: XOR<QcHistoriesCreateWithoutStatusInput, QcHistoriesUncheckedCreateWithoutStatusInput> | QcHistoriesCreateWithoutStatusInput[] | QcHistoriesUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutStatusInput | QcHistoriesCreateOrConnectWithoutStatusInput[]
    upsert?: QcHistoriesUpsertWithWhereUniqueWithoutStatusInput | QcHistoriesUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: QcHistoriesCreateManyStatusInputEnvelope
    set?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    disconnect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    delete?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    update?: QcHistoriesUpdateWithWhereUniqueWithoutStatusInput | QcHistoriesUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: QcHistoriesUpdateManyWithWhereWithoutStatusInput | QcHistoriesUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: QcHistoriesScalarWhereInput | QcHistoriesScalarWhereInput[]
  }

  export type ArrivalItemsUncheckedUpdateManyWithoutQcStatusNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutQcStatusInput, ArrivalItemsUncheckedCreateWithoutQcStatusInput> | ArrivalItemsCreateWithoutQcStatusInput[] | ArrivalItemsUncheckedCreateWithoutQcStatusInput[]
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutQcStatusInput | ArrivalItemsCreateOrConnectWithoutQcStatusInput[]
    upsert?: ArrivalItemsUpsertWithWhereUniqueWithoutQcStatusInput | ArrivalItemsUpsertWithWhereUniqueWithoutQcStatusInput[]
    createMany?: ArrivalItemsCreateManyQcStatusInputEnvelope
    set?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    disconnect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    delete?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    connect?: ArrivalItemsWhereUniqueInput | ArrivalItemsWhereUniqueInput[]
    update?: ArrivalItemsUpdateWithWhereUniqueWithoutQcStatusInput | ArrivalItemsUpdateWithWhereUniqueWithoutQcStatusInput[]
    updateMany?: ArrivalItemsUpdateManyWithWhereWithoutQcStatusInput | ArrivalItemsUpdateManyWithWhereWithoutQcStatusInput[]
    deleteMany?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
  }

  export type QcHistoriesUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<QcHistoriesCreateWithoutStatusInput, QcHistoriesUncheckedCreateWithoutStatusInput> | QcHistoriesCreateWithoutStatusInput[] | QcHistoriesUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: QcHistoriesCreateOrConnectWithoutStatusInput | QcHistoriesCreateOrConnectWithoutStatusInput[]
    upsert?: QcHistoriesUpsertWithWhereUniqueWithoutStatusInput | QcHistoriesUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: QcHistoriesCreateManyStatusInputEnvelope
    set?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    disconnect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    delete?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    connect?: QcHistoriesWhereUniqueInput | QcHistoriesWhereUniqueInput[]
    update?: QcHistoriesUpdateWithWhereUniqueWithoutStatusInput | QcHistoriesUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: QcHistoriesUpdateManyWithWhereWithoutStatusInput | QcHistoriesUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: QcHistoriesScalarWhereInput | QcHistoriesScalarWhereInput[]
  }

  export type ArrivalItemsCreateNestedOneWithoutQcPhotosInput = {
    create?: XOR<ArrivalItemsCreateWithoutQcPhotosInput, ArrivalItemsUncheckedCreateWithoutQcPhotosInput>
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutQcPhotosInput
    connect?: ArrivalItemsWhereUniqueInput
  }

  export type ArrivalItemsUpdateOneRequiredWithoutQcPhotosNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutQcPhotosInput, ArrivalItemsUncheckedCreateWithoutQcPhotosInput>
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutQcPhotosInput
    upsert?: ArrivalItemsUpsertWithoutQcPhotosInput
    connect?: ArrivalItemsWhereUniqueInput
    update?: XOR<XOR<ArrivalItemsUpdateToOneWithWhereWithoutQcPhotosInput, ArrivalItemsUpdateWithoutQcPhotosInput>, ArrivalItemsUncheckedUpdateWithoutQcPhotosInput>
  }

  export type ArrivalsCreateNestedOneWithoutSecurityPhotosInput = {
    create?: XOR<ArrivalsCreateWithoutSecurityPhotosInput, ArrivalsUncheckedCreateWithoutSecurityPhotosInput>
    connectOrCreate?: ArrivalsCreateOrConnectWithoutSecurityPhotosInput
    connect?: ArrivalsWhereUniqueInput
  }

  export type ArrivalsUpdateOneRequiredWithoutSecurityPhotosNestedInput = {
    create?: XOR<ArrivalsCreateWithoutSecurityPhotosInput, ArrivalsUncheckedCreateWithoutSecurityPhotosInput>
    connectOrCreate?: ArrivalsCreateOrConnectWithoutSecurityPhotosInput
    upsert?: ArrivalsUpsertWithoutSecurityPhotosInput
    connect?: ArrivalsWhereUniqueInput
    update?: XOR<XOR<ArrivalsUpdateToOneWithWhereWithoutSecurityPhotosInput, ArrivalsUpdateWithoutSecurityPhotosInput>, ArrivalsUncheckedUpdateWithoutSecurityPhotosInput>
  }

  export type ArrivalItemsCreateNestedOneWithoutWeighingsPhotosInput = {
    create?: XOR<ArrivalItemsCreateWithoutWeighingsPhotosInput, ArrivalItemsUncheckedCreateWithoutWeighingsPhotosInput>
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutWeighingsPhotosInput
    connect?: ArrivalItemsWhereUniqueInput
  }

  export type ArrivalItemsUpdateOneRequiredWithoutWeighingsPhotosNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutWeighingsPhotosInput, ArrivalItemsUncheckedCreateWithoutWeighingsPhotosInput>
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutWeighingsPhotosInput
    upsert?: ArrivalItemsUpsertWithoutWeighingsPhotosInput
    connect?: ArrivalItemsWhereUniqueInput
    update?: XOR<XOR<ArrivalItemsUpdateToOneWithWhereWithoutWeighingsPhotosInput, ArrivalItemsUpdateWithoutWeighingsPhotosInput>, ArrivalItemsUncheckedUpdateWithoutWeighingsPhotosInput>
  }

  export type UsersCreateNestedOneWithoutQcHistoriesInput = {
    create?: XOR<UsersCreateWithoutQcHistoriesInput, UsersUncheckedCreateWithoutQcHistoriesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutQcHistoriesInput
    connect?: UsersWhereUniqueInput
  }

  export type QcStatusCreateNestedOneWithoutQcHistoriesInput = {
    create?: XOR<QcStatusCreateWithoutQcHistoriesInput, QcStatusUncheckedCreateWithoutQcHistoriesInput>
    connectOrCreate?: QcStatusCreateOrConnectWithoutQcHistoriesInput
    connect?: QcStatusWhereUniqueInput
  }

  export type ArrivalsCreateNestedOneWithoutQcHistoriesInput = {
    create?: XOR<ArrivalsCreateWithoutQcHistoriesInput, ArrivalsUncheckedCreateWithoutQcHistoriesInput>
    connectOrCreate?: ArrivalsCreateOrConnectWithoutQcHistoriesInput
    connect?: ArrivalsWhereUniqueInput
  }

  export type ArrivalItemsCreateNestedOneWithoutQcHistoriesInput = {
    create?: XOR<ArrivalItemsCreateWithoutQcHistoriesInput, ArrivalItemsUncheckedCreateWithoutQcHistoriesInput>
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutQcHistoriesInput
    connect?: ArrivalItemsWhereUniqueInput
  }

  export type QcResultsCreateNestedManyWithoutHistoryInput = {
    create?: XOR<QcResultsCreateWithoutHistoryInput, QcResultsUncheckedCreateWithoutHistoryInput> | QcResultsCreateWithoutHistoryInput[] | QcResultsUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutHistoryInput | QcResultsCreateOrConnectWithoutHistoryInput[]
    createMany?: QcResultsCreateManyHistoryInputEnvelope
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
  }

  export type QcResultsUncheckedCreateNestedManyWithoutHistoryInput = {
    create?: XOR<QcResultsCreateWithoutHistoryInput, QcResultsUncheckedCreateWithoutHistoryInput> | QcResultsCreateWithoutHistoryInput[] | QcResultsUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutHistoryInput | QcResultsCreateOrConnectWithoutHistoryInput[]
    createMany?: QcResultsCreateManyHistoryInputEnvelope
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
  }

  export type UsersUpdateOneRequiredWithoutQcHistoriesNestedInput = {
    create?: XOR<UsersCreateWithoutQcHistoriesInput, UsersUncheckedCreateWithoutQcHistoriesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutQcHistoriesInput
    upsert?: UsersUpsertWithoutQcHistoriesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutQcHistoriesInput, UsersUpdateWithoutQcHistoriesInput>, UsersUncheckedUpdateWithoutQcHistoriesInput>
  }

  export type QcStatusUpdateOneRequiredWithoutQcHistoriesNestedInput = {
    create?: XOR<QcStatusCreateWithoutQcHistoriesInput, QcStatusUncheckedCreateWithoutQcHistoriesInput>
    connectOrCreate?: QcStatusCreateOrConnectWithoutQcHistoriesInput
    upsert?: QcStatusUpsertWithoutQcHistoriesInput
    connect?: QcStatusWhereUniqueInput
    update?: XOR<XOR<QcStatusUpdateToOneWithWhereWithoutQcHistoriesInput, QcStatusUpdateWithoutQcHistoriesInput>, QcStatusUncheckedUpdateWithoutQcHistoriesInput>
  }

  export type ArrivalsUpdateOneWithoutQcHistoriesNestedInput = {
    create?: XOR<ArrivalsCreateWithoutQcHistoriesInput, ArrivalsUncheckedCreateWithoutQcHistoriesInput>
    connectOrCreate?: ArrivalsCreateOrConnectWithoutQcHistoriesInput
    upsert?: ArrivalsUpsertWithoutQcHistoriesInput
    disconnect?: ArrivalsWhereInput | boolean
    delete?: ArrivalsWhereInput | boolean
    connect?: ArrivalsWhereUniqueInput
    update?: XOR<XOR<ArrivalsUpdateToOneWithWhereWithoutQcHistoriesInput, ArrivalsUpdateWithoutQcHistoriesInput>, ArrivalsUncheckedUpdateWithoutQcHistoriesInput>
  }

  export type ArrivalItemsUpdateOneWithoutQcHistoriesNestedInput = {
    create?: XOR<ArrivalItemsCreateWithoutQcHistoriesInput, ArrivalItemsUncheckedCreateWithoutQcHistoriesInput>
    connectOrCreate?: ArrivalItemsCreateOrConnectWithoutQcHistoriesInput
    upsert?: ArrivalItemsUpsertWithoutQcHistoriesInput
    disconnect?: ArrivalItemsWhereInput | boolean
    delete?: ArrivalItemsWhereInput | boolean
    connect?: ArrivalItemsWhereUniqueInput
    update?: XOR<XOR<ArrivalItemsUpdateToOneWithWhereWithoutQcHistoriesInput, ArrivalItemsUpdateWithoutQcHistoriesInput>, ArrivalItemsUncheckedUpdateWithoutQcHistoriesInput>
  }

  export type QcResultsUpdateManyWithoutHistoryNestedInput = {
    create?: XOR<QcResultsCreateWithoutHistoryInput, QcResultsUncheckedCreateWithoutHistoryInput> | QcResultsCreateWithoutHistoryInput[] | QcResultsUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutHistoryInput | QcResultsCreateOrConnectWithoutHistoryInput[]
    upsert?: QcResultsUpsertWithWhereUniqueWithoutHistoryInput | QcResultsUpsertWithWhereUniqueWithoutHistoryInput[]
    createMany?: QcResultsCreateManyHistoryInputEnvelope
    set?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    disconnect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    delete?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    update?: QcResultsUpdateWithWhereUniqueWithoutHistoryInput | QcResultsUpdateWithWhereUniqueWithoutHistoryInput[]
    updateMany?: QcResultsUpdateManyWithWhereWithoutHistoryInput | QcResultsUpdateManyWithWhereWithoutHistoryInput[]
    deleteMany?: QcResultsScalarWhereInput | QcResultsScalarWhereInput[]
  }

  export type QcResultsUncheckedUpdateManyWithoutHistoryNestedInput = {
    create?: XOR<QcResultsCreateWithoutHistoryInput, QcResultsUncheckedCreateWithoutHistoryInput> | QcResultsCreateWithoutHistoryInput[] | QcResultsUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: QcResultsCreateOrConnectWithoutHistoryInput | QcResultsCreateOrConnectWithoutHistoryInput[]
    upsert?: QcResultsUpsertWithWhereUniqueWithoutHistoryInput | QcResultsUpsertWithWhereUniqueWithoutHistoryInput[]
    createMany?: QcResultsCreateManyHistoryInputEnvelope
    set?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    disconnect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    delete?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    connect?: QcResultsWhereUniqueInput | QcResultsWhereUniqueInput[]
    update?: QcResultsUpdateWithWhereUniqueWithoutHistoryInput | QcResultsUpdateWithWhereUniqueWithoutHistoryInput[]
    updateMany?: QcResultsUpdateManyWithWhereWithoutHistoryInput | QcResultsUpdateManyWithWhereWithoutHistoryInput[]
    deleteMany?: QcResultsScalarWhereInput | QcResultsScalarWhereInput[]
  }

  export type ArrivalsCreateNestedOneWithoutArrivalStatusesInput = {
    create?: XOR<ArrivalsCreateWithoutArrivalStatusesInput, ArrivalsUncheckedCreateWithoutArrivalStatusesInput>
    connectOrCreate?: ArrivalsCreateOrConnectWithoutArrivalStatusesInput
    connect?: ArrivalsWhereUniqueInput
  }

  export type ArrivalsUpdateOneRequiredWithoutArrivalStatusesNestedInput = {
    create?: XOR<ArrivalsCreateWithoutArrivalStatusesInput, ArrivalsUncheckedCreateWithoutArrivalStatusesInput>
    connectOrCreate?: ArrivalsCreateOrConnectWithoutArrivalStatusesInput
    upsert?: ArrivalsUpsertWithoutArrivalStatusesInput
    connect?: ArrivalsWhereUniqueInput
    update?: XOR<XOR<ArrivalsUpdateToOneWithWhereWithoutArrivalStatusesInput, ArrivalsUpdateWithoutArrivalStatusesInput>, ArrivalsUncheckedUpdateWithoutArrivalStatusesInput>
  }

  export type ParametersCreateNestedOneWithoutSettingsInput = {
    create?: XOR<ParametersCreateWithoutSettingsInput, ParametersUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: ParametersCreateOrConnectWithoutSettingsInput
    connect?: ParametersWhereUniqueInput
  }

  export type ParametersUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<ParametersCreateWithoutSettingsInput, ParametersUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: ParametersCreateOrConnectWithoutSettingsInput
    upsert?: ParametersUpsertWithoutSettingsInput
    connect?: ParametersWhereUniqueInput
    update?: XOR<XOR<ParametersUpdateToOneWithWhereWithoutSettingsInput, ParametersUpdateWithoutSettingsInput>, ParametersUncheckedUpdateWithoutSettingsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type QcHistoriesCreateWithoutUserInput = {
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: QcStatusCreateNestedOneWithoutQcHistoriesInput
    arrival?: ArrivalsCreateNestedOneWithoutQcHistoriesInput
    arrivalItem?: ArrivalItemsCreateNestedOneWithoutQcHistoriesInput
    QcResults?: QcResultsCreateNestedManyWithoutHistoryInput
  }

  export type QcHistoriesUncheckedCreateWithoutUserInput = {
    id?: number
    statusId: number
    arrivalId?: number | null
    arrivalItemId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type QcHistoriesCreateOrConnectWithoutUserInput = {
    where: QcHistoriesWhereUniqueInput
    create: XOR<QcHistoriesCreateWithoutUserInput, QcHistoriesUncheckedCreateWithoutUserInput>
  }

  export type QcHistoriesCreateManyUserInputEnvelope = {
    data: QcHistoriesCreateManyUserInput | QcHistoriesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QcHistoriesUpsertWithWhereUniqueWithoutUserInput = {
    where: QcHistoriesWhereUniqueInput
    update: XOR<QcHistoriesUpdateWithoutUserInput, QcHistoriesUncheckedUpdateWithoutUserInput>
    create: XOR<QcHistoriesCreateWithoutUserInput, QcHistoriesUncheckedCreateWithoutUserInput>
  }

  export type QcHistoriesUpdateWithWhereUniqueWithoutUserInput = {
    where: QcHistoriesWhereUniqueInput
    data: XOR<QcHistoriesUpdateWithoutUserInput, QcHistoriesUncheckedUpdateWithoutUserInput>
  }

  export type QcHistoriesUpdateManyWithWhereWithoutUserInput = {
    where: QcHistoriesScalarWhereInput
    data: XOR<QcHistoriesUpdateManyMutationInput, QcHistoriesUncheckedUpdateManyWithoutUserInput>
  }

  export type QcHistoriesScalarWhereInput = {
    AND?: QcHistoriesScalarWhereInput | QcHistoriesScalarWhereInput[]
    OR?: QcHistoriesScalarWhereInput[]
    NOT?: QcHistoriesScalarWhereInput | QcHistoriesScalarWhereInput[]
    id?: IntFilter<"QcHistories"> | number
    userId?: StringFilter<"QcHistories"> | string
    statusId?: IntFilter<"QcHistories"> | number
    arrivalId?: IntNullableFilter<"QcHistories"> | number | null
    arrivalItemId?: IntNullableFilter<"QcHistories"> | number | null
    qcSample?: FloatNullableFilter<"QcHistories"> | number | null
    qcKotoran?: FloatNullableFilter<"QcHistories"> | number | null
    totalBerat?: FloatNullableFilter<"QcHistories"> | number | null
    pengeringan?: FloatNullableFilter<"QcHistories"> | number | null
    note?: StringNullableFilter<"QcHistories"> | string | null
    qcNote?: StringNullableFilter<"QcHistories"> | string | null
    createdAt?: DateTimeFilter<"QcHistories"> | Date | string
    updatedAt?: DateTimeFilter<"QcHistories"> | Date | string
  }

  export type ArrivalsCreateWithoutSupplierInput = {
    idKedatangan: string
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutArrivalInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalInput
    SecurityPhotos?: SecurityPhotosCreateNestedManyWithoutArrivalInput
    ArrivalStatuses?: ArrivalStatusesCreateNestedOneWithoutArrivalInput
  }

  export type ArrivalsUncheckedCreateWithoutSupplierInput = {
    id?: number
    idKedatangan: string
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutArrivalInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalInput
    SecurityPhotos?: SecurityPhotosUncheckedCreateNestedManyWithoutArrivalInput
    ArrivalStatuses?: ArrivalStatusesUncheckedCreateNestedOneWithoutArrivalInput
  }

  export type ArrivalsCreateOrConnectWithoutSupplierInput = {
    where: ArrivalsWhereUniqueInput
    create: XOR<ArrivalsCreateWithoutSupplierInput, ArrivalsUncheckedCreateWithoutSupplierInput>
  }

  export type ArrivalsCreateManySupplierInputEnvelope = {
    data: ArrivalsCreateManySupplierInput | ArrivalsCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalsUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ArrivalsWhereUniqueInput
    update: XOR<ArrivalsUpdateWithoutSupplierInput, ArrivalsUncheckedUpdateWithoutSupplierInput>
    create: XOR<ArrivalsCreateWithoutSupplierInput, ArrivalsUncheckedCreateWithoutSupplierInput>
  }

  export type ArrivalsUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ArrivalsWhereUniqueInput
    data: XOR<ArrivalsUpdateWithoutSupplierInput, ArrivalsUncheckedUpdateWithoutSupplierInput>
  }

  export type ArrivalsUpdateManyWithWhereWithoutSupplierInput = {
    where: ArrivalsScalarWhereInput
    data: XOR<ArrivalsUpdateManyMutationInput, ArrivalsUncheckedUpdateManyWithoutSupplierInput>
  }

  export type ArrivalsScalarWhereInput = {
    AND?: ArrivalsScalarWhereInput | ArrivalsScalarWhereInput[]
    OR?: ArrivalsScalarWhereInput[]
    NOT?: ArrivalsScalarWhereInput | ArrivalsScalarWhereInput[]
    id?: IntFilter<"Arrivals"> | number
    idKedatangan?: StringFilter<"Arrivals"> | string
    supplierId?: IntFilter<"Arrivals"> | number
    arrivalDate?: DateTimeFilter<"Arrivals"> | Date | string
    arrivalTime?: StringNullableFilter<"Arrivals"> | string | null
    nopol?: StringNullableFilter<"Arrivals"> | string | null
    suratJalan?: StringNullableFilter<"Arrivals"> | string | null
    city?: StringNullableFilter<"Arrivals"> | string | null
    note?: StringNullableFilter<"Arrivals"> | string | null
    createdAt?: DateTimeFilter<"Arrivals"> | Date | string
    createdBy?: StringNullableFilter<"Arrivals"> | string | null
    updatedAt?: DateTimeFilter<"Arrivals"> | Date | string
    updatedBy?: StringNullableFilter<"Arrivals"> | string | null
  }

  export type ArrivalItemsCreateWithoutMaterialInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    arrival: ArrivalsCreateNestedOneWithoutArrivalItemsInput
    condition: ConditionsCreateNestedOneWithoutArrivalItemsInput
    parameter?: ParametersCreateNestedOneWithoutArrivalItemsInput
    qcStatus?: QcStatusCreateNestedOneWithoutArrivalItemsInput
    QcResults?: QcResultsCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateWithoutMaterialInput = {
    id?: number
    arrivalId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsCreateOrConnectWithoutMaterialInput = {
    where: ArrivalItemsWhereUniqueInput
    create: XOR<ArrivalItemsCreateWithoutMaterialInput, ArrivalItemsUncheckedCreateWithoutMaterialInput>
  }

  export type ArrivalItemsCreateManyMaterialInputEnvelope = {
    data: ArrivalItemsCreateManyMaterialInput | ArrivalItemsCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalItemsUpsertWithWhereUniqueWithoutMaterialInput = {
    where: ArrivalItemsWhereUniqueInput
    update: XOR<ArrivalItemsUpdateWithoutMaterialInput, ArrivalItemsUncheckedUpdateWithoutMaterialInput>
    create: XOR<ArrivalItemsCreateWithoutMaterialInput, ArrivalItemsUncheckedCreateWithoutMaterialInput>
  }

  export type ArrivalItemsUpdateWithWhereUniqueWithoutMaterialInput = {
    where: ArrivalItemsWhereUniqueInput
    data: XOR<ArrivalItemsUpdateWithoutMaterialInput, ArrivalItemsUncheckedUpdateWithoutMaterialInput>
  }

  export type ArrivalItemsUpdateManyWithWhereWithoutMaterialInput = {
    where: ArrivalItemsScalarWhereInput
    data: XOR<ArrivalItemsUpdateManyMutationInput, ArrivalItemsUncheckedUpdateManyWithoutMaterialInput>
  }

  export type ArrivalItemsScalarWhereInput = {
    AND?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
    OR?: ArrivalItemsScalarWhereInput[]
    NOT?: ArrivalItemsScalarWhereInput | ArrivalItemsScalarWhereInput[]
    id?: IntFilter<"ArrivalItems"> | number
    arrivalId?: IntFilter<"ArrivalItems"> | number
    materialId?: IntFilter<"ArrivalItems"> | number
    conditionId?: IntFilter<"ArrivalItems"> | number
    parameterId?: IntNullableFilter<"ArrivalItems"> | number | null
    conditionCategory?: StringNullableFilter<"ArrivalItems"> | string | null
    quantity?: FloatFilter<"ArrivalItems"> | number
    note?: StringNullableFilter<"ArrivalItems"> | string | null
    itemName?: StringNullableFilter<"ArrivalItems"> | string | null
    qcNote?: StringNullableFilter<"ArrivalItems"> | string | null
    qcStatusId?: IntNullableFilter<"ArrivalItems"> | number | null
    qcAnalysis?: StringNullableFilter<"ArrivalItems"> | string | null
    qcSample?: FloatNullableFilter<"ArrivalItems"> | number | null
    qcKotoran?: FloatNullableFilter<"ArrivalItems"> | number | null
    totalBerat?: FloatNullableFilter<"ArrivalItems"> | number | null
    pengeringan?: FloatNullableFilter<"ArrivalItems"> | number | null
    createdAt?: DateTimeFilter<"ArrivalItems"> | Date | string
    createdBy?: StringNullableFilter<"ArrivalItems"> | string | null
    updatedAt?: DateTimeFilter<"ArrivalItems"> | Date | string
    updatedBy?: StringNullableFilter<"ArrivalItems"> | string | null
    statusQc?: BoolFilter<"ArrivalItems"> | boolean
  }

  export type ArrivalItemsCreateWithoutConditionInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    arrival: ArrivalsCreateNestedOneWithoutArrivalItemsInput
    material: MaterialsCreateNestedOneWithoutArrivalItemsInput
    parameter?: ParametersCreateNestedOneWithoutArrivalItemsInput
    qcStatus?: QcStatusCreateNestedOneWithoutArrivalItemsInput
    QcResults?: QcResultsCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateWithoutConditionInput = {
    id?: number
    arrivalId: number
    materialId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsCreateOrConnectWithoutConditionInput = {
    where: ArrivalItemsWhereUniqueInput
    create: XOR<ArrivalItemsCreateWithoutConditionInput, ArrivalItemsUncheckedCreateWithoutConditionInput>
  }

  export type ArrivalItemsCreateManyConditionInputEnvelope = {
    data: ArrivalItemsCreateManyConditionInput | ArrivalItemsCreateManyConditionInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalItemsUpsertWithWhereUniqueWithoutConditionInput = {
    where: ArrivalItemsWhereUniqueInput
    update: XOR<ArrivalItemsUpdateWithoutConditionInput, ArrivalItemsUncheckedUpdateWithoutConditionInput>
    create: XOR<ArrivalItemsCreateWithoutConditionInput, ArrivalItemsUncheckedCreateWithoutConditionInput>
  }

  export type ArrivalItemsUpdateWithWhereUniqueWithoutConditionInput = {
    where: ArrivalItemsWhereUniqueInput
    data: XOR<ArrivalItemsUpdateWithoutConditionInput, ArrivalItemsUncheckedUpdateWithoutConditionInput>
  }

  export type ArrivalItemsUpdateManyWithWhereWithoutConditionInput = {
    where: ArrivalItemsScalarWhereInput
    data: XOR<ArrivalItemsUpdateManyMutationInput, ArrivalItemsUncheckedUpdateManyWithoutConditionInput>
  }

  export type ArrivalItemsCreateWithoutParameterInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    arrival: ArrivalsCreateNestedOneWithoutArrivalItemsInput
    material: MaterialsCreateNestedOneWithoutArrivalItemsInput
    condition: ConditionsCreateNestedOneWithoutArrivalItemsInput
    qcStatus?: QcStatusCreateNestedOneWithoutArrivalItemsInput
    QcResults?: QcResultsCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateWithoutParameterInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsCreateOrConnectWithoutParameterInput = {
    where: ArrivalItemsWhereUniqueInput
    create: XOR<ArrivalItemsCreateWithoutParameterInput, ArrivalItemsUncheckedCreateWithoutParameterInput>
  }

  export type ArrivalItemsCreateManyParameterInputEnvelope = {
    data: ArrivalItemsCreateManyParameterInput | ArrivalItemsCreateManyParameterInput[]
    skipDuplicates?: boolean
  }

  export type QcResultsCreateWithoutParameterInput = {
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    arrivalItem: ArrivalItemsCreateNestedOneWithoutQcResultsInput
    history?: QcHistoriesCreateNestedOneWithoutQcResultsInput
  }

  export type QcResultsUncheckedCreateWithoutParameterInput = {
    id?: number
    arrivalItemId: number
    historyId?: number | null
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcResultsCreateOrConnectWithoutParameterInput = {
    where: QcResultsWhereUniqueInput
    create: XOR<QcResultsCreateWithoutParameterInput, QcResultsUncheckedCreateWithoutParameterInput>
  }

  export type QcResultsCreateManyParameterInputEnvelope = {
    data: QcResultsCreateManyParameterInput | QcResultsCreateManyParameterInput[]
    skipDuplicates?: boolean
  }

  export type ParameterSettingsCreateWithoutParameterInput = {
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type ParameterSettingsUncheckedCreateWithoutParameterInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type ParameterSettingsCreateOrConnectWithoutParameterInput = {
    where: ParameterSettingsWhereUniqueInput
    create: XOR<ParameterSettingsCreateWithoutParameterInput, ParameterSettingsUncheckedCreateWithoutParameterInput>
  }

  export type ParameterSettingsCreateManyParameterInputEnvelope = {
    data: ParameterSettingsCreateManyParameterInput | ParameterSettingsCreateManyParameterInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalItemsUpsertWithWhereUniqueWithoutParameterInput = {
    where: ArrivalItemsWhereUniqueInput
    update: XOR<ArrivalItemsUpdateWithoutParameterInput, ArrivalItemsUncheckedUpdateWithoutParameterInput>
    create: XOR<ArrivalItemsCreateWithoutParameterInput, ArrivalItemsUncheckedCreateWithoutParameterInput>
  }

  export type ArrivalItemsUpdateWithWhereUniqueWithoutParameterInput = {
    where: ArrivalItemsWhereUniqueInput
    data: XOR<ArrivalItemsUpdateWithoutParameterInput, ArrivalItemsUncheckedUpdateWithoutParameterInput>
  }

  export type ArrivalItemsUpdateManyWithWhereWithoutParameterInput = {
    where: ArrivalItemsScalarWhereInput
    data: XOR<ArrivalItemsUpdateManyMutationInput, ArrivalItemsUncheckedUpdateManyWithoutParameterInput>
  }

  export type QcResultsUpsertWithWhereUniqueWithoutParameterInput = {
    where: QcResultsWhereUniqueInput
    update: XOR<QcResultsUpdateWithoutParameterInput, QcResultsUncheckedUpdateWithoutParameterInput>
    create: XOR<QcResultsCreateWithoutParameterInput, QcResultsUncheckedCreateWithoutParameterInput>
  }

  export type QcResultsUpdateWithWhereUniqueWithoutParameterInput = {
    where: QcResultsWhereUniqueInput
    data: XOR<QcResultsUpdateWithoutParameterInput, QcResultsUncheckedUpdateWithoutParameterInput>
  }

  export type QcResultsUpdateManyWithWhereWithoutParameterInput = {
    where: QcResultsScalarWhereInput
    data: XOR<QcResultsUpdateManyMutationInput, QcResultsUncheckedUpdateManyWithoutParameterInput>
  }

  export type QcResultsScalarWhereInput = {
    AND?: QcResultsScalarWhereInput | QcResultsScalarWhereInput[]
    OR?: QcResultsScalarWhereInput[]
    NOT?: QcResultsScalarWhereInput | QcResultsScalarWhereInput[]
    id?: IntFilter<"QcResults"> | number
    arrivalItemId?: IntFilter<"QcResults"> | number
    parameterId?: IntFilter<"QcResults"> | number
    historyId?: IntNullableFilter<"QcResults"> | number | null
    resultKey?: StringFilter<"QcResults"> | string
    value?: StringFilter<"QcResults"> | string
    createdAt?: DateTimeFilter<"QcResults"> | Date | string
    createdBy?: StringNullableFilter<"QcResults"> | string | null
    updatedAt?: DateTimeFilter<"QcResults"> | Date | string
    updatedBy?: StringNullableFilter<"QcResults"> | string | null
  }

  export type ParameterSettingsUpsertWithWhereUniqueWithoutParameterInput = {
    where: ParameterSettingsWhereUniqueInput
    update: XOR<ParameterSettingsUpdateWithoutParameterInput, ParameterSettingsUncheckedUpdateWithoutParameterInput>
    create: XOR<ParameterSettingsCreateWithoutParameterInput, ParameterSettingsUncheckedCreateWithoutParameterInput>
  }

  export type ParameterSettingsUpdateWithWhereUniqueWithoutParameterInput = {
    where: ParameterSettingsWhereUniqueInput
    data: XOR<ParameterSettingsUpdateWithoutParameterInput, ParameterSettingsUncheckedUpdateWithoutParameterInput>
  }

  export type ParameterSettingsUpdateManyWithWhereWithoutParameterInput = {
    where: ParameterSettingsScalarWhereInput
    data: XOR<ParameterSettingsUpdateManyMutationInput, ParameterSettingsUncheckedUpdateManyWithoutParameterInput>
  }

  export type ParameterSettingsScalarWhereInput = {
    AND?: ParameterSettingsScalarWhereInput | ParameterSettingsScalarWhereInput[]
    OR?: ParameterSettingsScalarWhereInput[]
    NOT?: ParameterSettingsScalarWhereInput | ParameterSettingsScalarWhereInput[]
    id?: IntFilter<"ParameterSettings"> | number
    parameterId?: IntFilter<"ParameterSettings"> | number
    key?: StringFilter<"ParameterSettings"> | string
    value?: StringFilter<"ParameterSettings"> | string
    createdAt?: DateTimeFilter<"ParameterSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ParameterSettings"> | Date | string
    createdBy?: StringNullableFilter<"ParameterSettings"> | string | null
    updatedBy?: StringNullableFilter<"ParameterSettings"> | string | null
  }

  export type SuppliersCreateWithoutArrivalsInput = {
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SuppliersUncheckedCreateWithoutArrivalsInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SuppliersCreateOrConnectWithoutArrivalsInput = {
    where: SuppliersWhereUniqueInput
    create: XOR<SuppliersCreateWithoutArrivalsInput, SuppliersUncheckedCreateWithoutArrivalsInput>
  }

  export type ArrivalItemsCreateWithoutArrivalInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    material: MaterialsCreateNestedOneWithoutArrivalItemsInput
    condition: ConditionsCreateNestedOneWithoutArrivalItemsInput
    parameter?: ParametersCreateNestedOneWithoutArrivalItemsInput
    qcStatus?: QcStatusCreateNestedOneWithoutArrivalItemsInput
    QcResults?: QcResultsCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateWithoutArrivalInput = {
    id?: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsCreateOrConnectWithoutArrivalInput = {
    where: ArrivalItemsWhereUniqueInput
    create: XOR<ArrivalItemsCreateWithoutArrivalInput, ArrivalItemsUncheckedCreateWithoutArrivalInput>
  }

  export type ArrivalItemsCreateManyArrivalInputEnvelope = {
    data: ArrivalItemsCreateManyArrivalInput | ArrivalItemsCreateManyArrivalInput[]
    skipDuplicates?: boolean
  }

  export type QcHistoriesCreateWithoutArrivalInput = {
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutQcHistoriesInput
    status: QcStatusCreateNestedOneWithoutQcHistoriesInput
    arrivalItem?: ArrivalItemsCreateNestedOneWithoutQcHistoriesInput
    QcResults?: QcResultsCreateNestedManyWithoutHistoryInput
  }

  export type QcHistoriesUncheckedCreateWithoutArrivalInput = {
    id?: number
    userId: string
    statusId: number
    arrivalItemId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type QcHistoriesCreateOrConnectWithoutArrivalInput = {
    where: QcHistoriesWhereUniqueInput
    create: XOR<QcHistoriesCreateWithoutArrivalInput, QcHistoriesUncheckedCreateWithoutArrivalInput>
  }

  export type QcHistoriesCreateManyArrivalInputEnvelope = {
    data: QcHistoriesCreateManyArrivalInput | QcHistoriesCreateManyArrivalInput[]
    skipDuplicates?: boolean
  }

  export type SecurityPhotosCreateWithoutArrivalInput = {
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SecurityPhotosUncheckedCreateWithoutArrivalInput = {
    id?: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SecurityPhotosCreateOrConnectWithoutArrivalInput = {
    where: SecurityPhotosWhereUniqueInput
    create: XOR<SecurityPhotosCreateWithoutArrivalInput, SecurityPhotosUncheckedCreateWithoutArrivalInput>
  }

  export type SecurityPhotosCreateManyArrivalInputEnvelope = {
    data: SecurityPhotosCreateManyArrivalInput | SecurityPhotosCreateManyArrivalInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalStatusesCreateWithoutArrivalInput = {
    status?: string
    statusQc?: string | null
    statusWeighing?: string | null
    statusApproval?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ArrivalStatusesUncheckedCreateWithoutArrivalInput = {
    id?: number
    status?: string
    statusQc?: string | null
    statusWeighing?: string | null
    statusApproval?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ArrivalStatusesCreateOrConnectWithoutArrivalInput = {
    where: ArrivalStatusesWhereUniqueInput
    create: XOR<ArrivalStatusesCreateWithoutArrivalInput, ArrivalStatusesUncheckedCreateWithoutArrivalInput>
  }

  export type SuppliersUpsertWithoutArrivalsInput = {
    update: XOR<SuppliersUpdateWithoutArrivalsInput, SuppliersUncheckedUpdateWithoutArrivalsInput>
    create: XOR<SuppliersCreateWithoutArrivalsInput, SuppliersUncheckedCreateWithoutArrivalsInput>
    where?: SuppliersWhereInput
  }

  export type SuppliersUpdateToOneWithWhereWithoutArrivalsInput = {
    where?: SuppliersWhereInput
    data: XOR<SuppliersUpdateWithoutArrivalsInput, SuppliersUncheckedUpdateWithoutArrivalsInput>
  }

  export type SuppliersUpdateWithoutArrivalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuppliersUncheckedUpdateWithoutArrivalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArrivalItemsUpsertWithWhereUniqueWithoutArrivalInput = {
    where: ArrivalItemsWhereUniqueInput
    update: XOR<ArrivalItemsUpdateWithoutArrivalInput, ArrivalItemsUncheckedUpdateWithoutArrivalInput>
    create: XOR<ArrivalItemsCreateWithoutArrivalInput, ArrivalItemsUncheckedCreateWithoutArrivalInput>
  }

  export type ArrivalItemsUpdateWithWhereUniqueWithoutArrivalInput = {
    where: ArrivalItemsWhereUniqueInput
    data: XOR<ArrivalItemsUpdateWithoutArrivalInput, ArrivalItemsUncheckedUpdateWithoutArrivalInput>
  }

  export type ArrivalItemsUpdateManyWithWhereWithoutArrivalInput = {
    where: ArrivalItemsScalarWhereInput
    data: XOR<ArrivalItemsUpdateManyMutationInput, ArrivalItemsUncheckedUpdateManyWithoutArrivalInput>
  }

  export type QcHistoriesUpsertWithWhereUniqueWithoutArrivalInput = {
    where: QcHistoriesWhereUniqueInput
    update: XOR<QcHistoriesUpdateWithoutArrivalInput, QcHistoriesUncheckedUpdateWithoutArrivalInput>
    create: XOR<QcHistoriesCreateWithoutArrivalInput, QcHistoriesUncheckedCreateWithoutArrivalInput>
  }

  export type QcHistoriesUpdateWithWhereUniqueWithoutArrivalInput = {
    where: QcHistoriesWhereUniqueInput
    data: XOR<QcHistoriesUpdateWithoutArrivalInput, QcHistoriesUncheckedUpdateWithoutArrivalInput>
  }

  export type QcHistoriesUpdateManyWithWhereWithoutArrivalInput = {
    where: QcHistoriesScalarWhereInput
    data: XOR<QcHistoriesUpdateManyMutationInput, QcHistoriesUncheckedUpdateManyWithoutArrivalInput>
  }

  export type SecurityPhotosUpsertWithWhereUniqueWithoutArrivalInput = {
    where: SecurityPhotosWhereUniqueInput
    update: XOR<SecurityPhotosUpdateWithoutArrivalInput, SecurityPhotosUncheckedUpdateWithoutArrivalInput>
    create: XOR<SecurityPhotosCreateWithoutArrivalInput, SecurityPhotosUncheckedCreateWithoutArrivalInput>
  }

  export type SecurityPhotosUpdateWithWhereUniqueWithoutArrivalInput = {
    where: SecurityPhotosWhereUniqueInput
    data: XOR<SecurityPhotosUpdateWithoutArrivalInput, SecurityPhotosUncheckedUpdateWithoutArrivalInput>
  }

  export type SecurityPhotosUpdateManyWithWhereWithoutArrivalInput = {
    where: SecurityPhotosScalarWhereInput
    data: XOR<SecurityPhotosUpdateManyMutationInput, SecurityPhotosUncheckedUpdateManyWithoutArrivalInput>
  }

  export type SecurityPhotosScalarWhereInput = {
    AND?: SecurityPhotosScalarWhereInput | SecurityPhotosScalarWhereInput[]
    OR?: SecurityPhotosScalarWhereInput[]
    NOT?: SecurityPhotosScalarWhereInput | SecurityPhotosScalarWhereInput[]
    id?: IntFilter<"SecurityPhotos"> | number
    arrivalId?: IntFilter<"SecurityPhotos"> | number
    photo?: StringFilter<"SecurityPhotos"> | string
    createdAt?: DateTimeFilter<"SecurityPhotos"> | Date | string
    createdBy?: StringNullableFilter<"SecurityPhotos"> | string | null
    updatedAt?: DateTimeFilter<"SecurityPhotos"> | Date | string
    updatedBy?: StringNullableFilter<"SecurityPhotos"> | string | null
  }

  export type ArrivalStatusesUpsertWithoutArrivalInput = {
    update: XOR<ArrivalStatusesUpdateWithoutArrivalInput, ArrivalStatusesUncheckedUpdateWithoutArrivalInput>
    create: XOR<ArrivalStatusesCreateWithoutArrivalInput, ArrivalStatusesUncheckedCreateWithoutArrivalInput>
    where?: ArrivalStatusesWhereInput
  }

  export type ArrivalStatusesUpdateToOneWithWhereWithoutArrivalInput = {
    where?: ArrivalStatusesWhereInput
    data: XOR<ArrivalStatusesUpdateWithoutArrivalInput, ArrivalStatusesUncheckedUpdateWithoutArrivalInput>
  }

  export type ArrivalStatusesUpdateWithoutArrivalInput = {
    status?: StringFieldUpdateOperationsInput | string
    statusQc?: NullableStringFieldUpdateOperationsInput | string | null
    statusWeighing?: NullableStringFieldUpdateOperationsInput | string | null
    statusApproval?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArrivalStatusesUncheckedUpdateWithoutArrivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statusQc?: NullableStringFieldUpdateOperationsInput | string | null
    statusWeighing?: NullableStringFieldUpdateOperationsInput | string | null
    statusApproval?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArrivalsCreateWithoutArrivalItemsInput = {
    idKedatangan: string
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    supplier: SuppliersCreateNestedOneWithoutArrivalsInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalInput
    SecurityPhotos?: SecurityPhotosCreateNestedManyWithoutArrivalInput
    ArrivalStatuses?: ArrivalStatusesCreateNestedOneWithoutArrivalInput
  }

  export type ArrivalsUncheckedCreateWithoutArrivalItemsInput = {
    id?: number
    idKedatangan: string
    supplierId: number
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalInput
    SecurityPhotos?: SecurityPhotosUncheckedCreateNestedManyWithoutArrivalInput
    ArrivalStatuses?: ArrivalStatusesUncheckedCreateNestedOneWithoutArrivalInput
  }

  export type ArrivalsCreateOrConnectWithoutArrivalItemsInput = {
    where: ArrivalsWhereUniqueInput
    create: XOR<ArrivalsCreateWithoutArrivalItemsInput, ArrivalsUncheckedCreateWithoutArrivalItemsInput>
  }

  export type MaterialsCreateWithoutArrivalItemsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type MaterialsUncheckedCreateWithoutArrivalItemsInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type MaterialsCreateOrConnectWithoutArrivalItemsInput = {
    where: MaterialsWhereUniqueInput
    create: XOR<MaterialsCreateWithoutArrivalItemsInput, MaterialsUncheckedCreateWithoutArrivalItemsInput>
  }

  export type ConditionsCreateWithoutArrivalItemsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ConditionsUncheckedCreateWithoutArrivalItemsInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ConditionsCreateOrConnectWithoutArrivalItemsInput = {
    where: ConditionsWhereUniqueInput
    create: XOR<ConditionsCreateWithoutArrivalItemsInput, ConditionsUncheckedCreateWithoutArrivalItemsInput>
  }

  export type ParametersCreateWithoutArrivalItemsInput = {
    name: string
    unit?: string | null
    type?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    QcResults?: QcResultsCreateNestedManyWithoutParameterInput
    settings?: ParameterSettingsCreateNestedManyWithoutParameterInput
  }

  export type ParametersUncheckedCreateWithoutArrivalItemsInput = {
    id?: number
    name: string
    unit?: string | null
    type?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutParameterInput
    settings?: ParameterSettingsUncheckedCreateNestedManyWithoutParameterInput
  }

  export type ParametersCreateOrConnectWithoutArrivalItemsInput = {
    where: ParametersWhereUniqueInput
    create: XOR<ParametersCreateWithoutArrivalItemsInput, ParametersUncheckedCreateWithoutArrivalItemsInput>
  }

  export type QcStatusCreateWithoutArrivalItemsInput = {
    name: string
    description?: string | null
    QcHistories?: QcHistoriesCreateNestedManyWithoutStatusInput
  }

  export type QcStatusUncheckedCreateWithoutArrivalItemsInput = {
    id?: number
    name: string
    description?: string | null
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutStatusInput
  }

  export type QcStatusCreateOrConnectWithoutArrivalItemsInput = {
    where: QcStatusWhereUniqueInput
    create: XOR<QcStatusCreateWithoutArrivalItemsInput, QcStatusUncheckedCreateWithoutArrivalItemsInput>
  }

  export type QcResultsCreateWithoutArrivalItemInput = {
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    parameter?: ParametersCreateNestedOneWithoutQcResultsInput
    history?: QcHistoriesCreateNestedOneWithoutQcResultsInput
  }

  export type QcResultsUncheckedCreateWithoutArrivalItemInput = {
    id?: number
    parameterId: number
    historyId?: number | null
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcResultsCreateOrConnectWithoutArrivalItemInput = {
    where: QcResultsWhereUniqueInput
    create: XOR<QcResultsCreateWithoutArrivalItemInput, QcResultsUncheckedCreateWithoutArrivalItemInput>
  }

  export type QcResultsCreateManyArrivalItemInputEnvelope = {
    data: QcResultsCreateManyArrivalItemInput | QcResultsCreateManyArrivalItemInput[]
    skipDuplicates?: boolean
  }

  export type QcPhotosCreateWithoutArrivalItemInput = {
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcPhotosUncheckedCreateWithoutArrivalItemInput = {
    id?: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcPhotosCreateOrConnectWithoutArrivalItemInput = {
    where: QcPhotosWhereUniqueInput
    create: XOR<QcPhotosCreateWithoutArrivalItemInput, QcPhotosUncheckedCreateWithoutArrivalItemInput>
  }

  export type QcPhotosCreateManyArrivalItemInputEnvelope = {
    data: QcPhotosCreateManyArrivalItemInput | QcPhotosCreateManyArrivalItemInput[]
    skipDuplicates?: boolean
  }

  export type WeighingsCreateWithoutArrivalItemInput = {
    weight: number
    note?: string | null
    weighingDate?: Date | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type WeighingsUncheckedCreateWithoutArrivalItemInput = {
    id?: number
    weight: number
    note?: string | null
    weighingDate?: Date | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type WeighingsCreateOrConnectWithoutArrivalItemInput = {
    where: WeighingsWhereUniqueInput
    create: XOR<WeighingsCreateWithoutArrivalItemInput, WeighingsUncheckedCreateWithoutArrivalItemInput>
  }

  export type WeighingsCreateManyArrivalItemInputEnvelope = {
    data: WeighingsCreateManyArrivalItemInput | WeighingsCreateManyArrivalItemInput[]
    skipDuplicates?: boolean
  }

  export type WeighingsPhotosCreateWithoutArrivalItemInput = {
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type WeighingsPhotosUncheckedCreateWithoutArrivalItemInput = {
    id?: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type WeighingsPhotosCreateOrConnectWithoutArrivalItemInput = {
    where: WeighingsPhotosWhereUniqueInput
    create: XOR<WeighingsPhotosCreateWithoutArrivalItemInput, WeighingsPhotosUncheckedCreateWithoutArrivalItemInput>
  }

  export type WeighingsPhotosCreateManyArrivalItemInputEnvelope = {
    data: WeighingsPhotosCreateManyArrivalItemInput | WeighingsPhotosCreateManyArrivalItemInput[]
    skipDuplicates?: boolean
  }

  export type QcHistoriesCreateWithoutArrivalItemInput = {
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutQcHistoriesInput
    status: QcStatusCreateNestedOneWithoutQcHistoriesInput
    arrival?: ArrivalsCreateNestedOneWithoutQcHistoriesInput
    QcResults?: QcResultsCreateNestedManyWithoutHistoryInput
  }

  export type QcHistoriesUncheckedCreateWithoutArrivalItemInput = {
    id?: number
    userId: string
    statusId: number
    arrivalId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type QcHistoriesCreateOrConnectWithoutArrivalItemInput = {
    where: QcHistoriesWhereUniqueInput
    create: XOR<QcHistoriesCreateWithoutArrivalItemInput, QcHistoriesUncheckedCreateWithoutArrivalItemInput>
  }

  export type QcHistoriesCreateManyArrivalItemInputEnvelope = {
    data: QcHistoriesCreateManyArrivalItemInput | QcHistoriesCreateManyArrivalItemInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalsUpsertWithoutArrivalItemsInput = {
    update: XOR<ArrivalsUpdateWithoutArrivalItemsInput, ArrivalsUncheckedUpdateWithoutArrivalItemsInput>
    create: XOR<ArrivalsCreateWithoutArrivalItemsInput, ArrivalsUncheckedCreateWithoutArrivalItemsInput>
    where?: ArrivalsWhereInput
  }

  export type ArrivalsUpdateToOneWithWhereWithoutArrivalItemsInput = {
    where?: ArrivalsWhereInput
    data: XOR<ArrivalsUpdateWithoutArrivalItemsInput, ArrivalsUncheckedUpdateWithoutArrivalItemsInput>
  }

  export type ArrivalsUpdateWithoutArrivalItemsInput = {
    idKedatangan?: StringFieldUpdateOperationsInput | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: SuppliersUpdateOneRequiredWithoutArrivalsNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalNestedInput
    SecurityPhotos?: SecurityPhotosUpdateManyWithoutArrivalNestedInput
    ArrivalStatuses?: ArrivalStatusesUpdateOneWithoutArrivalNestedInput
  }

  export type ArrivalsUncheckedUpdateWithoutArrivalItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    idKedatangan?: StringFieldUpdateOperationsInput | string
    supplierId?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalNestedInput
    SecurityPhotos?: SecurityPhotosUncheckedUpdateManyWithoutArrivalNestedInput
    ArrivalStatuses?: ArrivalStatusesUncheckedUpdateOneWithoutArrivalNestedInput
  }

  export type MaterialsUpsertWithoutArrivalItemsInput = {
    update: XOR<MaterialsUpdateWithoutArrivalItemsInput, MaterialsUncheckedUpdateWithoutArrivalItemsInput>
    create: XOR<MaterialsCreateWithoutArrivalItemsInput, MaterialsUncheckedCreateWithoutArrivalItemsInput>
    where?: MaterialsWhereInput
  }

  export type MaterialsUpdateToOneWithWhereWithoutArrivalItemsInput = {
    where?: MaterialsWhereInput
    data: XOR<MaterialsUpdateWithoutArrivalItemsInput, MaterialsUncheckedUpdateWithoutArrivalItemsInput>
  }

  export type MaterialsUpdateWithoutArrivalItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialsUncheckedUpdateWithoutArrivalItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionsUpsertWithoutArrivalItemsInput = {
    update: XOR<ConditionsUpdateWithoutArrivalItemsInput, ConditionsUncheckedUpdateWithoutArrivalItemsInput>
    create: XOR<ConditionsCreateWithoutArrivalItemsInput, ConditionsUncheckedCreateWithoutArrivalItemsInput>
    where?: ConditionsWhereInput
  }

  export type ConditionsUpdateToOneWithWhereWithoutArrivalItemsInput = {
    where?: ConditionsWhereInput
    data: XOR<ConditionsUpdateWithoutArrivalItemsInput, ConditionsUncheckedUpdateWithoutArrivalItemsInput>
  }

  export type ConditionsUpdateWithoutArrivalItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionsUncheckedUpdateWithoutArrivalItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParametersUpsertWithoutArrivalItemsInput = {
    update: XOR<ParametersUpdateWithoutArrivalItemsInput, ParametersUncheckedUpdateWithoutArrivalItemsInput>
    create: XOR<ParametersCreateWithoutArrivalItemsInput, ParametersUncheckedCreateWithoutArrivalItemsInput>
    where?: ParametersWhereInput
  }

  export type ParametersUpdateToOneWithWhereWithoutArrivalItemsInput = {
    where?: ParametersWhereInput
    data: XOR<ParametersUpdateWithoutArrivalItemsInput, ParametersUncheckedUpdateWithoutArrivalItemsInput>
  }

  export type ParametersUpdateWithoutArrivalItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    QcResults?: QcResultsUpdateManyWithoutParameterNestedInput
    settings?: ParameterSettingsUpdateManyWithoutParameterNestedInput
  }

  export type ParametersUncheckedUpdateWithoutArrivalItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    QcResults?: QcResultsUncheckedUpdateManyWithoutParameterNestedInput
    settings?: ParameterSettingsUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type QcStatusUpsertWithoutArrivalItemsInput = {
    update: XOR<QcStatusUpdateWithoutArrivalItemsInput, QcStatusUncheckedUpdateWithoutArrivalItemsInput>
    create: XOR<QcStatusCreateWithoutArrivalItemsInput, QcStatusUncheckedCreateWithoutArrivalItemsInput>
    where?: QcStatusWhereInput
  }

  export type QcStatusUpdateToOneWithWhereWithoutArrivalItemsInput = {
    where?: QcStatusWhereInput
    data: XOR<QcStatusUpdateWithoutArrivalItemsInput, QcStatusUncheckedUpdateWithoutArrivalItemsInput>
  }

  export type QcStatusUpdateWithoutArrivalItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    QcHistories?: QcHistoriesUpdateManyWithoutStatusNestedInput
  }

  export type QcStatusUncheckedUpdateWithoutArrivalItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type QcResultsUpsertWithWhereUniqueWithoutArrivalItemInput = {
    where: QcResultsWhereUniqueInput
    update: XOR<QcResultsUpdateWithoutArrivalItemInput, QcResultsUncheckedUpdateWithoutArrivalItemInput>
    create: XOR<QcResultsCreateWithoutArrivalItemInput, QcResultsUncheckedCreateWithoutArrivalItemInput>
  }

  export type QcResultsUpdateWithWhereUniqueWithoutArrivalItemInput = {
    where: QcResultsWhereUniqueInput
    data: XOR<QcResultsUpdateWithoutArrivalItemInput, QcResultsUncheckedUpdateWithoutArrivalItemInput>
  }

  export type QcResultsUpdateManyWithWhereWithoutArrivalItemInput = {
    where: QcResultsScalarWhereInput
    data: XOR<QcResultsUpdateManyMutationInput, QcResultsUncheckedUpdateManyWithoutArrivalItemInput>
  }

  export type QcPhotosUpsertWithWhereUniqueWithoutArrivalItemInput = {
    where: QcPhotosWhereUniqueInput
    update: XOR<QcPhotosUpdateWithoutArrivalItemInput, QcPhotosUncheckedUpdateWithoutArrivalItemInput>
    create: XOR<QcPhotosCreateWithoutArrivalItemInput, QcPhotosUncheckedCreateWithoutArrivalItemInput>
  }

  export type QcPhotosUpdateWithWhereUniqueWithoutArrivalItemInput = {
    where: QcPhotosWhereUniqueInput
    data: XOR<QcPhotosUpdateWithoutArrivalItemInput, QcPhotosUncheckedUpdateWithoutArrivalItemInput>
  }

  export type QcPhotosUpdateManyWithWhereWithoutArrivalItemInput = {
    where: QcPhotosScalarWhereInput
    data: XOR<QcPhotosUpdateManyMutationInput, QcPhotosUncheckedUpdateManyWithoutArrivalItemInput>
  }

  export type QcPhotosScalarWhereInput = {
    AND?: QcPhotosScalarWhereInput | QcPhotosScalarWhereInput[]
    OR?: QcPhotosScalarWhereInput[]
    NOT?: QcPhotosScalarWhereInput | QcPhotosScalarWhereInput[]
    id?: IntFilter<"QcPhotos"> | number
    arrivalItemId?: IntFilter<"QcPhotos"> | number
    photo?: StringFilter<"QcPhotos"> | string
    createdAt?: DateTimeFilter<"QcPhotos"> | Date | string
    createdBy?: StringNullableFilter<"QcPhotos"> | string | null
    updatedAt?: DateTimeFilter<"QcPhotos"> | Date | string
    updatedBy?: StringNullableFilter<"QcPhotos"> | string | null
  }

  export type WeighingsUpsertWithWhereUniqueWithoutArrivalItemInput = {
    where: WeighingsWhereUniqueInput
    update: XOR<WeighingsUpdateWithoutArrivalItemInput, WeighingsUncheckedUpdateWithoutArrivalItemInput>
    create: XOR<WeighingsCreateWithoutArrivalItemInput, WeighingsUncheckedCreateWithoutArrivalItemInput>
  }

  export type WeighingsUpdateWithWhereUniqueWithoutArrivalItemInput = {
    where: WeighingsWhereUniqueInput
    data: XOR<WeighingsUpdateWithoutArrivalItemInput, WeighingsUncheckedUpdateWithoutArrivalItemInput>
  }

  export type WeighingsUpdateManyWithWhereWithoutArrivalItemInput = {
    where: WeighingsScalarWhereInput
    data: XOR<WeighingsUpdateManyMutationInput, WeighingsUncheckedUpdateManyWithoutArrivalItemInput>
  }

  export type WeighingsScalarWhereInput = {
    AND?: WeighingsScalarWhereInput | WeighingsScalarWhereInput[]
    OR?: WeighingsScalarWhereInput[]
    NOT?: WeighingsScalarWhereInput | WeighingsScalarWhereInput[]
    id?: IntFilter<"Weighings"> | number
    arrivalItemId?: IntFilter<"Weighings"> | number
    weight?: FloatFilter<"Weighings"> | number
    note?: StringNullableFilter<"Weighings"> | string | null
    weighingDate?: DateTimeFilter<"Weighings"> | Date | string
    createdAt?: DateTimeFilter<"Weighings"> | Date | string
    createdBy?: StringNullableFilter<"Weighings"> | string | null
    updatedAt?: DateTimeFilter<"Weighings"> | Date | string
    updatedBy?: StringNullableFilter<"Weighings"> | string | null
  }

  export type WeighingsPhotosUpsertWithWhereUniqueWithoutArrivalItemInput = {
    where: WeighingsPhotosWhereUniqueInput
    update: XOR<WeighingsPhotosUpdateWithoutArrivalItemInput, WeighingsPhotosUncheckedUpdateWithoutArrivalItemInput>
    create: XOR<WeighingsPhotosCreateWithoutArrivalItemInput, WeighingsPhotosUncheckedCreateWithoutArrivalItemInput>
  }

  export type WeighingsPhotosUpdateWithWhereUniqueWithoutArrivalItemInput = {
    where: WeighingsPhotosWhereUniqueInput
    data: XOR<WeighingsPhotosUpdateWithoutArrivalItemInput, WeighingsPhotosUncheckedUpdateWithoutArrivalItemInput>
  }

  export type WeighingsPhotosUpdateManyWithWhereWithoutArrivalItemInput = {
    where: WeighingsPhotosScalarWhereInput
    data: XOR<WeighingsPhotosUpdateManyMutationInput, WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemInput>
  }

  export type WeighingsPhotosScalarWhereInput = {
    AND?: WeighingsPhotosScalarWhereInput | WeighingsPhotosScalarWhereInput[]
    OR?: WeighingsPhotosScalarWhereInput[]
    NOT?: WeighingsPhotosScalarWhereInput | WeighingsPhotosScalarWhereInput[]
    id?: IntFilter<"WeighingsPhotos"> | number
    arrivalItemId?: IntFilter<"WeighingsPhotos"> | number
    photo?: StringFilter<"WeighingsPhotos"> | string
    createdAt?: DateTimeFilter<"WeighingsPhotos"> | Date | string
    createdBy?: StringNullableFilter<"WeighingsPhotos"> | string | null
    updatedAt?: DateTimeFilter<"WeighingsPhotos"> | Date | string
    updatedBy?: StringNullableFilter<"WeighingsPhotos"> | string | null
  }

  export type QcHistoriesUpsertWithWhereUniqueWithoutArrivalItemInput = {
    where: QcHistoriesWhereUniqueInput
    update: XOR<QcHistoriesUpdateWithoutArrivalItemInput, QcHistoriesUncheckedUpdateWithoutArrivalItemInput>
    create: XOR<QcHistoriesCreateWithoutArrivalItemInput, QcHistoriesUncheckedCreateWithoutArrivalItemInput>
  }

  export type QcHistoriesUpdateWithWhereUniqueWithoutArrivalItemInput = {
    where: QcHistoriesWhereUniqueInput
    data: XOR<QcHistoriesUpdateWithoutArrivalItemInput, QcHistoriesUncheckedUpdateWithoutArrivalItemInput>
  }

  export type QcHistoriesUpdateManyWithWhereWithoutArrivalItemInput = {
    where: QcHistoriesScalarWhereInput
    data: XOR<QcHistoriesUpdateManyMutationInput, QcHistoriesUncheckedUpdateManyWithoutArrivalItemInput>
  }

  export type ArrivalItemsCreateWithoutWeighingsInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    arrival: ArrivalsCreateNestedOneWithoutArrivalItemsInput
    material: MaterialsCreateNestedOneWithoutArrivalItemsInput
    condition: ConditionsCreateNestedOneWithoutArrivalItemsInput
    parameter?: ParametersCreateNestedOneWithoutArrivalItemsInput
    qcStatus?: QcStatusCreateNestedOneWithoutArrivalItemsInput
    QcResults?: QcResultsCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateWithoutWeighingsInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsCreateOrConnectWithoutWeighingsInput = {
    where: ArrivalItemsWhereUniqueInput
    create: XOR<ArrivalItemsCreateWithoutWeighingsInput, ArrivalItemsUncheckedCreateWithoutWeighingsInput>
  }

  export type ArrivalItemsUpsertWithoutWeighingsInput = {
    update: XOR<ArrivalItemsUpdateWithoutWeighingsInput, ArrivalItemsUncheckedUpdateWithoutWeighingsInput>
    create: XOR<ArrivalItemsCreateWithoutWeighingsInput, ArrivalItemsUncheckedCreateWithoutWeighingsInput>
    where?: ArrivalItemsWhereInput
  }

  export type ArrivalItemsUpdateToOneWithWhereWithoutWeighingsInput = {
    where?: ArrivalItemsWhereInput
    data: XOR<ArrivalItemsUpdateWithoutWeighingsInput, ArrivalItemsUncheckedUpdateWithoutWeighingsInput>
  }

  export type ArrivalItemsUpdateWithoutWeighingsInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput
    material?: MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput
    condition?: ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput
    parameter?: ParametersUpdateOneWithoutArrivalItemsNestedInput
    qcStatus?: QcStatusUpdateOneWithoutArrivalItemsNestedInput
    QcResults?: QcResultsUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateWithoutWeighingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcResults?: QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsCreateWithoutQcResultsInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    arrival: ArrivalsCreateNestedOneWithoutArrivalItemsInput
    material: MaterialsCreateNestedOneWithoutArrivalItemsInput
    condition: ConditionsCreateNestedOneWithoutArrivalItemsInput
    parameter?: ParametersCreateNestedOneWithoutArrivalItemsInput
    qcStatus?: QcStatusCreateNestedOneWithoutArrivalItemsInput
    QcPhotos?: QcPhotosCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateWithoutQcResultsInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcPhotos?: QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsCreateOrConnectWithoutQcResultsInput = {
    where: ArrivalItemsWhereUniqueInput
    create: XOR<ArrivalItemsCreateWithoutQcResultsInput, ArrivalItemsUncheckedCreateWithoutQcResultsInput>
  }

  export type ParametersCreateWithoutQcResultsInput = {
    name: string
    unit?: string | null
    type?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutParameterInput
    settings?: ParameterSettingsCreateNestedManyWithoutParameterInput
  }

  export type ParametersUncheckedCreateWithoutQcResultsInput = {
    id?: number
    name: string
    unit?: string | null
    type?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutParameterInput
    settings?: ParameterSettingsUncheckedCreateNestedManyWithoutParameterInput
  }

  export type ParametersCreateOrConnectWithoutQcResultsInput = {
    where: ParametersWhereUniqueInput
    create: XOR<ParametersCreateWithoutQcResultsInput, ParametersUncheckedCreateWithoutQcResultsInput>
  }

  export type QcHistoriesCreateWithoutQcResultsInput = {
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutQcHistoriesInput
    status: QcStatusCreateNestedOneWithoutQcHistoriesInput
    arrival?: ArrivalsCreateNestedOneWithoutQcHistoriesInput
    arrivalItem?: ArrivalItemsCreateNestedOneWithoutQcHistoriesInput
  }

  export type QcHistoriesUncheckedCreateWithoutQcResultsInput = {
    id?: number
    userId: string
    statusId: number
    arrivalId?: number | null
    arrivalItemId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QcHistoriesCreateOrConnectWithoutQcResultsInput = {
    where: QcHistoriesWhereUniqueInput
    create: XOR<QcHistoriesCreateWithoutQcResultsInput, QcHistoriesUncheckedCreateWithoutQcResultsInput>
  }

  export type ArrivalItemsUpsertWithoutQcResultsInput = {
    update: XOR<ArrivalItemsUpdateWithoutQcResultsInput, ArrivalItemsUncheckedUpdateWithoutQcResultsInput>
    create: XOR<ArrivalItemsCreateWithoutQcResultsInput, ArrivalItemsUncheckedCreateWithoutQcResultsInput>
    where?: ArrivalItemsWhereInput
  }

  export type ArrivalItemsUpdateToOneWithWhereWithoutQcResultsInput = {
    where?: ArrivalItemsWhereInput
    data: XOR<ArrivalItemsUpdateWithoutQcResultsInput, ArrivalItemsUncheckedUpdateWithoutQcResultsInput>
  }

  export type ArrivalItemsUpdateWithoutQcResultsInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput
    material?: MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput
    condition?: ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput
    parameter?: ParametersUpdateOneWithoutArrivalItemsNestedInput
    qcStatus?: QcStatusUpdateOneWithoutArrivalItemsNestedInput
    QcPhotos?: QcPhotosUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateWithoutQcResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcPhotos?: QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type ParametersUpsertWithoutQcResultsInput = {
    update: XOR<ParametersUpdateWithoutQcResultsInput, ParametersUncheckedUpdateWithoutQcResultsInput>
    create: XOR<ParametersCreateWithoutQcResultsInput, ParametersUncheckedCreateWithoutQcResultsInput>
    where?: ParametersWhereInput
  }

  export type ParametersUpdateToOneWithWhereWithoutQcResultsInput = {
    where?: ParametersWhereInput
    data: XOR<ParametersUpdateWithoutQcResultsInput, ParametersUncheckedUpdateWithoutQcResultsInput>
  }

  export type ParametersUpdateWithoutQcResultsInput = {
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUpdateManyWithoutParameterNestedInput
    settings?: ParameterSettingsUpdateManyWithoutParameterNestedInput
  }

  export type ParametersUncheckedUpdateWithoutQcResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutParameterNestedInput
    settings?: ParameterSettingsUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type QcHistoriesUpsertWithoutQcResultsInput = {
    update: XOR<QcHistoriesUpdateWithoutQcResultsInput, QcHistoriesUncheckedUpdateWithoutQcResultsInput>
    create: XOR<QcHistoriesCreateWithoutQcResultsInput, QcHistoriesUncheckedCreateWithoutQcResultsInput>
    where?: QcHistoriesWhereInput
  }

  export type QcHistoriesUpdateToOneWithWhereWithoutQcResultsInput = {
    where?: QcHistoriesWhereInput
    data: XOR<QcHistoriesUpdateWithoutQcResultsInput, QcHistoriesUncheckedUpdateWithoutQcResultsInput>
  }

  export type QcHistoriesUpdateWithoutQcResultsInput = {
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutQcHistoriesNestedInput
    status?: QcStatusUpdateOneRequiredWithoutQcHistoriesNestedInput
    arrival?: ArrivalsUpdateOneWithoutQcHistoriesNestedInput
    arrivalItem?: ArrivalItemsUpdateOneWithoutQcHistoriesNestedInput
  }

  export type QcHistoriesUncheckedUpdateWithoutQcResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
    arrivalId?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalItemId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArrivalItemsCreateWithoutQcStatusInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    arrival: ArrivalsCreateNestedOneWithoutArrivalItemsInput
    material: MaterialsCreateNestedOneWithoutArrivalItemsInput
    condition: ConditionsCreateNestedOneWithoutArrivalItemsInput
    parameter?: ParametersCreateNestedOneWithoutArrivalItemsInput
    QcResults?: QcResultsCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateWithoutQcStatusInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsCreateOrConnectWithoutQcStatusInput = {
    where: ArrivalItemsWhereUniqueInput
    create: XOR<ArrivalItemsCreateWithoutQcStatusInput, ArrivalItemsUncheckedCreateWithoutQcStatusInput>
  }

  export type ArrivalItemsCreateManyQcStatusInputEnvelope = {
    data: ArrivalItemsCreateManyQcStatusInput | ArrivalItemsCreateManyQcStatusInput[]
    skipDuplicates?: boolean
  }

  export type QcHistoriesCreateWithoutStatusInput = {
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutQcHistoriesInput
    arrival?: ArrivalsCreateNestedOneWithoutQcHistoriesInput
    arrivalItem?: ArrivalItemsCreateNestedOneWithoutQcHistoriesInput
    QcResults?: QcResultsCreateNestedManyWithoutHistoryInput
  }

  export type QcHistoriesUncheckedCreateWithoutStatusInput = {
    id?: number
    userId: string
    arrivalId?: number | null
    arrivalItemId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type QcHistoriesCreateOrConnectWithoutStatusInput = {
    where: QcHistoriesWhereUniqueInput
    create: XOR<QcHistoriesCreateWithoutStatusInput, QcHistoriesUncheckedCreateWithoutStatusInput>
  }

  export type QcHistoriesCreateManyStatusInputEnvelope = {
    data: QcHistoriesCreateManyStatusInput | QcHistoriesCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type ArrivalItemsUpsertWithWhereUniqueWithoutQcStatusInput = {
    where: ArrivalItemsWhereUniqueInput
    update: XOR<ArrivalItemsUpdateWithoutQcStatusInput, ArrivalItemsUncheckedUpdateWithoutQcStatusInput>
    create: XOR<ArrivalItemsCreateWithoutQcStatusInput, ArrivalItemsUncheckedCreateWithoutQcStatusInput>
  }

  export type ArrivalItemsUpdateWithWhereUniqueWithoutQcStatusInput = {
    where: ArrivalItemsWhereUniqueInput
    data: XOR<ArrivalItemsUpdateWithoutQcStatusInput, ArrivalItemsUncheckedUpdateWithoutQcStatusInput>
  }

  export type ArrivalItemsUpdateManyWithWhereWithoutQcStatusInput = {
    where: ArrivalItemsScalarWhereInput
    data: XOR<ArrivalItemsUpdateManyMutationInput, ArrivalItemsUncheckedUpdateManyWithoutQcStatusInput>
  }

  export type QcHistoriesUpsertWithWhereUniqueWithoutStatusInput = {
    where: QcHistoriesWhereUniqueInput
    update: XOR<QcHistoriesUpdateWithoutStatusInput, QcHistoriesUncheckedUpdateWithoutStatusInput>
    create: XOR<QcHistoriesCreateWithoutStatusInput, QcHistoriesUncheckedCreateWithoutStatusInput>
  }

  export type QcHistoriesUpdateWithWhereUniqueWithoutStatusInput = {
    where: QcHistoriesWhereUniqueInput
    data: XOR<QcHistoriesUpdateWithoutStatusInput, QcHistoriesUncheckedUpdateWithoutStatusInput>
  }

  export type QcHistoriesUpdateManyWithWhereWithoutStatusInput = {
    where: QcHistoriesScalarWhereInput
    data: XOR<QcHistoriesUpdateManyMutationInput, QcHistoriesUncheckedUpdateManyWithoutStatusInput>
  }

  export type ArrivalItemsCreateWithoutQcPhotosInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    arrival: ArrivalsCreateNestedOneWithoutArrivalItemsInput
    material: MaterialsCreateNestedOneWithoutArrivalItemsInput
    condition: ConditionsCreateNestedOneWithoutArrivalItemsInput
    parameter?: ParametersCreateNestedOneWithoutArrivalItemsInput
    qcStatus?: QcStatusCreateNestedOneWithoutArrivalItemsInput
    QcResults?: QcResultsCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateWithoutQcPhotosInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsCreateOrConnectWithoutQcPhotosInput = {
    where: ArrivalItemsWhereUniqueInput
    create: XOR<ArrivalItemsCreateWithoutQcPhotosInput, ArrivalItemsUncheckedCreateWithoutQcPhotosInput>
  }

  export type ArrivalItemsUpsertWithoutQcPhotosInput = {
    update: XOR<ArrivalItemsUpdateWithoutQcPhotosInput, ArrivalItemsUncheckedUpdateWithoutQcPhotosInput>
    create: XOR<ArrivalItemsCreateWithoutQcPhotosInput, ArrivalItemsUncheckedCreateWithoutQcPhotosInput>
    where?: ArrivalItemsWhereInput
  }

  export type ArrivalItemsUpdateToOneWithWhereWithoutQcPhotosInput = {
    where?: ArrivalItemsWhereInput
    data: XOR<ArrivalItemsUpdateWithoutQcPhotosInput, ArrivalItemsUncheckedUpdateWithoutQcPhotosInput>
  }

  export type ArrivalItemsUpdateWithoutQcPhotosInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput
    material?: MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput
    condition?: ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput
    parameter?: ParametersUpdateOneWithoutArrivalItemsNestedInput
    qcStatus?: QcStatusUpdateOneWithoutArrivalItemsNestedInput
    QcResults?: QcResultsUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateWithoutQcPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcResults?: QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalsCreateWithoutSecurityPhotosInput = {
    idKedatangan: string
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    supplier: SuppliersCreateNestedOneWithoutArrivalsInput
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutArrivalInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalInput
    ArrivalStatuses?: ArrivalStatusesCreateNestedOneWithoutArrivalInput
  }

  export type ArrivalsUncheckedCreateWithoutSecurityPhotosInput = {
    id?: number
    idKedatangan: string
    supplierId: number
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutArrivalInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalInput
    ArrivalStatuses?: ArrivalStatusesUncheckedCreateNestedOneWithoutArrivalInput
  }

  export type ArrivalsCreateOrConnectWithoutSecurityPhotosInput = {
    where: ArrivalsWhereUniqueInput
    create: XOR<ArrivalsCreateWithoutSecurityPhotosInput, ArrivalsUncheckedCreateWithoutSecurityPhotosInput>
  }

  export type ArrivalsUpsertWithoutSecurityPhotosInput = {
    update: XOR<ArrivalsUpdateWithoutSecurityPhotosInput, ArrivalsUncheckedUpdateWithoutSecurityPhotosInput>
    create: XOR<ArrivalsCreateWithoutSecurityPhotosInput, ArrivalsUncheckedCreateWithoutSecurityPhotosInput>
    where?: ArrivalsWhereInput
  }

  export type ArrivalsUpdateToOneWithWhereWithoutSecurityPhotosInput = {
    where?: ArrivalsWhereInput
    data: XOR<ArrivalsUpdateWithoutSecurityPhotosInput, ArrivalsUncheckedUpdateWithoutSecurityPhotosInput>
  }

  export type ArrivalsUpdateWithoutSecurityPhotosInput = {
    idKedatangan?: StringFieldUpdateOperationsInput | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: SuppliersUpdateOneRequiredWithoutArrivalsNestedInput
    ArrivalItems?: ArrivalItemsUpdateManyWithoutArrivalNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalNestedInput
    ArrivalStatuses?: ArrivalStatusesUpdateOneWithoutArrivalNestedInput
  }

  export type ArrivalsUncheckedUpdateWithoutSecurityPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idKedatangan?: StringFieldUpdateOperationsInput | string
    supplierId?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutArrivalNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalNestedInput
    ArrivalStatuses?: ArrivalStatusesUncheckedUpdateOneWithoutArrivalNestedInput
  }

  export type ArrivalItemsCreateWithoutWeighingsPhotosInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    arrival: ArrivalsCreateNestedOneWithoutArrivalItemsInput
    material: MaterialsCreateNestedOneWithoutArrivalItemsInput
    condition: ConditionsCreateNestedOneWithoutArrivalItemsInput
    parameter?: ParametersCreateNestedOneWithoutArrivalItemsInput
    qcStatus?: QcStatusCreateNestedOneWithoutArrivalItemsInput
    QcResults?: QcResultsCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateWithoutWeighingsPhotosInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsCreateOrConnectWithoutWeighingsPhotosInput = {
    where: ArrivalItemsWhereUniqueInput
    create: XOR<ArrivalItemsCreateWithoutWeighingsPhotosInput, ArrivalItemsUncheckedCreateWithoutWeighingsPhotosInput>
  }

  export type ArrivalItemsUpsertWithoutWeighingsPhotosInput = {
    update: XOR<ArrivalItemsUpdateWithoutWeighingsPhotosInput, ArrivalItemsUncheckedUpdateWithoutWeighingsPhotosInput>
    create: XOR<ArrivalItemsCreateWithoutWeighingsPhotosInput, ArrivalItemsUncheckedCreateWithoutWeighingsPhotosInput>
    where?: ArrivalItemsWhereInput
  }

  export type ArrivalItemsUpdateToOneWithWhereWithoutWeighingsPhotosInput = {
    where?: ArrivalItemsWhereInput
    data: XOR<ArrivalItemsUpdateWithoutWeighingsPhotosInput, ArrivalItemsUncheckedUpdateWithoutWeighingsPhotosInput>
  }

  export type ArrivalItemsUpdateWithoutWeighingsPhotosInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput
    material?: MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput
    condition?: ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput
    parameter?: ParametersUpdateOneWithoutArrivalItemsNestedInput
    qcStatus?: QcStatusUpdateOneWithoutArrivalItemsNestedInput
    QcResults?: QcResultsUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateWithoutWeighingsPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcResults?: QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type UsersCreateWithoutQcHistoriesInput = {
    username: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type UsersUncheckedCreateWithoutQcHistoriesInput = {
    username: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type UsersCreateOrConnectWithoutQcHistoriesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutQcHistoriesInput, UsersUncheckedCreateWithoutQcHistoriesInput>
  }

  export type QcStatusCreateWithoutQcHistoriesInput = {
    name: string
    description?: string | null
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutQcStatusInput
  }

  export type QcStatusUncheckedCreateWithoutQcHistoriesInput = {
    id?: number
    name: string
    description?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutQcStatusInput
  }

  export type QcStatusCreateOrConnectWithoutQcHistoriesInput = {
    where: QcStatusWhereUniqueInput
    create: XOR<QcStatusCreateWithoutQcHistoriesInput, QcStatusUncheckedCreateWithoutQcHistoriesInput>
  }

  export type ArrivalsCreateWithoutQcHistoriesInput = {
    idKedatangan: string
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    supplier: SuppliersCreateNestedOneWithoutArrivalsInput
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutArrivalInput
    SecurityPhotos?: SecurityPhotosCreateNestedManyWithoutArrivalInput
    ArrivalStatuses?: ArrivalStatusesCreateNestedOneWithoutArrivalInput
  }

  export type ArrivalsUncheckedCreateWithoutQcHistoriesInput = {
    id?: number
    idKedatangan: string
    supplierId: number
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutArrivalInput
    SecurityPhotos?: SecurityPhotosUncheckedCreateNestedManyWithoutArrivalInput
    ArrivalStatuses?: ArrivalStatusesUncheckedCreateNestedOneWithoutArrivalInput
  }

  export type ArrivalsCreateOrConnectWithoutQcHistoriesInput = {
    where: ArrivalsWhereUniqueInput
    create: XOR<ArrivalsCreateWithoutQcHistoriesInput, ArrivalsUncheckedCreateWithoutQcHistoriesInput>
  }

  export type ArrivalItemsCreateWithoutQcHistoriesInput = {
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    arrival: ArrivalsCreateNestedOneWithoutArrivalItemsInput
    material: MaterialsCreateNestedOneWithoutArrivalItemsInput
    condition: ConditionsCreateNestedOneWithoutArrivalItemsInput
    parameter?: ParametersCreateNestedOneWithoutArrivalItemsInput
    qcStatus?: QcStatusCreateNestedOneWithoutArrivalItemsInput
    QcResults?: QcResultsCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsUncheckedCreateWithoutQcHistoriesInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutArrivalItemInput
    QcPhotos?: QcPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
    Weighings?: WeighingsUncheckedCreateNestedManyWithoutArrivalItemInput
    WeighingsPhotos?: WeighingsPhotosUncheckedCreateNestedManyWithoutArrivalItemInput
  }

  export type ArrivalItemsCreateOrConnectWithoutQcHistoriesInput = {
    where: ArrivalItemsWhereUniqueInput
    create: XOR<ArrivalItemsCreateWithoutQcHistoriesInput, ArrivalItemsUncheckedCreateWithoutQcHistoriesInput>
  }

  export type QcResultsCreateWithoutHistoryInput = {
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    arrivalItem: ArrivalItemsCreateNestedOneWithoutQcResultsInput
    parameter?: ParametersCreateNestedOneWithoutQcResultsInput
  }

  export type QcResultsUncheckedCreateWithoutHistoryInput = {
    id?: number
    arrivalItemId: number
    parameterId: number
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcResultsCreateOrConnectWithoutHistoryInput = {
    where: QcResultsWhereUniqueInput
    create: XOR<QcResultsCreateWithoutHistoryInput, QcResultsUncheckedCreateWithoutHistoryInput>
  }

  export type QcResultsCreateManyHistoryInputEnvelope = {
    data: QcResultsCreateManyHistoryInput | QcResultsCreateManyHistoryInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutQcHistoriesInput = {
    update: XOR<UsersUpdateWithoutQcHistoriesInput, UsersUncheckedUpdateWithoutQcHistoriesInput>
    create: XOR<UsersCreateWithoutQcHistoriesInput, UsersUncheckedCreateWithoutQcHistoriesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutQcHistoriesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutQcHistoriesInput, UsersUncheckedUpdateWithoutQcHistoriesInput>
  }

  export type UsersUpdateWithoutQcHistoriesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersUncheckedUpdateWithoutQcHistoriesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcStatusUpsertWithoutQcHistoriesInput = {
    update: XOR<QcStatusUpdateWithoutQcHistoriesInput, QcStatusUncheckedUpdateWithoutQcHistoriesInput>
    create: XOR<QcStatusCreateWithoutQcHistoriesInput, QcStatusUncheckedCreateWithoutQcHistoriesInput>
    where?: QcStatusWhereInput
  }

  export type QcStatusUpdateToOneWithWhereWithoutQcHistoriesInput = {
    where?: QcStatusWhereInput
    data: XOR<QcStatusUpdateWithoutQcHistoriesInput, QcStatusUncheckedUpdateWithoutQcHistoriesInput>
  }

  export type QcStatusUpdateWithoutQcHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUpdateManyWithoutQcStatusNestedInput
  }

  export type QcStatusUncheckedUpdateWithoutQcHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutQcStatusNestedInput
  }

  export type ArrivalsUpsertWithoutQcHistoriesInput = {
    update: XOR<ArrivalsUpdateWithoutQcHistoriesInput, ArrivalsUncheckedUpdateWithoutQcHistoriesInput>
    create: XOR<ArrivalsCreateWithoutQcHistoriesInput, ArrivalsUncheckedCreateWithoutQcHistoriesInput>
    where?: ArrivalsWhereInput
  }

  export type ArrivalsUpdateToOneWithWhereWithoutQcHistoriesInput = {
    where?: ArrivalsWhereInput
    data: XOR<ArrivalsUpdateWithoutQcHistoriesInput, ArrivalsUncheckedUpdateWithoutQcHistoriesInput>
  }

  export type ArrivalsUpdateWithoutQcHistoriesInput = {
    idKedatangan?: StringFieldUpdateOperationsInput | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: SuppliersUpdateOneRequiredWithoutArrivalsNestedInput
    ArrivalItems?: ArrivalItemsUpdateManyWithoutArrivalNestedInput
    SecurityPhotos?: SecurityPhotosUpdateManyWithoutArrivalNestedInput
    ArrivalStatuses?: ArrivalStatusesUpdateOneWithoutArrivalNestedInput
  }

  export type ArrivalsUncheckedUpdateWithoutQcHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    idKedatangan?: StringFieldUpdateOperationsInput | string
    supplierId?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutArrivalNestedInput
    SecurityPhotos?: SecurityPhotosUncheckedUpdateManyWithoutArrivalNestedInput
    ArrivalStatuses?: ArrivalStatusesUncheckedUpdateOneWithoutArrivalNestedInput
  }

  export type ArrivalItemsUpsertWithoutQcHistoriesInput = {
    update: XOR<ArrivalItemsUpdateWithoutQcHistoriesInput, ArrivalItemsUncheckedUpdateWithoutQcHistoriesInput>
    create: XOR<ArrivalItemsCreateWithoutQcHistoriesInput, ArrivalItemsUncheckedCreateWithoutQcHistoriesInput>
    where?: ArrivalItemsWhereInput
  }

  export type ArrivalItemsUpdateToOneWithWhereWithoutQcHistoriesInput = {
    where?: ArrivalItemsWhereInput
    data: XOR<ArrivalItemsUpdateWithoutQcHistoriesInput, ArrivalItemsUncheckedUpdateWithoutQcHistoriesInput>
  }

  export type ArrivalItemsUpdateWithoutQcHistoriesInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput
    material?: MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput
    condition?: ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput
    parameter?: ParametersUpdateOneWithoutArrivalItemsNestedInput
    qcStatus?: QcStatusUpdateOneWithoutArrivalItemsNestedInput
    QcResults?: QcResultsUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateWithoutQcHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcResults?: QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type QcResultsUpsertWithWhereUniqueWithoutHistoryInput = {
    where: QcResultsWhereUniqueInput
    update: XOR<QcResultsUpdateWithoutHistoryInput, QcResultsUncheckedUpdateWithoutHistoryInput>
    create: XOR<QcResultsCreateWithoutHistoryInput, QcResultsUncheckedCreateWithoutHistoryInput>
  }

  export type QcResultsUpdateWithWhereUniqueWithoutHistoryInput = {
    where: QcResultsWhereUniqueInput
    data: XOR<QcResultsUpdateWithoutHistoryInput, QcResultsUncheckedUpdateWithoutHistoryInput>
  }

  export type QcResultsUpdateManyWithWhereWithoutHistoryInput = {
    where: QcResultsScalarWhereInput
    data: XOR<QcResultsUpdateManyMutationInput, QcResultsUncheckedUpdateManyWithoutHistoryInput>
  }

  export type ArrivalsCreateWithoutArrivalStatusesInput = {
    idKedatangan: string
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    supplier: SuppliersCreateNestedOneWithoutArrivalsInput
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutArrivalInput
    QcHistories?: QcHistoriesCreateNestedManyWithoutArrivalInput
    SecurityPhotos?: SecurityPhotosCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalsUncheckedCreateWithoutArrivalStatusesInput = {
    id?: number
    idKedatangan: string
    supplierId: number
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutArrivalInput
    QcHistories?: QcHistoriesUncheckedCreateNestedManyWithoutArrivalInput
    SecurityPhotos?: SecurityPhotosUncheckedCreateNestedManyWithoutArrivalInput
  }

  export type ArrivalsCreateOrConnectWithoutArrivalStatusesInput = {
    where: ArrivalsWhereUniqueInput
    create: XOR<ArrivalsCreateWithoutArrivalStatusesInput, ArrivalsUncheckedCreateWithoutArrivalStatusesInput>
  }

  export type ArrivalsUpsertWithoutArrivalStatusesInput = {
    update: XOR<ArrivalsUpdateWithoutArrivalStatusesInput, ArrivalsUncheckedUpdateWithoutArrivalStatusesInput>
    create: XOR<ArrivalsCreateWithoutArrivalStatusesInput, ArrivalsUncheckedCreateWithoutArrivalStatusesInput>
    where?: ArrivalsWhereInput
  }

  export type ArrivalsUpdateToOneWithWhereWithoutArrivalStatusesInput = {
    where?: ArrivalsWhereInput
    data: XOR<ArrivalsUpdateWithoutArrivalStatusesInput, ArrivalsUncheckedUpdateWithoutArrivalStatusesInput>
  }

  export type ArrivalsUpdateWithoutArrivalStatusesInput = {
    idKedatangan?: StringFieldUpdateOperationsInput | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: SuppliersUpdateOneRequiredWithoutArrivalsNestedInput
    ArrivalItems?: ArrivalItemsUpdateManyWithoutArrivalNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalNestedInput
    SecurityPhotos?: SecurityPhotosUpdateManyWithoutArrivalNestedInput
  }

  export type ArrivalsUncheckedUpdateWithoutArrivalStatusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    idKedatangan?: StringFieldUpdateOperationsInput | string
    supplierId?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutArrivalNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalNestedInput
    SecurityPhotos?: SecurityPhotosUncheckedUpdateManyWithoutArrivalNestedInput
  }

  export type ParametersCreateWithoutSettingsInput = {
    name: string
    unit?: string | null
    type?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsCreateNestedManyWithoutParameterInput
    QcResults?: QcResultsCreateNestedManyWithoutParameterInput
  }

  export type ParametersUncheckedCreateWithoutSettingsInput = {
    id?: number
    name: string
    unit?: string | null
    type?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    ArrivalItems?: ArrivalItemsUncheckedCreateNestedManyWithoutParameterInput
    QcResults?: QcResultsUncheckedCreateNestedManyWithoutParameterInput
  }

  export type ParametersCreateOrConnectWithoutSettingsInput = {
    where: ParametersWhereUniqueInput
    create: XOR<ParametersCreateWithoutSettingsInput, ParametersUncheckedCreateWithoutSettingsInput>
  }

  export type ParametersUpsertWithoutSettingsInput = {
    update: XOR<ParametersUpdateWithoutSettingsInput, ParametersUncheckedUpdateWithoutSettingsInput>
    create: XOR<ParametersCreateWithoutSettingsInput, ParametersUncheckedCreateWithoutSettingsInput>
    where?: ParametersWhereInput
  }

  export type ParametersUpdateToOneWithWhereWithoutSettingsInput = {
    where?: ParametersWhereInput
    data: XOR<ParametersUpdateWithoutSettingsInput, ParametersUncheckedUpdateWithoutSettingsInput>
  }

  export type ParametersUpdateWithoutSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUpdateManyWithoutParameterNestedInput
    QcResults?: QcResultsUpdateManyWithoutParameterNestedInput
  }

  export type ParametersUncheckedUpdateWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutParameterNestedInput
    QcResults?: QcResultsUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type QcHistoriesCreateManyUserInput = {
    id?: number
    statusId: number
    arrivalId?: number | null
    arrivalItemId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QcHistoriesUpdateWithoutUserInput = {
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: QcStatusUpdateOneRequiredWithoutQcHistoriesNestedInput
    arrival?: ArrivalsUpdateOneWithoutQcHistoriesNestedInput
    arrivalItem?: ArrivalItemsUpdateOneWithoutQcHistoriesNestedInput
    QcResults?: QcResultsUpdateManyWithoutHistoryNestedInput
  }

  export type QcHistoriesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusId?: IntFieldUpdateOperationsInput | number
    arrivalId?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalItemId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QcResults?: QcResultsUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type QcHistoriesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusId?: IntFieldUpdateOperationsInput | number
    arrivalId?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalItemId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArrivalsCreateManySupplierInput = {
    id?: number
    idKedatangan: string
    arrivalDate?: Date | string
    arrivalTime?: string | null
    nopol?: string | null
    suratJalan?: string | null
    city?: string | null
    note?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ArrivalsUpdateWithoutSupplierInput = {
    idKedatangan?: StringFieldUpdateOperationsInput | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUpdateManyWithoutArrivalNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalNestedInput
    SecurityPhotos?: SecurityPhotosUpdateManyWithoutArrivalNestedInput
    ArrivalStatuses?: ArrivalStatusesUpdateOneWithoutArrivalNestedInput
  }

  export type ArrivalsUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    idKedatangan?: StringFieldUpdateOperationsInput | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalItems?: ArrivalItemsUncheckedUpdateManyWithoutArrivalNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalNestedInput
    SecurityPhotos?: SecurityPhotosUncheckedUpdateManyWithoutArrivalNestedInput
    ArrivalStatuses?: ArrivalStatusesUncheckedUpdateOneWithoutArrivalNestedInput
  }

  export type ArrivalsUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    idKedatangan?: StringFieldUpdateOperationsInput | string
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    nopol?: NullableStringFieldUpdateOperationsInput | string | null
    suratJalan?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArrivalItemsCreateManyMaterialInput = {
    id?: number
    arrivalId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
  }

  export type ArrivalItemsUpdateWithoutMaterialInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput
    condition?: ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput
    parameter?: ParametersUpdateOneWithoutArrivalItemsNestedInput
    qcStatus?: QcStatusUpdateOneWithoutArrivalItemsNestedInput
    QcResults?: QcResultsUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcResults?: QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArrivalItemsCreateManyConditionInput = {
    id?: number
    arrivalId: number
    materialId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
  }

  export type ArrivalItemsUpdateWithoutConditionInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput
    material?: MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput
    parameter?: ParametersUpdateOneWithoutArrivalItemsNestedInput
    qcStatus?: QcStatusUpdateOneWithoutArrivalItemsNestedInput
    QcResults?: QcResultsUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateWithoutConditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcResults?: QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateManyWithoutConditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArrivalItemsCreateManyParameterInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
  }

  export type QcResultsCreateManyParameterInput = {
    id?: number
    arrivalItemId: number
    historyId?: number | null
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ParameterSettingsCreateManyParameterInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type ArrivalItemsUpdateWithoutParameterInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput
    material?: MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput
    condition?: ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput
    qcStatus?: QcStatusUpdateOneWithoutArrivalItemsNestedInput
    QcResults?: QcResultsUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateWithoutParameterInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcResults?: QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateManyWithoutParameterInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QcResultsUpdateWithoutParameterInput = {
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalItem?: ArrivalItemsUpdateOneRequiredWithoutQcResultsNestedInput
    history?: QcHistoriesUpdateOneWithoutQcResultsNestedInput
  }

  export type QcResultsUncheckedUpdateWithoutParameterInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    historyId?: NullableIntFieldUpdateOperationsInput | number | null
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcResultsUncheckedUpdateManyWithoutParameterInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    historyId?: NullableIntFieldUpdateOperationsInput | number | null
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParameterSettingsUpdateWithoutParameterInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParameterSettingsUncheckedUpdateWithoutParameterInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParameterSettingsUncheckedUpdateManyWithoutParameterInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArrivalItemsCreateManyArrivalInput = {
    id?: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcStatusId?: number | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
  }

  export type QcHistoriesCreateManyArrivalInput = {
    id?: number
    userId: string
    statusId: number
    arrivalItemId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityPhotosCreateManyArrivalInput = {
    id?: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ArrivalItemsUpdateWithoutArrivalInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    material?: MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput
    condition?: ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput
    parameter?: ParametersUpdateOneWithoutArrivalItemsNestedInput
    qcStatus?: QcStatusUpdateOneWithoutArrivalItemsNestedInput
    QcResults?: QcResultsUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateWithoutArrivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcResults?: QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateManyWithoutArrivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QcHistoriesUpdateWithoutArrivalInput = {
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutQcHistoriesNestedInput
    status?: QcStatusUpdateOneRequiredWithoutQcHistoriesNestedInput
    arrivalItem?: ArrivalItemsUpdateOneWithoutQcHistoriesNestedInput
    QcResults?: QcResultsUpdateManyWithoutHistoryNestedInput
  }

  export type QcHistoriesUncheckedUpdateWithoutArrivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QcResults?: QcResultsUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type QcHistoriesUncheckedUpdateManyWithoutArrivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityPhotosUpdateWithoutArrivalInput = {
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityPhotosUncheckedUpdateWithoutArrivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityPhotosUncheckedUpdateManyWithoutArrivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcResultsCreateManyArrivalItemInput = {
    id?: number
    parameterId: number
    historyId?: number | null
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcPhotosCreateManyArrivalItemInput = {
    id?: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type WeighingsCreateManyArrivalItemInput = {
    id?: number
    weight: number
    note?: string | null
    weighingDate?: Date | string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type WeighingsPhotosCreateManyArrivalItemInput = {
    id?: number
    photo: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcHistoriesCreateManyArrivalItemInput = {
    id?: number
    userId: string
    statusId: number
    arrivalId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QcResultsUpdateWithoutArrivalItemInput = {
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    parameter?: ParametersUpdateOneWithoutQcResultsNestedInput
    history?: QcHistoriesUpdateOneWithoutQcResultsNestedInput
  }

  export type QcResultsUncheckedUpdateWithoutArrivalItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    parameterId?: IntFieldUpdateOperationsInput | number
    historyId?: NullableIntFieldUpdateOperationsInput | number | null
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcResultsUncheckedUpdateManyWithoutArrivalItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    parameterId?: IntFieldUpdateOperationsInput | number
    historyId?: NullableIntFieldUpdateOperationsInput | number | null
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcPhotosUpdateWithoutArrivalItemInput = {
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcPhotosUncheckedUpdateWithoutArrivalItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcPhotosUncheckedUpdateManyWithoutArrivalItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsUpdateWithoutArrivalItemInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    weighingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsUncheckedUpdateWithoutArrivalItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    weighingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsUncheckedUpdateManyWithoutArrivalItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    weighingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsPhotosUpdateWithoutArrivalItemInput = {
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsPhotosUncheckedUpdateWithoutArrivalItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcHistoriesUpdateWithoutArrivalItemInput = {
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutQcHistoriesNestedInput
    status?: QcStatusUpdateOneRequiredWithoutQcHistoriesNestedInput
    arrival?: ArrivalsUpdateOneWithoutQcHistoriesNestedInput
    QcResults?: QcResultsUpdateManyWithoutHistoryNestedInput
  }

  export type QcHistoriesUncheckedUpdateWithoutArrivalItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
    arrivalId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QcResults?: QcResultsUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type QcHistoriesUncheckedUpdateManyWithoutArrivalItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
    arrivalId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArrivalItemsCreateManyQcStatusInput = {
    id?: number
    arrivalId: number
    materialId: number
    conditionId: number
    parameterId?: number | null
    conditionCategory?: string | null
    quantity: number
    note?: string | null
    itemName?: string | null
    qcNote?: string | null
    qcAnalysis?: string | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    statusQc?: boolean
  }

  export type QcHistoriesCreateManyStatusInput = {
    id?: number
    userId: string
    arrivalId?: number | null
    arrivalItemId?: number | null
    qcSample?: number | null
    qcKotoran?: number | null
    totalBerat?: number | null
    pengeringan?: number | null
    note?: string | null
    qcNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArrivalItemsUpdateWithoutQcStatusInput = {
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    arrival?: ArrivalsUpdateOneRequiredWithoutArrivalItemsNestedInput
    material?: MaterialsUpdateOneRequiredWithoutArrivalItemsNestedInput
    condition?: ConditionsUpdateOneRequiredWithoutArrivalItemsNestedInput
    parameter?: ParametersUpdateOneWithoutArrivalItemsNestedInput
    QcResults?: QcResultsUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateWithoutQcStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
    QcResults?: QcResultsUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcPhotos?: QcPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    Weighings?: WeighingsUncheckedUpdateManyWithoutArrivalItemNestedInput
    WeighingsPhotos?: WeighingsPhotosUncheckedUpdateManyWithoutArrivalItemNestedInput
    QcHistories?: QcHistoriesUncheckedUpdateManyWithoutArrivalItemNestedInput
  }

  export type ArrivalItemsUncheckedUpdateManyWithoutQcStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    parameterId?: NullableIntFieldUpdateOperationsInput | number | null
    conditionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    qcAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    statusQc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QcHistoriesUpdateWithoutStatusInput = {
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutQcHistoriesNestedInput
    arrival?: ArrivalsUpdateOneWithoutQcHistoriesNestedInput
    arrivalItem?: ArrivalItemsUpdateOneWithoutQcHistoriesNestedInput
    QcResults?: QcResultsUpdateManyWithoutHistoryNestedInput
  }

  export type QcHistoriesUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    arrivalId?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalItemId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QcResults?: QcResultsUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type QcHistoriesUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    arrivalId?: NullableIntFieldUpdateOperationsInput | number | null
    arrivalItemId?: NullableIntFieldUpdateOperationsInput | number | null
    qcSample?: NullableFloatFieldUpdateOperationsInput | number | null
    qcKotoran?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBerat?: NullableFloatFieldUpdateOperationsInput | number | null
    pengeringan?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qcNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QcResultsCreateManyHistoryInput = {
    id?: number
    arrivalItemId: number
    parameterId: number
    resultKey: string
    value: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type QcResultsUpdateWithoutHistoryInput = {
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalItem?: ArrivalItemsUpdateOneRequiredWithoutQcResultsNestedInput
    parameter?: ParametersUpdateOneWithoutQcResultsNestedInput
  }

  export type QcResultsUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    parameterId?: IntFieldUpdateOperationsInput | number
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QcResultsUncheckedUpdateManyWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivalItemId?: IntFieldUpdateOperationsInput | number
    parameterId?: IntFieldUpdateOperationsInput | number
    resultKey?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}